<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0052)http://people.ne.mediaone.net/abrahams/abrahams.html -->

    <meta name="generator" content="Microsoft FrontPage 5.0">
    <title>Exception-Safety in Generic Components</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta content="MSHTML 5.50.4522.1800" name="GENERATOR">

    <h1 align="center">Exception-Safety in Generic Components</h1>

    <p align="center"><i><b>Lessons Learned from Specifying Exception-Safety
    for the C++ Standard Library</b></i>

    <h3 align="center">David Abrahams</h3>

    <h3 align="center"><a href="mailto:david.abrahams@rcn.com">
    david.abrahams@rcn.com</a></h3>

<!--    <p><b>Abstract.</b> This paper represents the knowledge accumulated in
    response to a real-world need: that the C++ Standard Template Library
    exhibit useful and well-defined interactions with exceptions, the
    error-handling mechanism built-in to the core C++ language. It explores the
    meaning of exception-safety, reveals surprising myths about exceptions and
    genericity, describes valuable tools for reasoning about program
    correctness, and outlines an automated testing procedure for verifying
    exception-safety.-->
    <p><b>概要</b> この文書は実世界の必要性に対する応答の中で蓄積された知識を表す:
    つまり、 C++ 標準テンプレートライブラリは、役立つ、そして明確な例外との相互作用を示し、
    エラー捕捉の機構は C++ 言語の中核に組み込まれている。
    この文書では、例外安全性の意味を探求し、例外と汎用性についての驚くべき神話を明らかにし、
    プログラムの正当性を理由付けるための価値ある道具について述べ、
    例外安全性を実証するための自動化されたテストの手続きを概説する。

    <p><b>Keywords:</b> exception-safety, exceptions, STL, C++

    <h2>1 What is exception-safety?</h2>

<!--    <p>Informally, exception-safety in a component means that it exhibits
    reasonable behavior when an exception is thrown during its execution. For
    most people, the term ``reasonable'' includes all the usual
    expectations for error-handling: that resources should not be leaked, and
    that the program should remain in a well-defined state so that execution
    can continue. For most components, it also includes the expectation that
    when an error is encountered, it is reported to the caller.-->
    <p>簡単に言えば、コンポーネントの例外安全性とは、
    実行中に例外が投げられたとき、正当な振る舞いを示すことを意味する。
    ほとんどの人にとって、``正当な''という用語は、エラー捕捉に対する通常の例外全てを含む:
    つまり、資源は漏れるべきではないし、プログラムは実行を継続できるように、
    明確な状態であり続けるべきである。多くのコンポーネントにとって、
    これはまた、エラーに出会った時に呼び出し元に報告されるような例外も含む。

<!--    <p>More formally, we can describe a component as minimally exception-safe
    if, when exceptions are thrown from within that component, its invariants
    are intact. Later on we'll see that at least three different levels of
    exception-safety can be usefully distinguished. These distinctions can help
    us to describe and reason about the behavior of large systems.-->
    <p>より公式に言えば、コンポーネントの中から例外が投げられたときに、
    もしその不変性が損なわれないなら、そのコンポーネントは最小限の例外安全性を持っていると言える。
    後に見るが、通常、少なくとも3種類の異なる例外安全性が区別されている。
    これらの区別は巨大なシステムの振る舞いについて記述し、理由付けるのに役立つのである。

<!--    <p>In a generic component, we usually have an additional expectation of
    <i>exception-neutrality</i>, which means that exceptions thrown by a
    component's type parameters should be propagated, unchanged, to the
    component's caller.-->
    <p>汎用コンポーネントでは、通常我々は、さらに、<i>例外中立性</i>という期待をもつ。
    これは、コンポーネントの型パラメータによって投げられた例外は、
    そのコンポーネントの呼び出し元まで、変わることなく伝えられるべきである、
    ということを意味する。

    <h2>2 Myths and Superstitions</h2>

<!--    <p>Exception-safety seems straightforward so far: it doesn't constitute
    anything more than we'd expect from code using more traditional
    error-handling techniques. It might be worthwhile, however, to examine the
    term from a psychological viewpoint. Nobody ever spoke of
    ``error-safety'' before C++ had exceptions.-->
    <p>例外安全性は、これまでのところ簡単なものに見える:
    それは、より伝統的なエラー捕捉の技術を使ったコードに期待する以上のことを、
    何も構築したりはしない。しかし、心理学的な観点からこの用語を調べてみることは、価値があるだろう。
    C++ が例外を持つ以前は、誰も``エラー安全性''について語らなかった。
    

<!--    <p>It's almost as though exceptions are viewed as a <i>mysterious
    attack</i> on otherwise correct code, from which we must protect ourselves.
    Needless to say, this doesn't lead to a healthy relationship with error
    handling! During standardization, a democratic process which requires broad
    support for changes, I encountered many widely-held superstitions. In order
    to even begin the discussion of exception-safety in generic components, it
    may be worthwhile confronting a few of them.-->
    <p>まるで例外は、正しいコードに対する<i>ミステリアスな攻撃</i>であり、
    我々が自らをその攻撃から守らなければいけないようなものであると見なされているかのようである。
    言うまでもなく、これはエラー捕捉との健全な関係に繋がらない!
    標準化の間、変更に対する幅広いサポートを要求する民主的な過程で、
    私は広く支持された多くの迷信に出会った。
    汎用コンポーネントにおける例外安全性の議論を始めるために、
    それらのいくつかを見ておくことは意味のあることだろう。

<!--    <p><i>``Interactions between templates and exceptions are not
    well-understood.''</i> This myth, often heard from those who consider
    these both new language features, is easily disposed of: there simply are
    no interactions. A template, once instantiated, works in all respects like
    an ordinary class or function. A simple way to reason about the behavior of
    a template with exceptions is to think of how a specific instantiation of
    that template works. Finally, the genericity of templates should not cause
    special concern. Although the component's client supplies part of the
    operation (which may, unless otherwise specified, throw arbitrary
    exceptions), the same is true of operations using familiar virtual
    functions or simple function pointers.-->
    <p><i>``テンプレートと例外の相互作用は、良く理解できない。''</i>
    これら両方が言語の新しい特徴であると考える人々から良く聞かれるこの神話は、
    簡単に却下できる: そこには、相互作用はないのである。
    テンプレートは、一度実体化されれば、全ての面で通常のクラスや関数と同じように機能する。
    例外と関連したテンプレートの振る舞いを考えるための単純な方法は、
    そのテンプレートの特別版の実体化がどう機能するかについて考えることである。
    最後に、テンプレートの汎用性は、何も特別なことを引き起こさない。
    コンポーネントのクライアントは操作の一部を提供するが(この操作は、もし特別版でないなら、
    任意の例外を投げるだろう)、我々が良く親しんだ仮想関数や、
    単純な関数ポインタを使った操作についても、同じことなのである。

<!--    <p><i>``It is well known to be impossible to write an exception-safe
    generic container.''</i> This claim is often heard with reference to
    an article by Tom Cargill <a title=
    "Tom Cargill, ``Exception Handling: A False Sense of Security'', C++ Report, Nov-Dec 1994"
     href=
    "#reference4"><sup>[4]</sup></a>
    in which he explores the problem of exception-safety for a generic stack
    template. In his article, Cargill raises many useful questions, but
    unfortunately fails to present a solution to his problem.<a title=
    "Probably the greatest impediment to a solution in Cargill's case was an unfortunate combination of choices on his part: the interface he chose for his container was incompatible with his particular demands for safety. By changing either one he might have solved the problem."
     href=
    "#footnote1"><sup>1</sup></a>
    He concludes by suggesting that a solution may not be possible.
    Unfortunately, his article was read by many as ``proof'' of that
    speculation. Since it was published there have been many examples of
    exception-safe generic components, among them the C++ standard library
    containers.-->
    <p><i>``例外安全性をもつ汎用コンテナを書くのが不可能であることは、
    良く知られている''</i>
    この主張は、Tom Cargill による文書、 <a title=
    "Tom Cargill, ``Exception Handling: A False Sense of Security'', C++ Report, Nov-Dec 1994"
    href="#reference4"><sup>[4]</sup></a>
    に関連してよく聞かれる。そこで彼は、汎用スタックテンプレートに対する例外安全性の問題について探求している。
    彼の文書で、 Cargill は多くの役立つ問題を掲げているが、
    残念ながらそれらの問題に対する解決法を提供できていない。
    <a title="Probably the greatest impediment to a solution in Cargill's case was an unfortunate combination of choices on his part: the interface he chose for his container was incompatible with his particular demands for safety. By changing either one he might have solved the problem." href="#footnote1"><sup>1</sup></a>
    彼は解決は不可能である、と提案して結論付けている。不幸にも彼の文書は、
    多くの人に、そのような空論の ``証拠'' として読まれてしまった。
    しかしこの文書が出版されてから、例外安全な汎用コンテナの多くの実例があったのである。
    C++ 標準ライブラリコンテナもその中にはいる。
    
<!--    <p><i>``Dealing with exceptions will slow code down, and templates are
    used specifically to get the best possible performance.''</i> A good
    implementation of C++ will not devote a single instruction cycle to dealing
    with exceptions until one is thrown, and then it can be handled at a speed
    comparable with that of calling a function <a title=
    "D. R. Musser, ``Introspective Sorting and Selection Algorithms'', Software-Practice and Experience 27(8):983-993, 1997."
     href=
    "#reference7"><sup>[7]</sup></a>.
    That alone gives programs using exceptions performance equivalent to that
    of a program which ignores the possibility of errors. Using exceptions can
    actually result in faster programs than ``traditional'' error
    handling methods for other reasons. First, a catch block clearly indicates
    to the compiler which code is devoted to error-handling; it can then be
    separated from the usual execution path, improving locality of reference.
    Second, code using ``traditional'' error handling must typically
    test a return value for errors after every single function call; using
    exceptions completely eliminates that overhead.-->
    <p><i>``例外を扱うとコードは遅くなり、テンプレートは本質的に
    可能な限りのパフォーマンスを得るために使われる。''</i>
    C++ の優れた実装は、例外が投げられるまでにその例外を扱うひとつの命令サイクルを費やすことはしないで、
    例外は関数呼び出しの同じようなスピードで捕捉可能である
    <a title="D. R. Musser, ``Introspective Sorting and Selection Algorithms'', Software-Practice and Experience 27(8):983-993, 1997." href="#reference7"><sup>[7]</sup></a>。
    それだけで、例外を使ったプログラムに、
    エラーの可能性を無視したプログラムと同等のパフォーマンスを提供している。
    例外を使うと実際は、結果的に別の理由で``伝統的な''エラー捕捉の方法よりも早くなる。
    まず、 catch 節はコンパイラに、どのコードがエラー捕捉に費やされるかを明確に示す。
    このため、通常の実行パスから分離することが可能であり、参照の局所性が改善する。
    次に、``伝統的な''エラー捕捉を使ったコードは典型的に、単一の関数を呼び出した後、
    いつも返り値を検査しなければならない。
    例外を使えば、このオーバヘッドは完全に消える。

<!--    <p><i>``Exceptions make it more difficult to reason about a program's
    behavior.''</i> Usually cited in support of this myth is the way
    ``hidden'' execution paths are followed during stack-unwinding.
    Hidden execution paths are nothing new to any C++ programmer who expects
    local variables to be destroyed upon returning from a function:-->
    <p><i>``例外はプログラムの振る舞いを推論することを難しくしてしまう''</i>
    通常、この神話が支持されて引用されるのは、
    スタック巻き戻しの間に``隠れた''実行パスを通る、という意味においてである。
    隠れた実行パスはローカル変数が関数から戻る前に破棄されることを期待している C++ プログラマにとっては、
    なにも新しいものではない。

    <blockquote>
<pre>ErrorCode f( int&amp; result )         // 1 
{                                  // 2 
    X x;                           // 3 
    ErrorCode err = x.g( result ); // 4 
    if ( err != kNoError )         // 5 
        return err;                // 6 
    // ...More code here... 
    return kNoError;               // 7 
}
</pre>
    </blockquote>

<!--    <p>In the example above, there is a ``hidden'' call to
    <code>X::~X()</code> in lines 6 and 7. Granted, using exceptions, there is
    no code devoted to error handling visible:-->
    <p>上の例では、6行目と7行目に <code>X::~X</code> の``隠れた''呼び出しがある。
    そう考えれば、例外を使うことで、エラー捕捉に対して、明白なコードの無駄は存在しない。

    <blockquote>
<pre>int f()                 // 1 
{                       // 2 
    X x;                // 3 
    int result = x.g(); // 4 
    // ...More code here... 
    return result;      // 5 
} 
</pre>
    </blockquote>

<!--    <p>For many programmers more familiar with exceptions, the second example
    is actually more readable and understandable than the first. The
    ``hidden'' code paths include the same calls to destructors of
    local variables. In addition, they follow a simple pattern which acts
    <i>exactly</i> as though there were a potential return statement after each
    function call in case of an exception. Readability is enhanced because the
    normal path of execution is unobscured by error-handling, and return values
    are freed up to be used in a natural way.-->
    例外をより良く知っている多くのプログラマにとって、2番目の例は実際は最初の例よりも、
    読みやすく理解しやすい。
    ``隠れた''コードパスは同じくローカル変数のデストラクタを呼び出している。
    更にこれは、冷害が起こった場合にそれぞれの関数呼び出しの後に、
    潜在的なリターン文があるかのような、<i>正確に</i>振る舞う単純なパターンに従うのである。
    通常の実行パスはエラー捕捉によって分かりにくくならないので、可読性は向上し、
    返り値は自然なやり方で使えるように解放されるのである。

<!--    <p>There is an even more important way in which exceptions can enhance
    correctness: by allowing simple class invariants. In the first example, if
    <code>x</code>'s constructor should need to allocate resources, it has no
    way to report a failure: in C++, constructors have no return values. The
    usual result when exceptions are avoided is that classes requiring
    resources must include a separate initializer function which finishes the
    job of construction. The programmer can therefore never be sure, when an
    object of class <code>X</code> is used, whether he is handling a
    full-fledged <code>X</code> or some abortive attempt to construct one (or
    worse: someone simply forgot to call the initializer!)-->
    例外が正確さを向上することが出来る、さらに重要なやり方がある: それは、
    単純なクラス不変性を可能にすることによる。
    最初の例では、もし <code>X</code> のコンストラクタが資源を確保する必要があるなら、
    失敗を報告する手だてはない: C++ ではコンストラクタは返り値を持てないからである。
    例外を使わない場合は通常、資源を要求するクラスが構築の仕事を完了する、
    別の初期化関数を含まなければならない、という結果になる。
    プログラマはそのため、クラス <code>X</code> のオブジェクトが使われるとき、
    完全な <code>X</code> を手にしたのか、それともどこかで構築に失敗したものを手にしたのか、
    決して確信をもてない(或いは更に悪いことに、誰かが単に初期化関数を呼び忘れたのかもしれない。)

    <h2>3 A contractual basis for exception-safety</h2>

<!--    <p>A non-generic component can be described as exception-safe in isolation,
    but because of its configurability by client code, exception-safety in a
    generic component usually depends on a contract between the component and
    its clients. For example, the designer of a generic component might require
    that an operation which is used in the component's destructor not throw any
    exceptions.<a title=
    " It is usually inadvisable to throw an exception from a destructor in C++, since the destructor may itself be called during the stack-unwinding caused by another exception. If the second exception is allowed to propagate beyond the destructor, the program is immediately terminated."
     href=
    "#footnote2"><sup>2</sup></a>
    The generic component might, in return, provide one of the following
    guarantees:-->
    非汎用的なコンポーネントは例外安全として記述することが出来るが、
    汎用的なコンポーネントの場合は、クライアントによる構造化が可能なので、
    例外安全性は通常、コンポーネントとクライアントの契約に依存する。
    例えば、汎用的コンポーネントの設計者はコンポーネントのデストラクタで使われる演算が、
    どんな例外も投げないことを要求するだろう。<a title=
    " It is usually inadvisable to throw an exception from a destructor in C++, since the destructor may itself be called during the stack-unwinding caused by another exception. If the second exception is allowed to propagate beyond the destructor, the program is immediately terminated."
     href=
    "#footnote2"><sup>2</sup></a>
    汎用的コンポーネントはその代わり、次の保証のうちのひとつを提供するだろう。
    

    <ul>
<!--      <li>The <i>basic</i> guarantee: that the invariants of the component are
      preserved, and no resources are leaked.

      <li>The <i>strong</i> guarantee: that the operation has either completed
      successfully or thrown an exception, leaving the program state exactly as
      it was before the operation started.

      <li>The <i>no-throw</i> guarantee: that the operation will not throw an
      exception.-->
      <li><i>基本的</i>保証: コンポーネントの不変性は保持され、資源漏れはない。</li>
      <li><i>強い</i>保証: 演算は成功して完了するか、例外を投げるかのどちらかである。
      例外を投げる場合、プログラムの状態は演算が始まる前の状態と全く同じである。</li>
      <li><i>例外不送出</i>保証: 演算は例外を投げない。
    </ul>

<!--    <p>The basic guarantee is a simple minimum standard for exception-safety to
    which we can hold all components. It says simply that after an exception,
    the component can still be used as before. Importantly, the preservation of
    invariants allows the component to be destroyed, potentially as part of
    stack-unwinding. This guarantee is actually less useful than it might at
    first appear. If a component has many valid states, after an exception we
    have no idea what state the component is in|only that the state is valid.
    The options for recovery in this case are limited: either destruction or
    resetting the component to some known state before further use. Consider
    the following example:-->
    <p>基本的保証は、全てのコンポーネントに負わせることの出来る、
    例外安全性に対する単純で最小限の基準である。
    例外の後でもまだコンポーネントは以前のように使うことが出来ると述べているに過ぎない。
    重要なことだが、不変性の保持によって、スタック巻き戻しの一部として潜在的に、
    コンポーネントを破棄することが出来るのである。
    この保証は実際には、見た目ほど役立つものではない。
    もしコンポーネントが多くの有効状態を持つなら、例外の後にコンポーネントの状態が、
    またはその状態だけが有効な状態なのかどうか知ることは出来ない。
    この場合、回復のための選択肢は限られている: コンポーネントの破棄か、
    さらに使う前に、ある既知の状態にコンポーネントをリセットするかである。
    次の例を考えてみよう:
    

    <blockquote>
<pre>template &lt;class X&gt; 
void print_random_sequence() 
{ 
    std::vector&lt;X&gt; v(10); // A vector of 10 items 
    try { 
        // Provides only the <i>basic</i> guarantee 
        v.insert( v.begin(), X() ); 
    } 
    catch(...) {} // ignore any exceptions above 
    // print the vector's contents 
    std::cout "(" &lt;&lt; v.size() &lt;&lt; ") "; 
    std::copy( v.begin(), v.end(), 
    std::ostream_iterator&lt;X&gt;( std::cout, " " ) ); 
} 
</pre>
    </blockquote>

<!--    <p>Since all we know about v after an exception is that it is valid, the
    function is allowed to print any random sequence of <code>X</code>s.<a
    title=
    "In practice of course, this function would make an extremely poor random sequence generator!"
     href=
    "#footnote3"><sup>3</sup></a>
    It is ``safe'' in the sense that it is not allowed to crash, but
    its output may be unpredictable.-->
    <p>我々はみんな、例外後に v が有効であることを知っているので、
    この関数は <code>X</code> のどんなランダムなシーケンスでも出力することが出来る。
    <a
    title=
    "In practice of course, this function would make an extremely poor random sequence generator!"
     href=
    "#footnote3"><sup>3</sup></a>
    これはクラッシュしないと言う意味で``安全''ではあるが、出力の内容は予想できないものである。

<!--    <p>The <i>strong</i> guarantee provides full
    ``commit-or-rollback'' semantics. In the case of C++ standard
    containers, this means, for example, that if an exception is thrown all
    iterators remain valid. We also know that the container has exactly the
    same elements as before the exception was thrown. A transaction that has no
    effects if it fails has obvious benefits: the program state is simple and
    predictable in case of an exception. In the C++ standard library, nearly
    all of the operations on the node-based containers list, set, multiset,
    map, and multimap provide the <i>strong</i> guarantee.<a title=
    "It is worth noting that mutating algorithms usually cannot provide the strong guarantee: to roll back a modified element of a range, it must be set back to its previous value using operator=, which itself might throw. In the C++ standard library, there are a few exceptions to this rule, whose rollback behavior consists only of destruction: uninitialized_copy, uninitialized_fill, and uninitialized_fill_n."
     href=
    "#footnote4"><sup>4</sup></a>).-->
    <p><i>強い</i>保証は、``責任を持つか、巻き戻すか''という意味論を完全に提供する。
    C++ 標準コンテナの場合、これは例えばもし例外が投げられても全てのイテレータは有効なままであることを意味する。
    我々はまた、コンテナが例外が投げられる前と全く同じ要素を持っていることも知っている。
    失敗したら、なんの効果も及ぼさない処理は、明らかに利点がある: 例外が発生した場合でも、
    プログラムの状態は単純で予測可能なのである。
    C++ 標準ライブラリでは、ノードを使うコンテナ、list, set, multiset, map, maltimap 
    のほとんど全ての演算が<i>強い</i>保証を提供している。
    <a title=
    "It is worth noting that mutating algorithms usually cannot provide the strong guarantee: to roll back a modified element of a range, it must be set back to its previous value using operator=, which itself might throw. In the C++ standard library, there are a few exceptions to this rule, whose rollback behavior consists only of destruction: uninitialized_copy, uninitialized_fill, and uninitialized_fill_n."
     href="#footnote4"><sup>4</sup></a>)

<!--    <p>The <i>no-throw</i> guarantee is the strongest of all, and it says that
    an operation is guaranteed not to throw an exception: it always completes
    successfully. This guarantee is necessary for most destructors, and indeed
    the destructors of C++ standard library components are all guaranteed not
    to throw exceptions. The <i>no-throw</i> guarantee turns out to be
    important for other reasons, as we shall see.<a title=
    "All type parameters supplied by clients of the C++ standard library are required not to throw from their destructors. In return, all components of the C++ standard library provide at least the basic guarantee."
     href=
    "#footnote5"><sup>5</sup></a>-->
   <p><i>例外不送出</i>保証は最も強いものであり、演算は例外を投げないことを保証されている、
   というものである: これは常に成功して完了する。
   この保証はほとんどのデストラクタにとって必要なものであり、
   C++ 標準ライブラリコンポーネントのデストラクタは実際にすべて、
   例外を投げないことを保証されている。
   <i>例外不送出</i>保証、他の理由で重要となることを我々は見るだろう。
<a title=
    "All type parameters supplied by clients of the C++ standard library are required not to throw from their destructors. In return, all components of the C++ standard library provide at least the basic guarantee."
     href=
    "#footnote5"><sup>5</sup></a>

    <h2>4 Legal Wrangling</h2>

<!--    <p>Inevitably, the contract can get more complicated: a quid pro quo
    arrangement is possible. Some components in the C++ Standard Library give
    one guarantee for arbitrary type parameters, but give a stronger guarantee
    in exchange for additional promises from the client type that no exceptions
    will be thrown. For example, the standard container operation
    <code>vector&lt;T&gt;::erase</code> gives the <i>basic</i> guarantee for
    any <code>T</code>, but for types whose copy constructor and copy
    assignment operator do not throw, it gives the <i>no-throw</i> guarantee.<a
    title=
    "Similar arrangements might have been made in the C++ standard for many of the mutating algorithms, but were never considered due to time constraints on the standardization process."
     href=
    "#footnote6"><sup>6</sup></a>-->
    <p>契約がより複雑になることを避けることは出来ない: その代わり整理することが可能である。
    C++ 標準ライブラリには、任意の型引数にひとつの保証を与え、
    例外を投げないというクライアント型からの約束が追加されれれば、より強い保証を与えているものもある。
    例えば、標準コンテナ操作 <code>vector&lt;T&gt;::erase</code> はどんな <code>T</code>
    にも<i>基本的</i>保証を与えるが、コピーコンストラクタとコピー代入演算子が例外を投げないなら、
    <i>例外不送出</i>保証を与えている。
    <a title=
    "Similar arrangements might have been made in the C++ standard for many of the mutating algorithms, but were never considered due to time constraints on the standardization process."
     href=
    "#footnote6"><sup>6</sup></a>

    <h2>5 What level of exception-safety should a component specify?</h2>

<!--    <p>From a client's point-of-view, the strongest possible level of safety
    would be ideal. Of course, the <i>no-throw</i> guarantee is simply
    impossible for many operations, but what about the <i>strong</i> guarantee?
    For example, suppose we wanted atomic behavior for
    <code>vector&lt;T&gt;::insert</code>. Insertion into the middle of a vector
    requires copying elements after the insertion point into later positions,
    to make room for the new element. If copying an element can fail, rolling
    back the operation would require ``undoing'' the previous
    copies...which depends on copying again. If copying back should fail (as it
    likely would), we have failed to meet our guarantee.-->
    <p>クライアントの観点から、可能な限り最も強いレベルの安全性が理想的である。
    もちろん<i>例外不送出</i>保証は多くの演算に対して不可能であるが、
    <i>強い</i>保証についてはどうだろうか?
    例えば、 <code>vector&lt;T&gt;::insert</code> に対してちょっとした振る舞いが欲しいと仮定しよう。
    vector の中間への挿入は、新しい要素のための場所を作るために、
    挿入点以降の要素を、次の位置にコピーする必要がある。
    もし要素のコピーが失敗に終われば、操作の巻き戻しは既に行われたコピーの``取り消し''を必要とする。
    
    

<!--    <p>One possible alternative would be to redefine <code>insert</code> to
    build the new array contents in a fresh piece of memory each time, and only
    destroy the old contents when that has succeeded. Unfortunately, there is a
    non-trivial cost if this approach is followed: insertions near the end of a
    vector which might have previously caused only a few copies would now cause
    every element to be copied. The <i>basic</i> guarantee is a
    ``natural'' level of safety for this operation, which it can
    provide without violating its performance guarantees. In fact all of the
    operations in the library appear to have such a ``natural'' level
    of safety.-->
    <p>ひとつの可能な選択肢は、新しい配列の内容を、毎回新しいメモリで構築して、
    成功したときのみ古い内容を破棄するように <code>insert</code> を再定義することである。
    残念ながら、このアプローチにはコストがかかる: vector の終端付近での挿入は、
    以前ではほとんどコピーを行う必要がなかったが、
    このアプローチでは全ての要素をコピーしなければいけない。
    <i>基本的</i>保証はこの操作に対する``自然な''水準の安全性である。
    パフォーマンスを脅かすことなく保証を与えているのである。
    実際ライブラリの全ての演算は、層のような``自然な''水準の安全性を提供している。

<!--    <p>Because performance requirements were already a well-established part of
    the draft standard and because performance is a primary goal of the STL,
    there was no attempt to specify more safety than could be provided within
    those requirements. Although not all of the library gives the <i>strong</i>
    guarantee, almost any operation on a standard container which gives the
    <i>basic</i> guarantee can be made <i>strong</i> using the ``make a
    new copy'' strategy described above:-->
    <p>パフォーマンスの要求は基準の草案の中では、確立した部分であり、
    パフォーマンスは STL の基本的な目的であるので、
    これらの要求の中で提供されうる、より強い安全性を明記する試みは為されなかった。
    全てのライブラリが <i>強い</i>保証を与えているわけではないが、
    <i>基本的</i>保証を提供する、標準コンテナほとんどの演算は、上に述べた、
    ``新たなコピーを作る''という戦略を使うことで、<i>強い</i>保証を持つことが出来る。
    
    <blockquote>
<pre>template &lt;class Container, class BasicOp&gt; 
void MakeOperationStrong( Container&amp; c, const BasicOp&amp; op ) 
{ 
    Container tmp(c); // Copy c 
    op(tmp); // Work on the copy 
    c.swap(tmp); // Cannot fail<a title=
"Associative containers whose Compare object might throw an exception when copied cannot use this technique, since the swap function might fail."
 href=
"#footnote7"><sup>7</sup></a>
}
</pre>
    </blockquote>

<!--    <p>This technique can be folded into a wrapper class to make a similar
    container which provides stronger guarantees (and different performance
    characteristics).<a title=
    "This suggests another potential use for the oft-wished-for but as yet unseen container traits&lt;&gt; template: automated container selection to meet exceptionsafety constraints."
     href=
    "#footnote8"><sup>8</sup></a>-->
    <p>この技は、より強い保証を提供する(そして異なるパフォーマンス特性を提供する)、
    似たようなコンテナを作るためのラッパクラスに導入することが出来る。
<a title=
    "This suggests another potential use for the oft-wished-for but as yet unseen container traits&lt;&gt; template: automated container selection to meet exceptionsafety constraints."
     href=
    "#footnote8"><sup>8</sup></a>

    <h2>6 Should we take everything we can get?</h2>

<!--    <p>By considering a particular implementation, we can hope to discern a
    natural level of safety. The danger in using this to establish requirements
    for a component is that the implementation might be restricted. If someone
    should come up with a more-efficient implementation which we'd like to use,
    we may find that it's incompatible with our exception-safety requirements.
    One might expect this to be of no concern in the well-explored domains of
    data structures and algorithms covered by the STL, but even there, advances
    are being made. A good example is the recent <i>introsort</i> algorithm <a
    title=
    "D. R. Musser, ``Introspective Sorting and Selection Algorithms'', Software-Practice and Experience 27(8):983-993, 1997."
     href=
    "#reference6"><sup>[6]</sup></a>,
    which represents a substantial improvement in worst-case complexity over
    the well-established <i>quicksort</i>.-->
    <p>特殊な実装を考えれば、安全性についての自然な水準を判断することを望めるだろう。
    コンポーネントに対する要求を確立するのにこれを使うことで、
    実装が制限されるという危険性が生じる。
    我々が使いたくなるような、より効率的な実装を誰かが作り上げても、
    それが我々の持つ例外安全性への要求を満たしていないことに気づくかもしれない。
    STL が扱っているデータ構造とアルゴリズムという、よく研究された領域では、
    このようなことに誰も期待を寄せないかもしれないが、
    それでも実際、より優れたものが作られている。最近の <i>introsort</i> アルゴリズムは、その良い例である
    <a
    title=
    "D. R. Musser, ``Introspective Sorting and Selection Algorithms'', Software-Practice and Experience 27(8):983-993, 1997."
     href=
    "#reference6"><sup>[6]</sup></a>。
    これは、既に確立した <i>quicksort</i> に対して、最悪の計算量を必要とするような場合での、
    大幅な改善を示している。

<!--    <p>To determine exactly how much to demand of the standard components, I
    looked at a typical real-world scenario. The chosen test case was a
    ``composite container.'' Such a container, built of two or more
    standard container components, is not only commonly needed, but serves as a
    simple representative case for maintaining invariants in larger systems:-->
    実際に標準コンポーネントの要求がどの程度のものなのかを決定するために、
    実世界の典型的な場合を考えた。
    選ばれたテストケースは ``合成コンテナ''である。
    2つ以上の標準コンテナの合成である、そのコンテナは広く必要とされているだけでなく、
    巨大なシステムで不変性を維持することについての単純で代表的な事例である。

    <blockquote>
<pre>// SearchableStack - A stack which can be efficiently searched 
// for any value. 
template &lt;class T&gt; 
class SearchableStack 
{ 
 public: 
    void push(const T&amp; t); // O(log n) 
    void pop(); // O(log n) 
    bool contains(const T&amp; t) const; // O(log n) 
    const T&amp; top() const; // O(1) 
 private: 
    std::set&lt;T&gt; set_impl; 
    std::list&lt;std::set&lt;T&gt;::iterator&gt; list_impl; 
}; 
</pre>
    </blockquote>

<!--    <p>The idea is that the list acts as a stack of set iterators: every
    element goes into the set first, and the resulting position is pushed onto
    the list. The invariant is straightforward: the set and the list should
    always have the same number of elements, and every element of the set
    should be referenced by an element of the list. The following
    implementation of the push function is designed to give the <i>strong</i>
    guarantee within the natural levels of safety provided by set and list:-->
    <p>ここでは、list は set のイテレータのスタックとして振る舞う:
    全ての要素は最初に set に入り、その結果その位置が list に入れられる。
    不変性というのは、簡単なことである: set と list は常に、
    同じ要素数を持ち、set 全ての要素は list の要素により参照されている、ということである。
    以下の push 関数のの実装は、 set と list によって提供される自然な水準の例外安全性で、
    <i>強い</i>保証を提供するために設計されたものである。

    <blockquote>
<pre>template &lt;class T&gt;                                // 1 
void SearchableStack&lt;T&gt;::push(const T&amp; t)         // 2 
{                                                       // 3 
    set&lt;T&gt;::iterator i = set_impl.insert(t);      // 4 
    try                                                 // 5 
    {                                                   // 6 
        list_impl.push_back(i);                         // 7 
    }                                                   // 8 
    catch(...)                                          // 9 
    {                                                   // 10 
        set_impl.erase(i);                              // 11 
        throw;                                          // 12 
    }                                                   // 13 
}                                                       // 14 
</pre>
    </blockquote>

<!--    <p>What does our code actually require of the library? We need to examine
    the lines where non-const operations occur:-->
    <p>このコードは実際に、ライブラリの何を要求するだろうか?
    非 const 演算が行われる行を調べてみる必要がある。

    <ul>
<!--      <li>Line 4: if the insertion fails but <code>set_impl</code> is modified
      in the process, our invariant is violated. We need to be able to rely on
      the <i>strong</i> guarantee from <code>set&lt;T&gt;::insert</code>.-->
      <li>4行目: 挿入が失敗したが、 <code>set_impl</code>がその過程で変更されている場合、
      不変性は保たれない。そこで、<code>set&lt;T&gt;::insert</code> からの
      <i>強い</i>保証に頼ることが出来なければならない。

<!--      <li>Line 7: likewise, if <code>push_back</code> fails, but
      <code>list_impl</code> is modified in the process, our invariant is
      violated, so we need to be able to rely on the <i>strong</i> guarantee
      from list&lt;T&gt;::insert.-->
      <li>7行目: 同様に <code>push_back</code> が失敗して <code>list_impl</code>
      がその過程で変更されているなら、不変性は保たれない。
      そこで、<code>list&lt;T&gt;::insert</code> からの
      <i>強い</i>保証に頼ることが出来なければならない。

<!--      <li>Line 11: here we are ``rolling back'' the insertion on line
      4. If this operation should fail, we will be unable to restore our
      invariant. We absolutely depend on the <i>no-throw</i> guarantee from
      <code>set&lt;T&gt;::erase</code>.<a title=
      "One might be tempted to surround the erase operation with a try/catch block to reduce the requirements on set&lt;T&gt; and the problems that arise in case of an exception, but in the end that just begs the question. First, erase just failed and in this case there are no viable alternative ways to produce the necessary result. Second and more generally, because of the variability of its type parameters a generic component can seldom be assured that any alternatives will succeed."
       href=
      "#footnote9"><sup>9</sup></a>-->
      <li>11行目: ここで4行目の挿入を``巻き戻し''ている。もしこの操作が失敗すれば、
      不変性を回復することは出来ないだろう。結局 <code>set&lt;T&gt;::erase</code>
      からの<i>例外不送出</i>保証に頼ることになる。
<a title=
      "One might be tempted to surround the erase operation with a try/catch block to reduce the requirements on set&lt;T&gt; and the problems that arise in case of an exception, but in the end that just begs the question. First, erase just failed and in this case there are no viable alternative ways to produce the necessary result. Second and more generally, because of the variability of its type parameters a generic component can seldom be assured that any alternatives will succeed."
       href=
      "#footnote9"><sup>9</sup></a>

<!--      <li>Line 11: for the same reasons, we also depend on being able to pass
      the <code>i</code> to the <code>erase</code> function: we need the
      <i>no-throw</i> guarantee from the copy constructor of
      <code>set&lt;T&gt;::iterator</code>.-->
      <li>11行目: 同じ理由で、 <i>i</i> を <code>erase</code> 関数に渡すことが出来るということにも、
      頼らなければならない: <code>set&lt;T&gt;::iterator</code> からの、
      <i>例外不送出</i>保証に頼る必要があるのである。

    </ul>

<!--    <p>I learned a great deal by approaching the question this way during
    standardization. First, the guarantee specified for the composite container
    actually depends on stronger guarantees from its components (the
    <i>no-throw</i> guarantees in line 11). Also, I took advantage of all of
    the natural level of safety to implement this simple example. Finally, the
    analysis revealed a requirement on iterators which I had previously
    overlooked when operations were considered on their own. The conclusion was
    that we should provide as much of the natural level of safety as possible.
    Faster but less-safe implementations could always be provided as extensions
    to the standard components. <sup><a title=
    "The prevalent philosophy in the design of STL was that functionality that wasn't essential to all uses should be left out in favor of efficiency, as long as that functionality could be obtained when needed by adapting the base components. This departs from that philosophy, but it would be difficult or impossible to obtain even the basic guarantee by adapting a base component that doesn't already have it."
     name="#footnote10">10</a></sup>-->
     <p>私は標準化の際にこの方法で問題を扱うことで、多くを学んだ。
     まず、合成コンテナに対して明示された保証は、実際はそのコンポーネントからのより強い保証
     (11行目の<i>例外不送出</i>保証)に依存するということである。
     また、この単純な例を実装するために、自然な水準の例外安全性を全ての面で利用した。
     そして、この分析は、以前私が、演算をそれぞれ独立したものと考えていたときには見逃していた、
     イテレータへの要求を明らかにした。
     結論は、可能な限り自然な水準の例外安全性を提供すべきだ、ということである。
     より速く、しかしより安全ではない実装は常に、標準コンポーネントの拡張として提供されるべきである。
     <sup><a title="The prevalent philosophy in the design of STL was that functionality that wasn't essential to all uses should be left out in favor of efficiency, as long as that functionality could be obtained when needed by adapting the base components. This departs from that philosophy, but it would be difficult or impossible to obtain even the basic guarantee by adapting a base component that doesn't already have it." href="#footnote10">10</a></sup>

    <h2>7 Automated testing for exception-safety</h2>

<!--    <p>As part of the standardization process, I produced an exception-safe
    reference implementation of the STL. Error-handling code is seldom
    rigorously tested in real life, in part because it is difficult to cause
    error conditions to occur. It is very common to see error-handling code
    which crashes the first time it is executed ...in a shipping product! To
    bolster confidence that the implementation actually worked as advertised, I
    designed an automated test suite, based on an exhaustive technique due to
    my colleague Matt Arnold.-->
    標準化の過程の一部として、私は STL での例外安全な参照の実装を作った。
    エラー捕捉コードは実際にかなり厳密にテストされたが、
    エラー状態を起こすことが難しいので、そのテストは部分的である。
    初めて実行されたときにクラッシュしたエラー捕捉コードを考えるというのは、
    とても一般的である-出荷される製品では。実装が実際に宣伝通りに動くという確信を強めるために、
    私は自動化されたテストスイートを設計した。これは同僚の Matt Arnold
    の精緻な技術に基づいている。

<!--    <p>The test program started with the basics: reinforcement and
    instrumentation, especially of the global operators <code>new</code> and
    <code>delete</code>.<sup><a title=
    "An excellent discussion on how to fortify memory subsystems can be found in: Steve Maguire, Writing Solid Code, Microsoft Press, Redmond, WA, 1993, ISBN 1-55615- 551-4."
     name="#footnote11">11</a></sup>Instances of the components (containers and
    algorithms) were created, with type parameters chosen to reveal as many
    potential problems as possible. For example, all type parameters were given
    a pointer to heap-allocated memory, so that leaking a contained object
    would be detected as a memory leak.-->
    <p>テストプログラムは基本的なところから始まった: 特にグローバル演算子 <code>new</code>
    と<code>delete</code>についての強化と計測である
    <sup><a title=
    "An excellent discussion on how to fortify memory subsystems can be found in: Steve Maguire, Writing Solid Code, Microsoft Press, Redmond, WA, 1993, ISBN 1-55615- 551-4."
     href="#footnote11">11</a></sup>。
     出来る限り多くの潜在的な問題を明らかにするために選ばれた型引数で、
     コンポーネント(コンテナとアルゴリズム)の実体が作られた。
     例えば、全ての型引数にはヒープ領域にメモリを割り当てられるポインタが与えられた。
     そのため、コンテナに格納されたオブジェクトをリークさせることは、
     メモリリークとして検出された。

<!--    <p>Finally, a scheme was designed that could cause an operation to throw an
    exception at each possible point of failure. At the beginning of every
    client-supplied operation which is allowed to throw an exception, a call to
    <code>ThisCanThrow</code> was added. A call to <code>ThisCanThrow</code>
    also had to be added everywhere that the generic operation being tested
    might throw an exception, for example in the global operator
    <code>new</code>, for which an instrumented replacement was supplied.-->
    <p>最後に、ポインタが間違って示す可能性のある場合に、その都度、
    演算に例外を投げさせることが出来るような仕組みを設計した。
    クライアントが提供し、例外を投げることが許されている全ての演算の最初に、
    <code>ThisCanThrow</code> の呼び出しが加えられた。
    <code>ThisCanThrow</code> の呼び出しはまた、
    テストされる汎用的演算が例外を投げるかもしれない全ての場所にも加えられた。
    例えば、より機能を強化したものに置き換えられた、グローバル演算子 <code>new</code> である。

    <blockquote>
<pre>// Use this as a type parameter, e.g. vector&lt;TestClass&gt; 
struct TestClass 
{ 
    TestClass( int v = 0 ) 
        : p( ThisCanThrow(), new int( v ) ) {} 
    TestClass( const TestClass&amp; rhs ) 
        : p( ThisCanThrow(), new int( *rhs.p ) ) {} 
    const TestClass&amp; operator=( const TestClass&amp; rhs ) 
        { ThisCanThrow(); *p = *rhs.p; } 
    bool operator==( const TestClass&amp; rhs ) 
        { ThisCanThrow(); return *p == *rhs.p; } 
    ...etc... 
    ~TestClass() { delete p; } 
};
</pre>
    </blockquote>

<!--    <p><code>ThisCanThrow</code> simply decrements a ``throw
    counter'' and, if it has reached zero, throws an exception. Each test
    takes a form which begins the counter at successively higher values in an
    outer loop and repeatedly attempts to complete the operation being tested.
    The result is that the operation throws an exception at each successive
    step along its execution path that can possibly fail. For example, here is
    a simplified version of the function used to test the <i>strong</i>
    guarantee: <a title=
    "Note that this technique requires that the operation being tested be exception-neutral. If the operation ever tries to recover from an exception and proceed, the throw counter will be negative, and subsequent operations that might fail will not be tested for exception-safety."
     href=
    "#footnote12"><sup>12</sup></a>-->
    <p><code>ThisCanThrow</code> は単に、``throw カウンタ''をデクリメントするだけであり、
    もしそれが 0 になったら、例外を投げる。
    テスト毎に、外側のループで、徐々に大きな値にカウンターを設定して開始し、
    演算のテストが完了するまで繰り返し試す、という形を取った。
    結果は、失敗する可能性がある実行パスに沿って、連続的なステップで、オペレーションが例外を投げた。
    例えば、<i>強い</i>保証をテストするのに使われた関数の単純なバージョンがある:
    <a title=
    "Note that this technique requires that the operation being tested be exception-neutral. If the operation ever tries to recover from an exception and proceed, the throw counter will be negative, and subsequent operations that might fail will not be tested for exception-safety."
     href=
    "#footnote12"><sup>12</sup></a>

    <blockquote>
<pre>extern int gThrowCounter; // The throw counter
void ThisCanThrow() 
{ 
    if (gThrowCounter-- == 0) 
        throw 0; 
} 
 
template &lt;class Value, class Operation&gt; 
void StrongCheck(const Value&amp; v, const Operation&amp; op) 
{ 
    bool succeeded = false; 
    for (long nextThrowCount = 0; !succeeded; ++nextThrowCount) 
    { 
        Value duplicate = v; 
        try 
        { 
            gThrowCounter = nextThrowCount; 
            op( duplicate ); // Try the operation 
            succeeded = true; 
        } 
        catch(...) // Catch all exceptions 
        { 
            bool unchanged = duplicate == v; // Test <i>strong</i> guarantee 
            assert( unchanged ); 
        } 
        // Specialize as desired for each container type, to check 
        // integrity. For example, size() == distance(begin(),end()) 
        CheckInvariant(v); // Check any invariant 
    } 
}
</pre>
    </blockquote>

<!--    <p>Notably, this kind of testing is much easier and less intrusive with a
    generic component than with non-generics, because testing-specific type
    parameters can be used without modifying the source code of the component
    being tested. Also, generic functions like <code>StrongCheck</code> above
    were instrumental in performing the tests on a wide range of values and
    operations.-->
    <p>注意すべきは、この種のテストは非汎用的なコンポーネントより、汎用的なものの方が
    遙かに簡単で、煩わしさのないものである、ということである。
    これは、テストに特化した型引数を、
    テストされるコンポーネントのソースコードを変更することなく使うことが出来るからである。
    また上の <code>StrongCheck</code> のような汎用関数が広範な値と演算のテストを行うのに役立つ。

    <h2>8 Further Reading</h2>
<!--    To my knowledge, there are currently only two descriptions of STL
    exception-safety available. The original specification <a title=
    "D. Abrahams, Exception Safety in STLport" href=
    "#reference2"><sup>[2]</sup></a>
    for the reference exception-safe implementation of the STL is an informal
    specification, simple and self-explanatory (also verbose), and uses the
    <i>basic-</i> and <i>strong-</i>guarantee distinctions outlined in this
    article. It explicitly forbids leaks, and differs substantively from the
    final C++ standard in the guarantees it makes, though they are largely
    identical. I hope to produce an updated version of this document soon. -->
    私が知る限り、現在 STL の利用可能な例外安全性には2種類の記述しかない。
    STL の例外安全の実装のリファレンスでの、オリジナルの仕様 <a title=
    "D. Abrahams, Exception Safety in STLport" href=
    "#reference2"><sup>[2]</sup></a>
    は、非公式な仕様であり、単純で自明(そして冗長)である。
    そこでは、この文書で概説してきた、<i>基本的</i>と<i>強い</i>保証の区別が使われている。
    それは明らかに、資源漏れを禁止していて、最終的な C++ 標準と比べ、多くの面で同じなのだが、
    保証という点では実質的に異なる。
    私はこの文書の改訂版が速やかに作られることを望んでいる。

<!--    <p>The description of exception-safety in the C++ Standard <a title=
    "International Standard ISO/IEC 14882, Information Technology-Programming Languages-C++, Document Number ISO/IEC 14882-1998"
     href=
    "#reference1"><sup>[1]</sup></a>
    is only slightly more formal, but relies on hard-to-read
    ``standardese'' and an occasionally subtle web of implication.<a
    title=
    "The changes to the draft standard which introduced exception-safety were made late in the process, when amendments were likely to be rejected solely on the basis of the number of altered words. Unfortunately, the result compromises clarity somewhat in favor of brevity. Greg Colvin was responsible for the clever language-lawyering needed to minimize the extent of these changes."
     href=
    "#footnote13"><sup>13</sup></a>
    In particular, leaks are not treated directly at all. It does have the
    advantage that it <i>is</i> the standard.-->
    C++ 標準での例外安全性の記述<a title=
    "International Standard ISO/IEC 14882, Information Technology-Programming Languages-C++, Document Number ISO/IEC 14882-1998"
     href=
    "#reference1"><sup>[1]</sup></a>
    はほんの少しだけ公式なものであるが、読みにくい``規格化''
    で構成されていて、ウェブ上ではほとんど見ることが出来ない。
<a
    title=
    "The changes to the draft standard which introduced exception-safety were made late in the process, when amendments were likely to be rejected solely on the basis of the number of altered words. Unfortunately, the result compromises clarity somewhat in favor of brevity. Greg Colvin was responsible for the clever language-lawyering needed to minimize the extent of these changes."
     href=
    "#footnote13"><sup>13</sup></a>
    とくに、資源漏れについては直接は全く扱われていない。
    それが規格<i>である</i>という利点を持っているに過ぎない。
    

<!--    <p>The original reference implementation <a title=
    "B. Fomitchev, Adapted SGI STL Version 1.0, with exception handling code by D. Abrahams"
     href=
    "#reference5"><sup>[5]</sup></a>
    of the exception-safe STL is an adaptation of an old version of the SGI
    STL, designed for C++ compilers with limited features. Although it is not a
    complete STL implementation, the code may be easier to read, and it
    illustrates a useful base-class technique for eliminating
    exception-handling code in constructors. The full test suite <a title=
    "D. Abrahams and B. Fomitchev, Exception Handling Test Suite" href=
    "#reference3"><sup>[3]</sup></a>
    used to validate the reference implementation has been used successfully to
    validate all recent versions of the SGI STL, and has been adapted to test
    one other vendor's implementation (which failed). As noted on the
    documentation page, it also seems to have the power to reveal hidden
    compiler bugs, particularly where optimizers interact with
    exception-handling code.-->
    <p>例外安全の実装<a title=
    "B. Fomitchev, Adapted SGI STL Version 1.0, with exception handling code by D. Abrahams"
     href=
    "#reference5"><sup>[5]</sup></a>
    に関するオリジナルのリファレンスは、SGI STL の古いバージョンである。
    これは限られた能力の C++ コンパイラのために設計された。
    これは完全な STL の実装ではないが、コードは読みやすいし、
    役立つ基底クラスのテクニックを、コンストラクタでの例外捕捉をなくすために説明している。
    参照の実装を検証するために使われた完全なテストスイート<a title=
    "D. Abrahams and B. Fomitchev, Exception Handling Test Suite" href=
    "#reference3"><sup>[3]</sup></a>
    は、引き続き SGI STL の最近のバージョン全てで使われている。
    そして他のベンダの実装をテスト(通らなかった)するのにも使われている。
    文書で注記されているように、それは隠れたコンパイラのバグを明らかにするのに、
    特に最適化と例外捕捉コードが相互作用するような場所では、
    強力であるだろう。
    

    <h2>References</h2>

    <ol>
      <li><a name="reference1">International</a> Standard ISO/IEC 14882,
      <i>Information Technology-Programming Languages-C++</i>, Document Number
      ISO/IEC 14882-1998, available from <a href=
      "http://webstore.ansi.org/ansidocstore/default.asp">http://webstore.ansi.org/ansidocstore/default.asp</a>.

      <li><a name="reference2">D.</a> Abrahams, <i>Exception Safety in
      STLport</i>, available at <a href=
      "http://www.stlport.org/doc/exception_safety.html">http://www.stlport.org/doc/exception_safety.html</a>.

      <li><a name="reference3">D.</a> Abrahams and B. Fomitchev, <i>Exception
      Handling Test Suite</i>, available at <a href=
      "http://www.stlport.org/doc/eh_testsuite.html">http://www.stlport.org/doc/eh_testsuite.html</a>.

      <li><a name="reference4">Tom</a> Cargill, ``Exception Handling: A
      False Sense of Security,'' C++ Report, Nov-Dec 1994, also available
      at <a href=
      "http://www.awl.com/cp/mec++-cargill.html">http://www.awl.com/cp/mec++-cargill.html</a>.

      <li><a name="reference5">B.</a> Fomitchev, <i>Adapted SGI STL Version
      1.0</i>, with exception handling code by D. Abrahams, available at <a
      href=
      "http://www.metabyte.com/~fbp/stl/old.html">http://www.metabyte.com/~fbp/stl/old.html</a>.

      <li><a name="reference6">D.</a> R. Musser, ``Introspective Sorting
      and Selection Algorithms,'' <i>Software-Practice and Experience</i>
      27(8):983-993, 1997.

      <li><a name="reference7">Bjarne</a> Stroustrup, <i>The Design And
      Evolution of C++</i>. Addison Wesley, Reading, MA, 1995, ISBN
      0-201-54330-3, Section 16.9.1.
    </ol>

    <h2>Footnotes</h2>

<!--    <p><a name="footnote1">1</a> Probably the greatest impediment to a solution
    in Cargill's case was an unfortunate combination of choices on his part:
    the interface he chose for his container was incompatible with his
    particular demands for safety. By changing either one he might have solved
    the problem.-->
    <p><a name="footnote1">1</a>おそらく Cargill の場合、解決に対する最も大きな障害は、
    彼が、不幸な組み合わせの選択をしてしまったということであった:
    彼がコンテナのために選んだインタフェースは、彼が要求する安全性の特徴と一致しないものだったのだ。
    どちらかを変更すれば、彼は問題を解決できただろう。
    

<!--    <p><a name="footnote2">2</a> It is usually inadvisable to throw an
    exception from a destructor in C++, since the destructor may itself be
    called during the stack-unwinding caused by another exception. If the
    second exception is allowed to propagate beyond the destructor, the program
    is immediately terminated.-->
    <p><a name="footnote2">2</a> C++ でデストラクタから例外が投げられることは通常進められない。
    デストラクタは、それ自身他の例外によって引き起こされるスタック巻き戻しの途中で呼び出されるかもしれないからである。
    2番目の例外がデストラクタを越えて伝えられることが可能なら、
    問題はすぐに解決する。

<!--    <p><a name="footnote3">3</a> In practice of course, this function would
    make an extremely poor random sequence generator!-->
    <p><a name="footnote3">3</a>実践としては、この関数はあまりにも貧弱なランダムシーケンス製作器である!

<!--    <p><a name="footnote4">4</a> It is worth noting that mutating algorithms
    usually cannot provide the <i>strong</i> guarantee: to roll back a modified
    element of a range, it must be set back to its previous value using
    <code>operator=</code>, which itself might throw. In the C++ standard
    library, there are a few exceptions to this rule, whose rollback behavior
    consists only of destruction: <code>uninitialized_copy</code>,
    <code>uninitialized_fill</code>, and <code>uninitialized_fill_n</code>.-->
    <p><a name="footnote4">4</a>変更操作を行うアルゴリズムが通常、<i>強い</i>保証を提供できないことは、
    注目に値する: ある範囲の変更された要素を巻き戻すために、
    例外を投げるかもしれない <code>operator=</code> を使って、以前の状態に戻さなければならないのである。
    C++ 標準ライブラリでは、この規則はほとんど守られていて、
    巻き戻しの振る舞いは破棄だけで成立している:
    例外は、<code>uninitialized_copy</code>,
    <code>uninitialized_fill</code>, <code>uninitialized_fill_n</code>

<!--    <p><a name="footnote5">5</a> All type parameters supplied by clients of the
    C++ standard library are required not to throw from their destructors. In
    return, all components of the C++ standard library provide at least the
    <i>basic</i> guarantee.-->
    <p><a name="footnote5">5</a>C++ 標準ライブラリのクライアントが提供する全ての型引数は、
    デストラクタが例外を投げないことを要求される。
    その代わりに、 C++ 標準ライブラリの全てのコンポーネントは少なくとも<i>基本的</i>保証を提供するのである。
    

<!--    <p><a name="footnote6">6</a> Similar arrangements might have been made in
    the C++ standard for many of the mutating algorithms, but were never
    considered due to time constraints on the standardization process.-->
    <p><a name="footnote6">6</a>変更操作を行う多くのアルゴリズムに対して C++ 規格では
    似たような整理が為されている。しかし規格化の過程で時間の制約は全く考えられていない。

<!--    <p><a name="footnote7">7</a> Associative containers whose
    <code>Compare</code> object might throw an exception when copied cannot use
    this technique, since the swap function might fail.-->
    <p><a name="footnote7">7</a>要素の <code>Compare</code> 
    がコピー時に例外を投げるかもしれないような連想コンテナは、この技を使っていない。
    スワップ関数が失敗するかもしれないからである。
    

<!--    <p><a name="footnote8">8</a> This suggests another potential use for the
    oft-wished-for but as yet unseen <code>container_traits&lt;&gt;</code>
    template: automated container selection to meet exception-safety
    constraints.-->
    <p><a name="footnote8">8</a>これは、たびたび望まれ、しかしまだ見知らぬ
    <code>container_traits&lt;&gt;</code> テンプレートのもう一つの潜在的な利用を示している。
    例外安全性の制約を満たす、コンテナの自動選択である。
    

<!--    <p><a name="footnote9">9</a> One might be tempted to surround the erase
    operation with a <code>try</code>/<code>catch</code> block to reduce the
    requirements on <code>set&lt;T&gt;</code> and the problems that arise in
    case of an exception, but in the end that just begs the question. First,
    erase just failed and in this case there are no viable alternative ways to
    produce the necessary result. Second and more generally, because of the
    variability of its type parameters a generic component can seldom be
    assured that any alternatives will succeed.-->
    <p><a name="footnote9">9</a><code>set&lt;T&gt;</code> に対する要求を減らし、
    例外時の問題を減らすために、
    erase を <code>try</code>/<code>cathc</code> ブロックに入れようとするかもしれない。
    しかし結局、問題なのである。
    まず、erase は失敗し、この場合必要な結果を産み出すための実行可能な代替案は存在しない。
    また、より一般には、型引数が多様なので、汎用コンポーネントにたいして、
    どんな選択肢も成功する保証はめったになされるものではない。

<!--    <p><a name="footnote10">10</a> The prevalent philosophy in the design of
    STL was that functionality that wasn't essential to all uses should be left
    out in favor of efficiency, as long as that functionality could be obtained
    when needed by adapting the base components. This departs from that
    philosophy, but it would be difficult or impossible to obtain even the
    <i>basic</i> guarantee by adapting a base component that doesn't already
    have it.-->
    <p><a name="footnote10">10</a>STL の設計の有力な哲学は、全ての利用にとって基本的でない機能は、
    その機能が必要なときに、基本のコンポーネントを適応することで得られる限り、
    効率を求めないでいく、ということである。
    これはそのような哲学に端を発しているが、<i>基本的</i>保証でさえ、
    既にその保証を持っていない基本のコンポーネントを適応して、そのような保証を得ることは難しいか、
    不可能である。

<!--    <p><a name="footnote11">11</a> An excellent discussion on how to fortify
    memory subsystems can be found in: Steve Maguire, Writing Solid Code,
    Microsoft Press, Redmond, WA, 1993, ISBN 1-55615- 551-4.-->
    <p><a name="footnote11">11</a>メモリシステムをどのようにして守るかについての素晴らしい議論が、
    次のものに書かれている: Steve Maguire, Writing Solid Code,
    Microsoft Press, Redmond, WA, 1993, ISBN 1-55615- 551-4.

<!--    <p><a name="footnote12">12</a> Note that this technique requires that the
    operation being tested be exception-neutral. If the operation ever tries to
    recover from an exception and proceed, the throw counter will be negative,
    and subsequent operations that might fail will not be tested for
    exception-safety.-->
    <p><a name="footnote12">12</a>この技は、テストされる操作が例外中立であることを必要とすることに注意すること。
    もし操作が例外から回復して、処理を続けようとするなら、throw カウンタは負の値になるだろう。
    そしてその後の失敗するかもしれない操作は、例外安全性に対してテストされない。

<!--    <p><a name="footnote13">13</a> The changes to the draft standard which
    introduced exception-safety were made late in the process, when amendments
    were likely to be rejected solely on the basis of the number of altered
    words. Unfortunately, the result compromises clarity somewhat in favor of
    brevity. Greg Colvin was responsible for the clever language-lawyering
    needed to minimize the extent of these changes.-->
    <p><a name="footnote13">13</a>例外安全性を導入した規格草案に対する変更は、
    変更される単語の数が多いという理由だけで修正が拒否されるような、
    草案作成の過程のかなり遅い時期に為された。
    不幸にも、この結果、簡潔さを求める余り、ある程度妥協したものとなった。
    Greg Colvin はこれらの変更の範囲を最小化するために必要な、
    賢い言語-法実務についての責任がある。

    
