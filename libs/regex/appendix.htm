<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=utf-8">
<meta name="Template"
content="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Regex++, Appendices</title>
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">

<p>&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top"><h3><img src="../../c++boost.gif"
        alt="C++ Boost" width="276" height="86"></h3>
        </td>
        <td valign="top"><h3 align="center">Regex++, Appendices.</h3>
        <p align="left"><i>Copyright (c) 1998-2001 </i></p>
        <p align="left"><i>Dr John Maddock</i></p>
        <p align="left"><i>Permission to use, copy, modify,
        distribute and sell this software and its documentation
        for any purpose is hereby granted without fee, provided
        that the above copyright notice appear in all copies and
        that both that copyright notice and this permission
        notice appear in supporting documentation. Dr John
        Maddock makes no representations about the suitability of
        this software for any purpose. It is provided &quot;as is&quot;
        without express or implied warranty.</i></p>
        </td>
    </tr>
</table>

<hr>
<h3><a name="implementation"></a>Appendix 1: Implementation notes</h3>

<!--<p>This is the first port of regex++ to the boost library, and is
based on regex++ 2.x, see changes.txt for a full list of changes
from the previous version. There are no known functionality bugs
except that POSIX style equivalence classes are only guaranteed
correct if the Win32 localization model is used (the default for
Win32 builds of the library). </p>-->
<p>これは boost ライブラリへ regex++ を導入した最初のものであり、
regex++ 2.x に基づいている。
以前のバージョンからの変更の完全なリストについては changes.txt を見よ。
Win32 地域化モデル (Win32 におけるデフォルトのライブラリ構築)
が使われているときのみ、POSIX スタイルの等価クラスが正しいことを保証される、
という点を除けば、機能的なバグは見つかっていない。</p>

<!--<p>There are some aspects of the code that C++ puritans will
consider to be poor style, in particular the use of goto in some
of the algorithms. The code could be cleaned up, by changing to a
recursive implementation, although it is likely to be slower in
that case. </p>-->
<p>C++ 信者はこのコードをいくつかの点で馬鹿げていると考えるであろう。
特にアルゴリズムのいくつかでは goto が使われている。
コードは、再帰的な実装に変更することで、よりきれいにすることができる。
その場合は、おそらくより遅くなるだろうが。</p>

<!--<p>The performance of the algorithms should be satisfactory in
most cases. For example the times taken to match the ftp response
expression &quot;^([0-9]+)(\-| |$)(.*)$&quot; against the string
&quot;100- this is a line of ftp response which contains a
message string&quot; are: BSD implementation 450 micro seconds,

<p>GNU implementation 271 micro seconds, regex++ 127 micro seconds (Pentium
P90, Win32 console app under MS Windows 95). </p>-->
<p>アルゴリズムのパフォーマンスは多くの場合、十分であるだろう。
例えば、 ftp レスポンスの表現 &quot;^([0-9]+)(\-| |$)(.*)$&quot;
が文字列 &quot;100- this is a line of ftp response which contains a
message string&quot; に一致するのにかかる時間は:
BSD の実装で 450 マイクロ秒, 
GNU の実装で 271 マイクロ秒,
regex++ では 127 マイクロ秒である (Pentium P90, Win32 コンソールアプリ、 MS Windows 95 環境)。</p>

<!--<p>However it should be noted that there are some &quot;pathological&quot;
expressions which may require exponential time for matching;
these all involve nested repetition operators, for example
attempting to match the expression &quot;(a*a)*b&quot; against <i>N</i>
letter a's requires time proportional to <i>2</i><sup><i>N</i></sup>.
These expressions can (almost) always be rewritten in such a way
as to avoid the problem, for example &quot;(a*a)*b&quot; could be
rewritten as &quot;a*b&quot; which requires only time linearly
proportional to <i>N</i> to solve. In the general case, non-nested
repeat expressions require time proportional to <i>N</i><sup><i>2</i></sup>,
however if the clauses are mutually exclusive then they can be
matched in linear time - this is the case with &quot;a*b&quot;,
for each character the matcher will either match an &quot;a&quot;
or a &quot;b&quot; or fail, where as with &quot;a*a&quot; the
matcher can't tell which branch to take (the first &quot;a&quot;
or the second) and so has to try both. <i>Be careful how you
write your regular expressions and avoid nested repeats if you
can! New to this version, some previously pathological cases have
been fixed - in particular searching for expressions which
contain leading repeats and/or leading literal strings should be
much faster than before. Literal strings are now searched for
using the Knuth/Morris/Pratt algorithm (this is used in
preference to the Boyer/More algorithm because it allows the
tracking of newline characters).</i> </p>-->
<p>しかし、一致判定に指数オーダを必要とする、 &quot;病的な&quot; 
正規表現があることも述べておかなければならないだろう。
これらは全て、ネストされた繰り返し演算子にまつわるものである。
例えば、正規表現 &quot;(a*a)*b&quot; を <i>N</i> 文字の a に一致させるには、
<i>2</i><sup><i>N</i></sup> に比例した時間を必要とする。
これらの表現は 問題を避けるために、(ほとんど) いつも、別の方法で書き直すことが出来る。
例えば、 &quot;(a*a)*b&quot; は &quot;a*b&quot; として書き直すことが出来る。
これは、一致を解決するのに <i>N</i> に線形的に比例した時間しかかからない。
一般的に、ネストされていない繰り返し表現は <i>N</i><sup><i>2</i></sup>
に比例する時間を必要とする。
しかし、もし句が相互排他的なら線形オーダの時間で一致させることが可能である。
これは、&quot;a*b&quot; の場合である。それぞれの文字に対して、
一致判定は &quot;a&quot; か &quot;b&quot; か失敗のいずれかである。
一方、&quot;a*a&quot; では取るべき枝を一致判定者は伝えることが出来ないので
( 最初の &quot;a&quot; か2番目のものか解らない)、両方を試さなければならない。
<i>正規表現をどう書くかに十分注意した方がよい。
そして、もし可能ならネストした繰り返しを避けるべきである。
このバージョンでの新しい点として、以前でのいくつかの病的なケースは直っている。
特に、先行する繰り返しや先行するリテラル文字列を含む正規表現の検索は、
以前に比べかなり速くなったと思う。
リテラル文字列に対しては今は Knuth/Morris/Pratt アルゴリズムを使って検索されている
(これは BM 法より好んで使われる。なぜなら、改行文字の追跡が可能だからである)。</i> </p>

<!--<p><i>Some aspects of the POSIX regular expression syntax are
implementation defined:</i> </p>-->
<p><i>POSIX 正規表現構文のいくつかの点は、より明確に実装された:</i> </p>

<ul>
<!--    <li>The &quot;leftmost-longest&quot; rule for determining
        what matches is ambiguous, this library takes the &quot;obvious&quot;
        interpretation: find the leftmost match, then maximize
        the length of each sub-expression in turn with lower
        indexed sub-expressions taking priority over higher
        indexed sub-expression. </li>-->
    <li>一致するものを決定するための &quot;最左最長&quot; 規則は曖昧である。
    このライブラリは &quot;明確な&quot; 解釈を持っている: 
    最左一致を発見し、それからそれぞれの子表現の長さを最長にし、
    そしてより前の順番の子表現をより後の順番の子表現より優先する。</li>
<!--    <li>The behavior of multi-character collating elements is
        ambiguous in the standard, in particular expressions such
        as [a[.ae.]] may have subtle inconsistencies lurking in
        them. This implementation matches bracket expressions as
        follows: all bracket expressions match a single character
        only, unless the expression contains a multi-character
        collating element, either on its own, or as the endpoint
        to a range, in which case the expression may match more
        than one character. </li>-->
    <li>マルチ文字照合要素の振る舞いは標準では曖昧である。
    特に [a[.ae.]] のような表現は、それ自身に潜在したわずかな不調和を持っている。
    この実装は次のような括弧表現に一致する: 
    表現がそれ自身に、或いは範囲の終端としてマルチ文字照合要素を持たない限り、
    全ての括弧表現が単一文字のみに一致する。
    もしそうでなければ、表現は一文字以上に一致するかもしれない。</li>
<!--    <li>Repeated null expressions are repeated only once, they
        are treated &quot;as if&quot; they were matched the
        maximum number of times allowed by the expression. </li>-->
    <li>繰り返しの null 表現は一度だけ繰り返される。
    それらは表現により認められる最大数の繰り返しと一致した &quot;かのように&quot; 扱われる。</li>
<!--    <li>The behavior of back references is ambiguous in the
        standard, in particular it is unclear whether expressions
        of the form &quot;((ab*)\2)+&quot; should be allowed.
        This implementation allows such expressions and the back
        reference matches whatever the last sub-expression match
        was. This means that at the end of the match, the back
        references may have matched strings different from the
        final value of the sub-expression to which they refer. </li>-->
    <li>後方参照の振る舞いは標準では曖昧である。
    特に &quot;((ab*)\2)+&quot; という形の表現が許されるかどうかは不明瞭である。
    この実装はそのような表現を認め、後方参照は最後の子表現の一致が何であれ、一致する。
    これは一致の終端では、後方参照はそれが参照する子表現の最終的な値とは異なる一致文字列を
    持っているかもしれない、ということを意味する。</li>
</ul>

<hr>

<!--<h3><a name="threads"></a>Appendix 2: Thread safety</h3>-->
<h3><a name="threads"></a>Appendix 2: スレッド安全性</h3>

<!--<p>Class reg_expression&lt;&gt; and its typedefs regex and wregex
are thread safe, in that compiled regular expressions can safely
be shared between threads. The matching algorithms regex_match,
regex_search, regex_grep, regex_format and regex_merge are all re-entrant
and thread safe. Class match_results is now thread safe, in that
the results of a match can be safely copied from one thread to
another (for example one thread may find matches and push
match_results instances onto a queue, while another thread pops
them off the other end), otherwise use a separate instance of
match_results per thread. </p>-->
<p>クラス reg_expression&lt;&gt; とその typedef である regex と wregex
はスレッド安全性を実現している。
コンパイルされた正規表現はスレッド間で安全に共有できる。
一致判定アルゴリズム regex_match,
regex_search, regex_grep, regex_format, regex_merge 
は全て、再入可能でスレッドセーフである。
クラス match_results も今はスレッドセーフである。
一致の結果はあるスレッドから別のスレッドに安全にコピーできる
(例えばあるスレッドが一致を発見し、 match_results のインスタンスをキューに挿入しながら、
別のスレッドがキューの逆端からそれを取り出すというようなことである)。
そうでなければ、スレッドごとに match_results の実体を分けて使えばよい。</p>

<!--<p>The POSIX API functions are all re-entrant and thread safe,
regular expressions compiled with <i>regcomp</i> can also be
shared between threads. </p>-->
<p>POSIX API 関数は全て再入可能でスレッドセーフである。
<i>regcomp</i> を伴ってコンパイルされた正規表現も異なるスレッド間で共有可能である。</p>

<!--<p>The class RegEx is only thread safe if each thread gets its
own RegEx instance (apartment threading) - this is a consequence
of RegEx handling both compiling and matching regular expressions.
</p>-->
<p>クラス RegEx はそれぞれのスレッドが自分の RegEx のインスタンスを
持っているときのみスレッドセーフである(分割スレッド)。
これは、RegEx が正規表現のコンパイルと一致判定の両方を扱っているからである。</p>

<!--<p>Finally note that changing the global locale invalidates all
compiled regular expressions, therefore calling <i>set_locale</i>
from one thread while another uses regular expressions <i>will</i>
produce unpredictable results. </p>-->
<p>最後に、グローバルロケールを変更すると、コンパイルされた全ての正規表現が無効になるので、
あるスレッドが正規表現を扱っている間に 別のスレッドが <i>set_locale</i> を呼び出すと、
予期できない結果を生む <i>だろう</i> ということに注意せよ。</p>

<!--<p>There is also a requirement that there is only one thread
executing prior to the start of main(). </p>-->
<p>また、 main() の開始より前にはただひとつのスレッドだけが存在する、
ということが要求されている。</p>

<hr>

<!--<h3><a name="localisation"></a>Appendix 3: Localization</h3>-->
<h3><a name="localisation"></a>Appendix 3: Localization</h3>

<!--<p>&nbsp;Regex++ provides extensive support for run-time
localization, the localization model used can be split into two
parts: front-end and back-end. </p>-->
<p>&nbsp;Regex++ は実行時地域化に対して拡張されたサポートを提供している。
地域化モデルは2つの部分に分かれる: フロントエンドとバックエンドだ。</p>

<!--<p>Front-end localization deals with everything which the user
sees - error messages, and the regular expression syntax itself.
For example a French application could change [[:word:]] to [[:mot:]]
and \w to \m. Modifying the front end locale requires active
support from the developer, by providing the library with a
message catalogue to load, containing the localized strings.
Front-end locale is affected by the LC_MESSAGES category only. </p>-->
<p>フロントエンドの地域化はユーザが見るものすべてを扱う。
つまり、エラーメッセージや、正規表現構文そのものである。
例えば、フランス語のアプリケーションは [[:word:]] を [[:mot:]] に、
そして \w を \m に変更することが出来るだろう。
フロントエンドのロケールを変更することは、
開発者による積極的なサポートを要求する。
これは、地域化された文字列を含む、読み込むべきメッセージカタログと共に
ライブラリが提供されるということである。
フロントエンドのロケールは LC_MESSAGES カテゴリのみに影響される。</p>

<!--<p>Back-end localization deals with everything that occurs after
the expression has been parsed - in other words everything that
the user does not see or interact with directly. It deals with
case conversion, collation, and character class membership. The
back-end locale does not require any intervention from the
developer - the library will acquire all the information it
requires for the current locale from the underlying operating
system / run time library. This means that if the program user
does not interact with regular expressions directly - for example
if the expressions are embedded in your C++ code - then no
explicit localization is required, as the library will take care
of everything for you. For example embedding the expression [[:word:]]+
in your code will always match a whole word, if the program is
run on a machine with, for example, a Greek locale, then it will
still match a whole word, but in Greek characters rather than
Latin ones. The back-end locale is affected by the LC_TYPE and
LC_COLLATE categories. </p>-->
<p>バックエンドの地域化は正規表現が解析された後に起こる全てのことを扱う。
つまり、ユーザが見ない、或いは直接関わらないこと全てである。
これは、大文字小文字の変換や、照合順序、文字クラスの要素などをあつかう。
バックエンドのロケールは開発者のいかなる介入も要求しない。
つまり、ライブラリは、ライブラリが現在のロケールに対して要求する全ての情報を
、オペレーティングシステムやランタイムライブラリから得られるということである。
これは、もしプログラムのユーザが正規表現を直接扱えない、
例えば正規表現があなたの C++ コードに埋め込まれているような場合に、
明示的な地域化が必要でないということを意味する。
なぜならライブラリが、あなたのために全てをやってくれるからである。
例えば、正規表現 [[:word:]]+ をあなたのコードに埋め込むと、常に全ての単語に一致する。
もしプログラムが、仮にギリシャ語のロケール環境で走っていたとしても、
全ての単語に一致するのである。
しかし、その一致はラテン文字での一致ではなく、ギリシャ文字での一致である。
バックエンドのロケールは LC_TYPE と LC_COLLATE のカテゴリに影響を受ける。</p>

<!--<p>There are three separate localization mechanisms supported by
regex++: </p>-->
<p>regex++ がサポートする3つの異なる地域化機構がある: </p>

<!--<p><i>Win32 localization model.</i> </p>-->
<p><i>Win32 localization model.</i> </p>

<!--<p>This is the default model when the library is compiled under
Win32, and is encapsulated by the traits class <a
href="template_class_ref.htm#regex_char_traits">w32_regex_traits</a>.
When this model is in effect there is a single global locale as
defined by the user's control panel settings, and returned by
GetUserDefaultLCID. All the settings used by regex++ are acquired
directly from the operating system bypassing the C run time
library. Front-end localization requires a resource dll,
containing a string table with the user-defined strings. The
traits class exports the function: </p>-->
<p>これはライブラリが Win32 環境でコンパイルされたときのデフォルトのモデルである。
そして、<a href="template_class_ref.htm#regex_char_traits">w32_regex_traits</a> 
によってカプセル化されている。
このモデルが適用されているときは、ユーザのコントロールパネルに従った唯一の
グローバルロケールがあり、それは GetUserDefaultLCID で返される。
regex++ で使われる全ての設定は C ランタイムライブラリを通さず、
オペレーティングシステムから直接得られる。
フロントエンドの地域化は、ユーザ定義の文字列をもった文字列テーブルを含むリソースである dll
を要求する。
特性クラスは次の関数を export する：</p>

<p>static std::string set_message_catalogue(const std::string&amp;
s); </p>

<!--<p>which needs to be called with a string identifying the name of
the resource dll, <i>before</i> your code compiles any regular
expressions (but not necessarily before you construct any <i>reg_expression</i>
instances): </p>-->
<p>これは、コードが何らかの正規表現をコンパイルする <i>前に</i> 
(しかし、必ずしも <i>reg_expression</i> のインスタンスを構築する前にではない)、
リソースの dll の名前を識別する文字列を伴って呼び出される必要がある:</p>

<p>boost::w32_regex_traits&lt;char&gt;::set_message_catalogue(&quot;mydll.dll&quot;);
</p>

<!--<p>Note that this API sets the dll name for <i>both</i> the
narrow and wide character specializations of w32_regex_traits. </p>-->
<p>この API が w32_regex_traits のナロウ文字とワイド文字 <i>両方</i> 
の特殊化のために dll の名前を設定することに注意すること。</p>

<!--<p>This model does not currently support thread specific locales
(via SetThreadLocale under Windows NT), the library provides full
Unicode support under NT, under Windows 9x the library degrades
gracefully - characters 0 to 255 are supported, the remainder are
treated as &quot;unknown&quot; graphic characters. </p>-->
<p>このモデルは現在は、(Windows NT での SetThreadLocale による)
スレッドに特化したロケールをサポートしていない。
ライブラリは NT での完全なユニコードのサポートを提供する。
Windows 9x ではこの能力は多少落ちる 
- 0 から 255 の文字はサポートされているが、それ以外は &quot;未知の&quot; グラフ文字として扱われる。</p>

<!--<p><i>C localization model.</i> </p>-->
<p><i>C 地域化モデル</i> </p>

<!--<p>This is the default model when the library is compiled under
an operating system other than Win32, and is encapsulated by the
traits class <a href="template_class_ref.htm#regex_char_traits"><i>c_regex_traits</i></a>,
Win32 users can force this model to take effect by defining the
pre-processor symbol BOOST_REGEX_USE_C_LOCALE. When this model is
in effect there is a single global locale, as set by <i>setlocale</i>.
All settings are acquired from your run time library,
consequently Unicode support is dependent upon your run time
library implementation. Front end localization requires a POSIX
message catalogue. The traits class exports the function: </p>-->
<p>ライブラリが Win32 以外のオペレーティングシステムでコンパイルされたとき、
これがデフォルトのモデルとなる。これは特性クラス
<a href="template_class_ref.htm#regex_char_traits"><i>c_regex_traits</i></a>
によってカプセル化されている。
Win32 のユーザはプリプロセッサで BOOST_REGEX_USE_C_LOCALE を定義することで、
このモデルを有効にすることが出来る。
このモデルが有効なとき、<i>setlocale</i> により設定された唯一のグローバルロケールが存在する。
全ての設定はランタイムライブラリから得ることが出来るので、
結果的にユニコードのサポートはランタイムライブラリの実装に依存する。
フロントエンドの地域化は POSIX メッセージカタログを必要とする。
特性クラスは以下の関数を export する:</p>

<p>static std::string set_message_catalogue(const std::string&amp;
s); </p>

<!--<p>which needs to be called with a string identifying the name of
the message catalogue, <i>before</i> your code compiles any
regular expressions (but not necessarily before you construct any
<i>reg_expression</i> instances): </p>-->
<p>これは、コードが何らかの正規表現をコンパイルする <i>前に</i> 
(しかし、必ずしも <i>reg_expression</i> のインスタンスを構築する前にではない)、
リソースの dll の名前を識別する文字列を伴って呼び出される必要がある:</p>

<p>boost::c_regex_traits&lt;char&gt;::set_message_catalogue(&quot;mycatalogue&quot;);
</p>

<!--<p>Note that this API sets the dll name for <i>both</i> the
narrow and wide character specializations of c_regex_traits. If
your run time library does not support POSIX message catalogues,
then you can either provide your own implementation of
&lt;nl_types.h&gt; or define BOOST_RE_NO_CAT to disable front-end
localization via message catalogues. </p>-->
<p>この API が w32_regex_traits のナロウ文字とワイド文字 <i>両方</i> 
の特殊化のために dll の名前を設定することに注意すること。
もしランタイムライブラリが POSIX メッセージカタログをサポートしていなければ、
&lt;nl_types.h&gt; の独自の実装を提供するか、
メッセージカタログによるフロントエンドの地域化を無効にするために
BOOST_RE_NO_CAT を定義することが出来る。</p>

<!--<p>Note that calling <i>setlocale</i> invalidates all compiled
regular expressions, calling <tt>setlocale(LC_ALL, &quot;C&quot;)</tt>
will make this library behave equivalent to most traditional
regular expression libraries including version 1 of this library.
</p>-->
<p><i>setlocale</i> を呼び出すと、コンパイルされた全ての正規表現が無効になることに注意すること。
<tt>setlocale(LC_ALL, &quot;C&quot;)</tt> を呼び出すと、
ライブラリは、このライブラリのバージョン 1 を含む多くの伝統的な正規表現ライブラリと
同じ振る舞いをする。
</p>

<p><i><tt>C++ </tt></i><i>localization</i><i><tt> </tt></i><i>model</i><i><tt>.</tt></i>
</p>
<p><i><tt>C++ </tt></i><i>地域化</i><i><tt> </tt></i><i>モデル</i><i><tt>.</tt></i>
</p>

<!--<p>This model is only in effect if the library is built with the
pre-processor symbol BOOST_REGEX_USE_CPP_LOCALE defined. When
this model is in effect each instance of reg_expression&lt;&gt;
has its own instance of std::locale, class reg_expression&lt;&gt;
also has a member function <i>imbue</i> which allows the locale
for the expression to be set on a per-instance basis. Front end
localization requires a POSIX message catalogue, which will be
loaded via the std::messages facet of the expression's locale,
the traits class exports the symbol: </p>-->
<p>このモデルは、プリプロセッサシンボル BOOST_REGEX_USE_CPP_LOCALE
を定義してライブラリをビルドした時のみ有効である。
このモデルが有効なとき、 reg_expression&lt;&gt; のそれぞれのインスタンスは、
自分自身の std::locale のインスタンスを持つ。
クラス reg_expression&lt;&gt; はメンバ関数 <i>imbue</i> も持つ。
これは、正規表現のロケールをインスタンスごとに設定することを可能にする。
フロントエンドの地域化は POSIX メッセージカタログを必要とする。
これは正規表現のロケールの std::message ファセットによって読み込まれる。
特性クラスは以下のシンボルを export する:</p>

<p>static std::string set_message_catalogue(const std::string&amp;
s); </p>

<!--<p>which needs to be called with a string identifying the name of
the message catalogue, <i>before</i> your code compiles any
regular expressions (but not necessarily before you construct any
<i>reg_expression</i> instances): </p>-->
<p>これは、コードが何らかの正規表現をコンパイルする <i>前に</i> 
(しかし、必ずしも <i>reg_expression</i> のインスタンスを構築する前にではない)、
メッセージカタログの名前を識別する文字列を伴って呼び出される必要がある:</p>

<p>boost::cpp_regex_traits&lt;char&gt;::set_message_catalogue(&quot;mycatalogue&quot;);
</p>

<!--<p>Note that calling reg_expression&lt;&gt;::imbue will
invalidate any expression currently compiled in that instance of
reg_expression&lt;&gt;. This model is the one which closest fits
the ethos of the C++ standard library, however it is the model
which will produce the slowest code, and which is the least well
supported by current standard library implementations, for
example I have yet to find an implementation of std::locale which
supports either message catalogues, or locales other than &quot;C&quot;
or &quot;POSIX&quot;. </p>-->
<p>reg_expression&lt;&gt;::imbue の呼び出しは、その reg_expression&lt;&gt;
のインスタンスの現在コンパイルされた正規表現を無効にすることに注意すること。
このモデルは C++ 標準ライブラリの思想にもっとも近いものである。
しかし、最も遅いコードを生成するモデルでもある。
そして現在の標準ライブラリの実装によって最もサポートされていないものである。
例えば私は、メッセージカタログか、或いは &quot;C&quot; や &quot;POSIX&quot;
以外のロケールの、どちらかをサポートした std::locale の実装を見たことはない。</p>

<!--<p>Finally note that if you build the library with a non-default
localization model, then the appropriate pre-processor symbol (BOOST_REGEX_USE_C_LOCALE
or BOOST_REGEX_USE_CPP_LOCALE) must be defined both when you
build the support library, and when you include &lt;boost/regex.hpp&gt;
or &lt;boost/cregex.hpp&gt; in your code. The best way to ensure
this is to add the #define to &lt;boost/regex/detail/regex_options.hpp&gt;.
</p>-->
<p>最後に、もしライブラリをデフォルト以外の地域化モデルでビルドするなら、
サポートライブラリをビルドするときにも、コードに &lt;boost/regex.hpp&gt; や 
&lt;boost/cregex.hpp&gt; をインクルードするときにも、
適切なプリプロセッサシンボル (BOOST_REGEX_USE_C_LOCALE や
BOOST_REGEX_USE_CPP_LOCALE) を定義しなければならないことに注意すること。
これを確実にする最良の方法は、 &lt;boost/regex/detail/regex_options.hpp&gt; に
#define を追加することである。
</p>

<!--<p><i>Providing a message catalogue:</i> </p>-->
<p><i>メッセージカタログの提供:</i> </p>

<!--<p>In order to localize the front end of the library, you need to
provide the library with the appropriate message strings
contained either in a resource dll's string table (Win32 model),
or a POSIX message catalogue (C or C++ models). In the latter
case the messages must appear in message set zero of the
catalogue. The messages and their id's are as follows: <br>
&nbsp; </p>-->
<p>ライブラリのフロントエンドを地域化するためには、
リソース dll の文字列テーブル (Win32 モデル) か、
POSIX メッセージカタログ (C または C++ モデル) を含んだ、
ふさわしいメッセージ文字列をもったライブラリを提供する必要がある。
後者の場合、<font color="red">メッセージはカタログのメッセージ集合ゼロに現れなければならない。</font>
メッセージとその ID は以下の通り:<br>
&nbsp; </p>

<table border="0" cellpadding="6" cellspacing="0" width="624">
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
<!--        <td valign="top" width="21%">Message id </td>
        <td valign="top" width="32%">Meaning </td>
        <td valign="top" width="29%">Default value </td>-->
        <td valign="top" width="21%">メッセージ ID </td>
        <td valign="top" width="32%">意味 </td>
        <td valign="top" width="29%">既定値 </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">101 </td>
<!--        <td valign="top" width="32%">The character used to start
        a sub-expression. </td>-->
        <td valign="top" width="32%">子表現の開始に使われる文字</td>
        <td valign="top" width="29%">&quot;(&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">102 </td>
<!--        <td valign="top" width="32%">The character used to end a
        sub-expression declaration. </td>-->
        <td valign="top" width="32%">子表現の終了に使われる文字</td>
        <td valign="top" width="29%">&quot;)&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">103 </td>
<!--        <td valign="top" width="32%">The character used to denote
        an end of line assertion. </td>-->
        <td valign="top" width="32%">行末の明示を表す文字</td>
        <td valign="top" width="29%">&quot;$&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">104 </td>
<!--        <td valign="top" width="32%">The character used to denote
        the start of line assertion. </td>-->
        <td valign="top" width="32%">行頭の明示を表す文字</td>
        <td valign="top" width="29%">&quot;^&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">105 </td>
<!--        <td valign="top" width="32%">The character used to denote
        the &quot;match any character expression&quot;. </td>-->
        <td valign="top" width="32%">&quot;あらゆる文字に一致する表現&quot; を表す文字</td>
        <td valign="top" width="29%">&quot;.&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">106 </td>
<!--        <td valign="top" width="32%">The match zero or more times
        repetition operator. </td>-->
        <td valign="top" width="32%">0回以上の一致繰り返し演算子</td>
        <td valign="top" width="29%">&quot;*&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">107 </td>
<!--        <td valign="top" width="32%">The match one or more
        repetition operator. </td>-->
        <td valign="top" width="32%">1回以上の一致繰り返し演算子</td>
        <td valign="top" width="29%">&quot;+&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">108 </td>
<!--        <td valign="top" width="32%">The match zero or one
        repetition operator. </td>-->
        <td valign="top" width="32%">0または1回の一致繰り返し演算子</td>
        <td valign="top" width="29%">&quot;?&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">109 </td>
<!--        <td valign="top" width="32%">The character set opening
        character. </td>-->
        <td valign="top" width="32%">文字集合の開始</td>
        <td valign="top" width="29%">&quot;[&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">110 </td>
<!--        <td valign="top" width="32%">The character set closing
        character. </td>-->
        <td valign="top" width="32%">文字集合の終了</td>
        <td valign="top" width="29%">&quot;]&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">111 </td>
<!--        <td valign="top" width="32%">The alternation operator. </td>-->
        <td valign="top" width="32%">排他演算子 </td>
        <td valign="top" width="29%">&quot;|&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">112 </td>
<!--        <td valign="top" width="32%">The escape character. </td>-->
        <td valign="top" width="32%">エスケープ文字</td>
        <td valign="top" width="29%">&quot;\\&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">113 </td>
<!--        <td valign="top" width="32%">The hash character (not
        currently used). </td>-->
        <td valign="top" width="32%">ハッシュ文字 (今は使われていない)</td>
        <td valign="top" width="29%">&quot;#&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">114 </td>
<!--        <td valign="top" width="32%">The range operator. </td>-->
        <td valign="top" width="32%">文字範囲演算子 </td>
        <td valign="top" width="29%">&quot;-&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">115 </td>
<!--        <td valign="top" width="32%">The repetition operator
        opening character. </td>-->
        <td valign="top" width="32%">繰り返し演算子の開始</td>
        <td valign="top" width="29%">&quot;{&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">116 </td>
<!--        <td valign="top" width="32%">The repetition operator
        closing character. </td>-->
        <td valign="top" width="32%">繰り返し演算子の終了</td>
        <td valign="top" width="29%">&quot;}&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">117 </td>
<!--        <td valign="top" width="32%">The digit characters. </td>-->
        <td valign="top" width="32%">数字</td>
        <td valign="top" width="29%">&quot;0123456789&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">118 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the word
        boundary assertion. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたとき、単語の境界の明示を表す文字</td>
        <td valign="top" width="29%">&quot;b&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">119 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the non-word
        boundary assertion. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたとき、非単語の境界の明示を表す文字</td>
        <td valign="top" width="29%">&quot;B&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">120 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the word-start
        boundary assertion. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに単語の開始を表す文字</td>
        <td valign="top" width="29%">&quot;&lt;&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">121 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the word-end
        boundary assertion. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに単語の終了を表す文字</td>
        <td valign="top" width="29%">&quot;&gt;&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">122 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents any word
        character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、あらゆる単語構成文字を表す文字</td>
        <td valign="top" width="29%">&quot;w&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">123 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents a non-word
        character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、あらゆる非-単語構成文字を表す文字</td>
        <td valign="top" width="29%">&quot;W&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">124 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents a start of
        buffer assertion. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、バッファの先頭の明示を表す文字</td>
        <td valign="top" width="29%">&quot;`A&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">125 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents an end of
        buffer assertion. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、バッファの終端の明示を表す文字</td>
        <td valign="top" width="29%">&quot;'z&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">126 </td>
<!--        <td valign="top" width="32%">The newline character. </td>-->
        <td valign="top" width="32%">改行文字</td>
        <td valign="top" width="29%">&quot;\n&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">127 </td>
<!--        <td valign="top" width="32%">The comma separator. </td>-->
        <td valign="top" width="32%">コンマセパレータ </td>
        <td valign="top" width="29%">&quot;,&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">128 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the bell
        character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、ベル文字を表す文字</td>
        <td valign="top" width="29%">&quot;a&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">129 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the form feed
        character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、フォームフィード文字(FF)を表す文字</td>
        <td valign="top" width="29%">&quot;f&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">130 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the newline
        character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、改行文字を表す文字</td>
        <td valign="top" width="29%">&quot;n&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">131 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the carriage
        return character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、復帰改行 (CR) 文字を表す文字</td>
        <td valign="top" width="29%">&quot;r&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">132 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the tab
        character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときにタブ文字を表す文字</td>
        <td valign="top" width="29%">&quot;t&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">133 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the vertical
        tab character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、垂直タブ文字を表す文字</td>
        <td valign="top" width="29%">&quot;v&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">134 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the start of a
        hexadecimal character constant. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、16進定数の開始を表す文字</td>
        <td valign="top" width="29%">&quot;x&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">135 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the start of
        an ASCII escape character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、 ASCII エスケープ文字の開始を表す文字</td>
        <td valign="top" width="29%">&quot;c&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">136 </td>
<!--        <td valign="top" width="32%">The colon character. </td>-->
        <td valign="top" width="32%">コロン</td>
        <td valign="top" width="29%">&quot;:&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">137 </td>
<!--        <td valign="top" width="32%">The equals character. </td>-->
        <td valign="top" width="32%">イコール</td>
        <td valign="top" width="29%">&quot;=&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">138 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the ASCII
        escape character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、
	ASCII エスケープ文字を表す文字</td>
        <td valign="top" width="29%">&quot;e&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">139 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents any lower case
        character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、あらゆる小文字を表す文字</td>
        <td valign="top" width="29%">&quot;l&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">140 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents any non-lower
        case character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、
	あらゆる非-小文字を表す文字</td>
        <td valign="top" width="29%">&quot;L&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">141 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents any upper case
        character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、
	あらゆる大文字を表す文字</td>
        <td valign="top" width="29%">&quot;u&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">142 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents any non-upper
        case character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、
	あらゆる非-大文字を表す文字</td>
        <td valign="top" width="29%">&quot;U&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">143 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents any space
        character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、
	あらゆる空白文字を表す文字</td>
        <td valign="top" width="29%">&quot;s&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">144 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents any non-space
        character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、
	あらゆる非-空白文字を表す文字</td>
        <td valign="top" width="29%">&quot;S&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">145 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents any digit
        character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、
	あらゆる数字を表す文字。</td>
        <td valign="top" width="29%">&quot;d&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">146 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents any non-digit
        character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、
	あらゆる非-数字を表す文字</td>
        <td valign="top" width="29%">&quot;D&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">147 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the end quote
        operator. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、
	終了引用符を表す文字</td>
        <td valign="top" width="29%">&quot;E&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">148 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the start
        quote operator. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、
	開始引用符を表す文字</td>
        <td valign="top" width="29%">&quot;Q&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">149 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents a Unicode
        combining character sequence. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、
	ユニコード複合文字シーケンスを表す文字</td>
        <td valign="top" width="29%">&quot;X&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">150 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents any single
        character. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、
	あらゆる単一文字を表す文字</td>
        <td valign="top" width="29%">&quot;C&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">151 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents end of buffer
        operator. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、
	バッファ終了演算子を表す文字</td>
        <td valign="top" width="29%">&quot;Z&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="21%">152 </td>
<!--        <td valign="top" width="32%">The character which when
        preceded by an escape character represents the
        continuation assertion. </td>-->
        <td valign="top" width="32%">エスケープ文字に続いたときに、
	連続の明示を表す文字</td>
        <td valign="top" width="29%">&quot;G&quot; </td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>153</td>
<!--        <td>The character which when preceeded by (? indicates a
        zero width negated forward lookahead assert.</td>-->
        <td> (? に続いたときにゼロ幅の否定前方一致の明示を表す文字</td>
        <td>!</td>
        <td>&nbsp;</td>
    </tr>
</table>

<p><br>
&nbsp; </p>

<!--<p>Custom error messages are loaded as follows: <br>-->
<p>カスタムのエラーメッセージは以下のように読み込まれる:<br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="624">
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
<!--        <td valign="top" width="22%">Message ID </td>
        <td valign="top" width="32%">Error message ID </td>
        <td valign="top" width="31%">Default string </td>-->
        <td valign="top" width="22%">メッセージ ID </td>
        <td valign="top" width="32%">エラーメッセージ ID </td>
        <td valign="top" width="31%">既定文字列 </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">201 </td>
        <td valign="top" width="32%">REG_NOMATCH </td>
        <td valign="top" width="31%">&quot;No match&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">202 </td>
        <td valign="top" width="32%">REG_BADPAT </td>
        <td valign="top" width="31%">&quot;Invalid regular
        expression&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">203 </td>
        <td valign="top" width="32%">REG_ECOLLATE </td>
        <td valign="top" width="31%">&quot;Invalid collation
        character&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">204 </td>
        <td valign="top" width="32%">REG_ECTYPE </td>
        <td valign="top" width="31%">&quot;Invalid character
        class name&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">205 </td>
        <td valign="top" width="32%">REG_EESCAPE </td>
        <td valign="top" width="31%">&quot;Trailing backslash&quot;
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">206 </td>
        <td valign="top" width="32%">REG_ESUBREG </td>
        <td valign="top" width="31%">&quot;Invalid back reference&quot;
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">207 </td>
        <td valign="top" width="32%">REG_EBRACK </td>
        <td valign="top" width="31%">&quot;Unmatched [ or [^&quot;
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">208 </td>
        <td valign="top" width="32%">REG_EPAREN </td>
        <td valign="top" width="31%">&quot;Unmatched ( or \\(&quot;
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">209 </td>
        <td valign="top" width="32%">REG_EBRACE </td>
        <td valign="top" width="31%">&quot;Unmatched \\{&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">210 </td>
        <td valign="top" width="32%">REG_BADBR </td>
        <td valign="top" width="31%">&quot;Invalid content of
        \\{\\}&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">211 </td>
        <td valign="top" width="32%">REG_ERANGE </td>
        <td valign="top" width="31%">&quot;Invalid range end&quot;
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">212 </td>
        <td valign="top" width="32%">REG_ESPACE </td>
        <td valign="top" width="31%">&quot;Memory exhausted&quot;
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">213 </td>
        <td valign="top" width="32%">REG_BADRPT </td>
        <td valign="top" width="31%">&quot;Invalid preceding
        regular expression&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">214 </td>
        <td valign="top" width="32%">REG_EEND </td>
        <td valign="top" width="31%">&quot;Premature end of
        regular expression&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">215 </td>
        <td valign="top" width="32%">REG_ESIZE </td>
        <td valign="top" width="31%">&quot;Regular expression too
        big&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">216 </td>
        <td valign="top" width="32%">REG_ERPAREN </td>
        <td valign="top" width="31%">&quot;Unmatched ) or \\)&quot;
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">217 </td>
        <td valign="top" width="32%">REG_EMPTY </td>
        <td valign="top" width="31%">&quot;Empty expression&quot;
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">218 </td>
        <td valign="top" width="32%">REG_E_UNKNOWN </td>
        <td valign="top" width="31%">&quot;Unknown error&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
</table>

<p><br>
&nbsp; </p>

<!--<p>Custom character class names are loaded as followed: <br>-->
<p>カスタムの文字クラス名は次のように読み込まれる:</br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="624">
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
<!--        <td valign="top" width="22%">Message ID </td>
        <td valign="top" width="32%">Description </td>
        <td valign="top" width="31%">Equivalent default class
        name </td>-->
        <td valign="top" width="22%">メッセージ ID </td>
        <td valign="top" width="32%">解説 </td>
        <td valign="top" width="31%">等価な既定のクラス名</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">300 </td>
<!--        <td valign="top" width="32%">The character class name for
        alphanumeric characters. </td>-->
        <td valign="top" width="32%">英数字の文字クラス名</td>
        <td valign="top" width="31%">&quot;alnum&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">301 </td>
<!--        <td valign="top" width="32%">The character class name for
        alphabetic characters. </td>-->
        <td valign="top" width="32%">アルファベット文字の文字クラス名</td>
        <td valign="top" width="31%">&quot;alpha&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">302 </td>
<!--        <td valign="top" width="32%">The character class name for
        control characters. </td>-->
        <td valign="top" width="32%">コントロール文字の文字クラス名</td>
        <td valign="top" width="31%">&quot;cntrl&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">303 </td>
<!--        <td valign="top" width="32%">The character class name for
        digit characters. </td>-->
        <td valign="top" width="32%">数字の文字クラス名</td>
        <td valign="top" width="31%">&quot;digit&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">304 </td>
<!--        <td valign="top" width="32%">The character class name for
        graphics characters. </td>-->
        <td valign="top" width="32%">空白以外の印字可能文字の文字クラス名</td>
        <td valign="top" width="31%">&quot;graph&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">305 </td>
<!--        <td valign="top" width="32%">The character class name for
        lower case characters. </td>-->
        <td valign="top" width="32%">小文字の文字クラス名</td>
        <td valign="top" width="31%">&quot;lower&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">306 </td>
<!--        <td valign="top" width="32%">The character class name for
        printable characters. </td>-->
        <td valign="top" width="32%">印字可能文字の文字クラス名</td>
        <td valign="top" width="31%">&quot;print&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">307 </td>
<!--        <td valign="top" width="32%">The character class name for
        punctuation characters. </td>-->
        <td valign="top" width="32%">句読点の文字クラス名</td>
        <td valign="top" width="31%">&quot;punct&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">308 </td>
<!--        <td valign="top" width="32%">The character class name for
        space characters. </td>-->
        <td valign="top" width="32%">空白文字の文字クラス名</td>
        <td valign="top" width="31%">&quot;space&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">309 </td>
<!--        <td valign="top" width="32%">The character class name for
        upper case characters. </td>-->
        <td valign="top" width="32%">大文字の文字クラス名</td>
        <td valign="top" width="31%">&quot;upper&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">310 </td>
<!--        <td valign="top" width="32%">The character class name for
        hexadecimal characters. </td>-->
        <td valign="top" width="32%">16進文字の文字クラス名</td>
        <td valign="top" width="31%">&quot;xdigit&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">311 </td>
<!--        <td valign="top" width="32%">The character class name for
        blank characters. </td>-->
        <td valign="top" width="32%">ブランク文字の文字クラス名</td>
        <td valign="top" width="31%">&quot;blank&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">312 </td>
<!--        <td valign="top" width="32%">The character class name for
        word characters. </td>-->
        <td valign="top" width="32%">単語構成文字の文字クラス名</td>
        <td valign="top" width="31%">&quot;word&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="8%">&nbsp;</td>
        <td valign="top" width="22%">313 </td>
<!--        <td valign="top" width="32%">The character class name for
        Unicode characters. </td>-->
        <td valign="top" width="32%">ユニコード文字の文字クラス名</td>
        <td valign="top" width="31%">&quot;unicode&quot; </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
</table>

<p><br>
&nbsp; </p>

<!--<p>Finally, custom collating element names are loaded starting
from message id 400, and terminating when the first load
thereafter fails. Each message looks something like: &quot;tagname
string&quot; where <i>tagname</i> is the name used inside [[.tagname.]]
and <i>string</i> is the actual text of the collating element.
Note that the value of collating element [[.zero.]] is used for
the conversion of strings to numbers - if you replace this with
another value then that will be used for string parsing - for
example use the Unicode character 0x0660 for [[.zero.]] if you
want to use Unicode Arabic-Indic digits in your regular
expressions in place of Latin digits. </p>-->
<p>最後に、カスタムの照合要素名がメッセージ ID 400 から始まって読み込まれ、
最初の読み込みがその後失敗したときに終了する。
それぞれのメッセージは次のようだろう:
&quot;tagname string&quot;
<i>tagname</i> は [[.tagname.]] の内側で使われる名前であり、
<i>string</i> は照合要素の実際のテキストである。
照合要素の値 [[.zero.]] は文字列から数字への変換のために使われていることに注意せよ。
もしこれを他の値で書き換えたら、それが文字列解析に使われることになる。
例えば、ラテン数字の代わりに、ユニコードのアラビア-インド数字を正規表現の中で使いたければ、
 [[.zero.]] にユニコード文字 0x0660 を使えばよい。</p>

<!--<p>Note that the POSIX defined names for character classes and
collating elements are always available - even if custom names
are defined, in contrast, custom error messages, and custom
syntax messages replace the default ones. </p>-->
<p>POSIX が定義した文字クラス名と照合要素は常に利用可能であることに注意せよ。
たとえカスタムの名前が定義されても、逆にカスタムのエラーメッセージと
カスタムの構文メッセージはデフォルトのもので置き換えられる。</p>

<hr>

<!--<h3><a name="demos"></a>Appendix 4: Example Applications</h3>-->
<h3><a name="demos"></a>Appendix 4: 応用例 </h3>

<!--<p>There are three demo applications that ship with this library,
they all come with makefiles for Borland, Microsoft and gcc
compilers, otherwise you will have to create your own makefiles. </p>-->
<p>このライブラリに関する3つのデモアプリケーションがある。
Borland, Microsoft, gcc コンパイラのメイクファイルは付属しているが、
それ以外は自分でメイクファイルを作成しなければならない</p>

<h5>regress.exe: </h5>

<!--<p>A regression test application that gives the matching/searching
algorithms a full workout. The presence of this program is your
guarantee that the library will behave as claimed - at least as
far as those items tested are concerned - if anyone spots
anything that isn't being tested I'd be glad to hear about it. </p>-->
<p>一致判定、検索アルゴリズムを完全に試すための、退行テストアプリケーションである。
このプログラムが動けば、少なくともこれらの試されたものが関わる限りは、
ライブラリが要求通りに動くであろうことを保証する。
もし誰かが、何か試されていないものを見つけたら、それについて聞けると私はうれしい。</p>

<p>Files: <a href="test/regress/parse.cpp">parse.cpp</a>, <a
href="test/regress/regress.cpp">regress.cpp</a>, <a
href="test/regress/tests.cpp">tests.cpp</a>. </p>

<h5>jgrep.exe </h5>

<!--<p>A simple grep implementation, run with no command line options
to find out its usage. Look at <a href="src/fileiter.cpp">fileiter.cpp</a>/fileiter.hpp
and the mapfile class to see an example of a &quot;smart&quot;
bidirectional iterator that can be used with regex++ or any other
STL algorithm. </p>-->
<p>単純な grep の実装。利用法を調べるためには、コマンドラインオプションをつけずに走らせてみること。
regex++ や他の STL アルゴリズムで使うことが出来る
&quot;賢い&quot; 双方向イテレータの例を見るには、
<a href="src/fileiter.cpp">fileiter.cpp</a>/fileiter.hpp 
およびそのマップファイルクラスを参考にせよ。</p>

<p>Files: <a href="example/jgrep/jgrep.cpp">jgrep.cpp</a>, <a
href="example/jgrep/main.cpp">main.cpp</a>. </p>

<h5>timer.exe </h5>

<!--<p>A simple interactive expression matching application, the
results of all matches are timed, allowing the programmer to
optimize their regular expressions where performance is critical.
</p>-->
<p>単純な対話式一致判定アプリケーション。
全ての一致の結果が時間測定されるので、
プログラマはパフォーマンスが重要なときに、
正規表現を最適化することが出来る。
</p>

<p>Files: <a href="example/timer/regex_timer.cpp">regex_timer.cpp</a>.
</p>

<!--<p>The snippets examples contain the code examples used in the
documentation:</p>-->
<p>断片的な例はこのドキュメントで使われたコードの例を含んでいる。</p>

<p><a href="example/snippets/regex_match_example.cpp">regex_match_example.cpp</a>:
<!--ftp based regex_match example.</p>-->
ftp に基づく regex_match の例</p>

<p><a href="example/snippets/regex_search_example.cpp">regex_search_example.cpp</a>:
<!--regex_search example: searches a cpp file for class definitions.</p>-->
regex_search の例: cpp ファイルのクラス定義を検索する。</p>

<p><a href="example/snippets/regex_grep_example_1.cpp">regex_grep_example_1.cpp</a>:
<!--regex_grep example 1: searches a cpp file for class definitions.</p>-->
regex_grep の例: cpp ファイルのクラス定義を検索する。</p>

<p><a href="example/snippets/regex_merge_example.cpp">regex_merge_example.cpp</a>:
<!--regex_merge example: converts a C++ file to syntax highlighted
HTML.</p>-->
regex_merge の例: C++ ファイルを、構文がハイライトされた HTML に変換する。</p>

<p><a href="example/snippets/regex_grep_example_2.cpp">regex_grep_example_2.cpp</a>:
<!--regex_grep example 2: searches a cpp file for class definitions,
using a global callback function. </p>-->
regex_grep の例 2: グローバルコールバック関数を使って、cpp ファイルのクラス定義を検索する。</p>

<p><a href="example/snippets/regex_grep_example_3.cpp">regex_grep_example_3.cpp</a>:
<!--regex_grep example 2: searches a cpp file for class definitions,
using a bound member function callback.</p>-->
regex_grep の例 3: 束縛されたメンバ関数コールバックを使って、cpp ファイルのクラス定義を検索する。</p>

<p><a href="example/snippets/regex_grep_example_4.cpp">regex_grep_example_4.cpp</a>:
<!--regex_grep example 2: searches a cpp file for class definitions,
using a C++ Builder closure as a callback.</p>-->
regex_grep の例 4: C++ Builder のクロージャをコールバックとして使って、cpp ファイルのクラス定義を検索する。</p>

<p><a href="example/snippets/regex_split_example_1.cpp">regex_split_example_1.cpp</a>:
<!--regex_split example: split a string into tokens.</p>-->
regex_split の例: 文字列をトークンに分割する。</p>

<p><a href="example/snippets/regex_split_example_2.cpp">regex_split_example_2.cpp</a>:
<!--regex_split example: spit out linked URL's.</p>-->
regex_split の例: リンクされた URL を吐き出す。</p>

<hr>

<!--<h3><a name="headers"></a>Appendix 5: Header Files</h3>-->
<h3><a name="headers"></a>Appendix 5: ヘッダファイル</h3>

<!--<p>There are two main headers used by this library: &lt;boost/regex.hpp&gt;
provides full access to the entire library, while &lt;boost/cregex.hpp&gt;
provides access to just the high level class RegEx, and the POSIX
API functions. </p>-->
<p>このライブラリが使う2つの主要なヘッダファイルがある:
&lt;boost/regex.hpp&gt; は完全なライブラリへの完全なアクセスを提供する。
&lt;boost/cregex.hpp&gt; は高水準クラス RegEx と POSIX API 関数へのアクセスのみを提供する。</p>

<hr>

<!--<h3><a name="redist"></a>Appendix 6: Redistributables</h3>-->
<h3><a name="redist"></a>Appendix 6: 再配布</h3>

<!--<p>&nbsp;If you are using Microsoft or Borland C++ and link to a
dll version of the run time library, then you will also link to
one of the dll versions of regex++. While these dll's are
redistributable, there are no &quot;standard&quot; versions, so
when installing on the users PC, you should place these in a
directory private to your application, and not in the PC's
directory path. Note that if you link to a static version of your
run time library, then you will also link to a static version of
regex++ and no dll's will need to be distributed. The possible
regex++ dll and library names are computed according to the
following formula:<br>-->
<p>&nbsp;もし Microsoft か Borland C++ を使っていて、
dll 版のランタイムライブラリにリンクしているなら、
regex++ の dll のひとつのバージョンにもリンクしているだろう。
これらの dll は再配布可能だが、 &quot;標準の&quot; バージョンというものが存在しないので、
ユーザの PC にインストールするとき、これらを、PC のディレクトリパスにではなく、
アプリケーションのプライベートディレクトリに置くべきである。
もしスタティックバージョンのランタイムライブラリとリンクしているなら、
regex++ ともリンクしていて、 dll が配布される必要はないだろう。
可能な regex++ dll とライブラリの名前は次の公式に従って導き出される:<br>
</p>

<p>&quot;boost_regex_&quot;<br>
+ BOOST_LIB_TOOLSET<br>
+ &quot;_&quot;<br>
+ BOOST_LIB_THREAD_OPT<br>
+ BOOST_LIB_RT_OPT<br>
+ BOOST_LIB_LINK_OPT<br>
+ BOOST_LIB_DEBUG_OPT<br>
<br>
<!--These are defined as:<br>-->
これらは次のように定義されている:<br>
<br>
<!--BOOST_LIB_TOOLSET: The compiler toolset name (vc6, vc7, bcb5 etc).<br>-->
BOOST_LIB_TOOLSET: コンパイラのツールセットの名前 (vc6, vc7, bcb5 など)<br>
<br>
<!--BOOST_LIB_THREAD_OPT: &quot;s&quot; for single thread builds,<br>
&quot;m&quot; for multithread builds.<br>-->
BOOST_LIB_THREAD_OPT: &quot;s&quot; はシングルスレッドビルドを表す。<br>
&quot;m&quot; はマルチスレッドビルドを表す。<br>
<br>
<!--BOOST_LIB_RT_OPT: &quot;s&quot; for static runtime,<br>
&quot;d&quot; for dynamic runtime.<br>-->
BOOST_LIB_RT_OPT: &quot;s&quot; はスタティックランタイムをあらわす。<br>
&quot;d&quot; はダイナミックランタイムを表す。
<br>
<!--BOOST_LIB_LINK_OPT: &quot;s&quot; for static link,<br>
&quot;i&quot; for dynamic link.<br>-->
BOOST_LIB_LINK_OPT: &quot;s&quot; はスタティックリンクを表す。<br>
&quot;i&quot; はダイナミックリンクを表す。</br>
<br>
<!--BOOST_LIB_DEBUG_OPT: nothing for release builds,<br>
&quot;d&quot; for debug builds,<br>
&quot;dd&quot; for debug-diagnostic builds (_STLP_DEBUG).</p>-->
BOOST_LIB_DEBUG_OPT: 未定義ならリリースビルドを表す。<br>
&quot;d&quot; はデバッグビルドを表す。<br>
&quot;dd&quot; は診断デバッグビルドを表す。(_STLP_DEBUG)</p>

<!--<p>Note: you can disable automatic library selection by defining
the symbol BOOST_REGEX_NO_LIB when compiling, this is useful if
you want to statically link even though you're using the dll
version of your run time library, or if you need to debug regex++.
</p>-->
<p>注意: シンボル BOOST_REGEX_NO_LIB をコンパイル時に定義することで、
ライブラリの自動選択を不可能にすることが出来る。
これは、ランタイムライブラリの dll バージョンを使っていても、
スタティックリンクをしたいようなときや、
regex++ をデバッグする必要があるときに役に立つ。
</p>

<hr>

<!--<h3><a name="upgrade"></a>Notes for upgraders</h3>-->
<h3><a name="upgrade"></a>アップグレードに関する注記</h3>

<!--<p>This version of regex++ is the first to be ported to the <a
href="http://www.boost.org/">boost</a> project, and as a result
has a number of changes to comply with the boost coding
guidelines. </p>-->
<p>このバージョンの regex++ は
<a href="http://www.boost.org/">boost</a> プロジェクトに移植された最初のものであり、
結果的に、boost コーディングガイドラインに従うために、
多くの変更が為された。</p>

<!--<p>Headers have been changed from &lt;header&gt; or &lt;header.h&gt;
to &lt;boost/header.hpp&gt; </p>-->
<p>ヘッダファイルは &lt;header&gt; や &lt;header.h&gt; から
&lt;boost/header.hpp&gt; に変更された。</p>

<!--<p>The library namespace has changed from &quot;jm&quot;, to
&quot;boost&quot;. </p>

<p>The reg_xxx algorithms have been renamed regex_xxx (to improve
naming consistency). </p>-->
<p>ライブラリの名前空間は &quot;jm&quot; から
&quot;boost&quot; に変更された。</p>

<p>reg_xxx アルゴリズムは (名前付けの一貫性を改善するために) regex_xxx に改名された。</p>

<!--<p>Algorithm query_match has been renamed regex_match, and only
returns true if the expression matches the whole of the input
string (think input data validation). </p>-->
<p>アルゴリズム query_match は regex_match に改名された。
また、正規表現が入力文字列の全体に一致するときのみ true を返すようになった
(入力データの検証を考えている)。</p>

<!--<p><i>Compiling existing code:</i> </p>-->
<p><i>既存のコードのコンパイル:</i> </p>

<!--<p>The directory, libs/regex/old_include contains a set of
headers that make this version of regex++ compatible with
previous ones, either add this directory to your include path, or
copy these headers to the root directory of your boost
installation. The contents of these headers are deprecated and
undocumented - really these are just here for existing code - for
new projects use the new header forms. </p>-->
<p>ディレクトリ libs/regex/old_include には、このバージョンの regex++ が
以前のライブラリとの互換性を持つためのヘッダファイル群が含まれている。
このディレクトリをインクルードパスに追加するか、これらのヘッダファイルを
boost をインストールしたルートディレクトリにコピーすればよい。
これらのヘッダファイルの内容は推奨されていないし、
ドキュメントも提供されていない。
これらは本当に、ただ既存のコードのためだけに存在している。
新しいプロジェクトには、新しいヘッダ形式を使うこと。</p>

<hr>

<!--<h3><a name="furtherInfo"></a>Further Information (Contacts and
Acknowledgements)</h3>-->
<h3><a name="furtherInfo"></a>より多くの情報 (連絡と謝辞)</h3>

<!--<p>The author can be contacted at <a
href="mailto:John_Maddock@compuserve.com">John_Maddock@compuserve.com</a>,
the home page for this library is at <a
href="http://ourworld.compuserve.com/homepages/John_Maddock/regexpp.htm">http://ourworld.compuserve.com/homepages/John_Maddock/regexpp.htm</a>,
and the official boost version can be obtained from <a
href="../libraries.htm">www.boost.org/libraries.htm</a>. </p>-->
<p>作者への連絡は
<a href="mailto:John_Maddock@compuserve.com">John_Maddock@compuserve.com</a>
で可能である。
このライブラリのためのホームページは
<a href="http://ourworld.compuserve.com/homepages/John_Maddock/regexpp.htm">
http://ourworld.compuserve.com/homepages/John_Maddock/regexpp.htm</a>
にある。
公式の boost のバージョンは
<a href="../libraries.htm">www.boost.org/libraries.htm</a>から入手できる。 </p>

<!--<p>I am indebted to Robert Sedgewick's &quot;Algorithms in C++&quot;
for forcing me to think about algorithms and their performance,
and to the folks at boost for forcing me to <i>think</i>, period.
The following people have all contributed useful comments or
fixes: Dave Abrahams, Mike Allison, Edan Ayal, Jayashree
Balasubramanian, Jan B.BANBvlsche, Beman Dawes, Paul Baxter, David
Bergman, David Dennerline, Edward Diener, Peter Dimov, Robert
Dunn, Fabio Forno, Tobias Gabrielsson, Rob Gillen, Marc Gregoire,
Chris Hecker, Nick Hodapp, Jesse Jones, Martin Jost, Boris
Krasnovskiy, Jan Hermelink, Max Leung, Wei-hao Lin, Jens Maurer,
Richard Peters, Heiko Schmidt, Jason Shirk, Gerald Slacik, Scobie
Smith, Mike Smyth, Alexander Sokolovsky, HervNBi Poirier, Michael
Raykh, Marc Recht, Scott VanCamp, Bruno Voigt, Alexey Voinov,
Jerry Waldorf, Rob Ward, Lealon Watts, Thomas Witt and Yuval
Yosef. I am also grateful to the manuals supplied with the Henry
Spencer, Perl and GNU regular expression libraries - wherever
possible I have tried to maintain compatibility with these
libraries and with the POSIX standard - the code however is
entirely my own, including any bugs! I can absolutely guarantee
that I will not fix any bugs I don't know about, so if you have
any comments or spot any bugs, please get in touch. </p>-->
<p>私は Robert Sedgewick 著 &quot;Algorithms in C++&quot;
に大変感謝している。
これは私にアルゴリズムとパフォーマンスについて考えさせてくれた。
また boost の人々は私に <i>考え</i>させてくれた、以上。
以下の人々は皆、有益なコメントや修正をしてくれた:
Dave Abrahams, Mike Allison, Edan Ayal, Jayashree
Balasubramanian, Jan BNBvlsche, Beman Dawes, Paul Baxter, David
Bergman, David Dennerline, Edward Diener, Peter Dimov, Robert
Dunn, Fabio Forno, Tobias Gabrielsson, Rob Gillen, Marc Gregoire,
Chris Hecker, Nick Hodapp, Jesse Jones, Martin Jost, Boris
Krasnovskiy, Jan Hermelink, Max Leung, Wei-hao Lin, Jens Maurer,
Richard Peters, Heiko Schmidt, Jason Shirk, Gerald Slacik, Scobie
Smith, Mike Smyth, Alexander Sokolovsky, HervNBi Poirier, Michael
Raykh, Marc Recht, Scott VanCamp, Bruno Voigt, Alexey Voinov,
Jerry Waldorf, Rob Ward, Lealon Watts, Thomas Witt and Yuval
Yosef. 
私はまた、Henry Spencer の Perl and GNU regular expression libraries
に関するマニュアルにも感謝している。
可能であれば常に、これらのライブラリ、そして POSIX 標準との互換性を保とうとした。
しかしコードは完全に私自身のものであり、バグを含んでいる!
私は、私が知らないどんなバグも直すことが出来ないだろうと、自信を持って保証できる。
だからもし、あなたが何かコメントをもっていたり、
バグを発見したりしたら、ぜひ教えて欲しい。</p>

<!--<p>Useful further information can be found at: </p>-->
<p>役立つ情報は更に、次の場所で得ることが出来る:</p>

<!--<p>A short tutorial on regular expressions <a
href="http://www.devshed.com/Server_Side/Administration/RegExp/">can
be found here</a>.</p>-->
<p>正規表現に関する簡単なチュートリアルは
<a href="http://www.devshed.com/Server_Side/Administration/RegExp/">
ここで見ることが出来る。</a></p>

<!--<p>The <a
href="http://www.opengroup.org/onlinepubs/7908799/toc.htm">Open
Unix Specification</a> contains a wealth of useful material,
including the regular expression syntax, and specifications for <a
href="http://www.opengroup.org/onlinepubs/7908799/xsh/regex.h.html">&lt;regex.h&gt;</a>
and <a
href="http://www.opengroup.org/onlinepubs/7908799/xsh/nl_types.h.html">&lt;nl_types.h&gt;</a>.
</p>-->
<p><a href="http://www.opengroup.org/onlinepubs/7908799/toc.htm">Open
Unix Specification</a> は、正規表現構文やその仕様
<a href="http://www.opengroup.org/onlinepubs/7908799/xsh/regex.h.html">&lt;regex.h&gt;</a>、
<a href="http://www.opengroup.org/onlinepubs/7908799/xsh/nl_types.h.html">&lt;nl_types.h&gt;</a>
などを含む、役立つ資料を多く含んでいる。
</p>

<!--<p>The <a href="http://www.cs.ucr.edu/~stelo/pattern.html">Pattern
Matching Pointers</a> site is a &quot;must visit&quot; resource
for anyone interested in pattern matching. </p>-->
<p><a href="http://www.cs.ucr.edu/~stelo/pattern.html">Pattern Matching Pointers</a>
サイトは &quot;must visit&quot; パターンマッチに興味を持つものなら誰もが訪ねなければならない情報資源である。</p>

<!--<p><a href="http://glimpse.cs.arizona.edu/">Glimpse and Agrep</a>,
use a simplified regular expression syntax to achieve faster
search times. </p>-->
<p><a href="http://glimpse.cs.arizona.edu/">Glimpse and Agrep</a>,
はより高速な探索時間を実現するために、単純化された正規表現構文を使っている</p>

<!--<p><a href="http://glimpse.cs.arizona.edu/udi.html">Udi Manber</a>
and <a href="http://www.dcc.uchile.cl/~rbaeza/">Ricardo Baeza-Yates</a>
both have a selection of useful pattern matching papers available
from their respective web sites. </p>-->
<p><a href="http://glimpse.cs.arizona.edu/udi.html">Udi Manber</a> と 
<a href="http://www.dcc.uchile.cl/~rbaeza/">Ricardo Baeza-Yates</a>
は両方とも、関連するウェブサイトから利用可能な、
役立つパターンマッチの文書を集めたものである。</p>

<hr>

<p><i>Copyright </i><a href="mailto:John_Maddock@compuserve.com"><i>Dr
John Maddock</i></a><i> 1998-2000 all rights reserved.</i> </p>
<hr align="left">
<p>
<p><i>Japanese Translation Copyright (C) 2003 <a href="mailto:k_takahashi@cppll.jp">Kohske Takahashi</a></i></p>
<p>
オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の
複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」
に提供されており、いかなる明示的、暗黙的保証も行わない。また、
いかなる目的に対しても、その利用が適していることを関知しない。
</p>
</body>
</html>
