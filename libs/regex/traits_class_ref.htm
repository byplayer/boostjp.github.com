<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=utf-8">
<meta name="keywords"
content="regex++, regular expressions, regular expression library, C++">
<meta name="Template"
content="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title> regex++ traits-class reference </title>
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top"><h3><img src="../../c++boost.gif"
        alt="C++ Boost" width="276" height="86"> </h3>
        </td>
        <td valign="top"><h3 align="center">Regex++, Traits Class
        Reference. </h3>
        <p align="left"><i>Copyright (c) 1998-2001 </i></p>
        <p align="left"><i>Dr John Maddock</i></p>
        <p align="left"><i>Permission to use, copy, modify,
        distribute and sell this software and its documentation
        for any purpose is hereby granted without fee, provided
        that the above copyright notice appear in all copies and
        that both that copyright notice and this permission
        notice appear in supporting documentation. Dr John
        Maddock makes no representations about the suitability of
        this software for any purpose. It is provided &quot;as is&quot;
        without express or implied warranty.</i></p>
        </td>
    </tr>
</table>

<hr>

<!--<p>This section describes the traits class requirements of the
reg_expression template class, these requirements are somewhat
complex (sorry), and subject to change as uses ask for new
features, however I will try to keep them stable for a while, and
ideally the requirements should lessen rather than increase. </p>-->
<p> この章では reg_expression テンプレートクラスの特性クラスの仕様について述べる。
これらの仕様は多少複雑(申し訳ない)で、新しい特徴の要求にあたり変更が必要である。
しかし私はしばらく、これらをこのままにしておこうと思う。
そして理想的には、仕様は増えるよりも減らされるべきである。</p>

<!--<p>The <i>reg_expression</i> traits classes encapsulate both the
properties of a character type, and the properties of the locale
associated with that type. The associated locale may be defined
at run-time (via std::locale), or hard-coded into the traits
class and determined at compile time. </p>-->
<p><i>reg_expression</i> 特性クラスは文字型の性質と、
その文字型に関連するロケールの性質の両方をカプセル化する。
関連するロケールは実行時に (std::locale によって) 定義されるかもしれないし、
特性クラスに直接コーディングされて、コンパイル時に決定されているかもしれない。</p>

<!--<p>The following example class illustrates the interface required
by a &quot;typical&quot; traits class for use with class
reg_expression: </p>-->
<p>次のクラスの例は、 クラス reg_expression で使うための、
&quot;典型的な&quot; 特性クラスに求められるインタフェースを説明している:</p>

<pre>
class mytraits
{
   typedef implementation_defined char_type;
   typedef implementation_defined uchar_type;
   typedef implementation_defined size_type;
   typedef implementation_defined string_type;
   typedef implementation_defined locale_type;
   typedef implementation_defined uint32_t;
   struct sentry
   {
      sentry(const mytraits&amp;);
      operator void*() { return this; }
   };

   enum char_syntax_type
   {
      syntax_char = 0,
      syntax_open_bracket = 1,                  // (
      syntax_close_bracket = 2,                 // )
      syntax_dollar = 3,                        // $
      syntax_caret = 4,                         // ^
      syntax_dot = 5,                           // .
      syntax_star = 6,                          // *
      syntax_plus = 7,                          // +
      syntax_question = 8,                      // ?
      syntax_open_set = 9,                      // [
      syntax_close_set = 10,                    // ]
      syntax_or = 11,                           // |
      syntax_slash = 12,                        //
      syntax_hash = 13,                         // #
      syntax_dash = 14,                         // -
      syntax_open_brace = 15,                   // {
      syntax_close_brace = 16,                  // }
      syntax_digit = 17,                        // 0-9
      syntax_b = 18,                            // for \b
      syntax_B = 19,                            // for \B
      syntax_left_word = 20,                    // for \&lt;
      syntax_right_word = 21,                   // for \
      syntax_w = 22,                            // for \w
      syntax_W = 23,                            // for \W
      syntax_start_buffer = 24,                 // for \`
      syntax_end_buffer = 25,                   // for \'
      syntax_newline = 26,                      // for newline alt
      syntax_comma = 27,                        // for {x,y}

      syntax_a = 28,                            // for \a
      syntax_f = 29,                            // for \f
      syntax_n = 30,                            // for \n
      syntax_r = 31,                            // for \r
      syntax_t = 32,                            // for \t
      syntax_v = 33,                            // for \v
      syntax_x = 34,                            // for \xdd
      syntax_c = 35,                            // for \cx
      syntax_colon = 36,                        // for [:...:]
      syntax_equal = 37,                        // for [=...=]
   
      // perl ops:
      syntax_e = 38,                            // for \e
      syntax_l = 39,                            // for \l
      syntax_L = 40,                            // for \L
      syntax_u = 41,                            // for \u
      syntax_U = 42,                            // for \U
      syntax_s = 43,                            // for \s
      syntax_S = 44,                            // for \S
      syntax_d = 45,                            // for \d
      syntax_D = 46,                            // for \D
      syntax_E = 47,                            // for \Q\E
      syntax_Q = 48,                            // for \Q\E
      syntax_X = 49,                            // for \X
      syntax_C = 50,                            // for \C
      syntax_Z = 51,                            // for \Z
      syntax_G = 52,                            // for \G
      syntax_bang = 53,                         // reserved for future use '!'
      syntax_and = 54,                          // reserve for future use '&amp;'
   };

   enum{
      char_class_none = 0,
      char_class_alpha,
      char_class_cntrl,
      char_class_digit,
      char_class_lower,
      char_class_punct,
      char_class_space,
      char_class_upper,
      char_class_xdigit,
      char_class_blank,
      char_class_unicode,
      char_class_alnum,
      char_class_graph,
      char_class_print,
      char_class_word
   };

   static size_t length(const char_type* p);
   unsigned int syntax_type(size_type c)const;
   char_type translate(char_type c, bool icase)const;
   void transform(string_type&amp; out, const string_type&amp; in)const;
   void transform_primary(string_type&amp; out, const string_type&amp; in)const;
   bool is_separator(char_type c)const;
   bool is_combining(char_type)const;
   bool is_class(char_type c, uint32_t f)const;
   int toi(char_type c)const;
   int toi(const char_type*&amp; first, const char_type* last, int radix)const;
   uint32_t lookup_classname(const char_type* first, const char_type* last)const;
   bool lookup_collatename(string_type&amp; buf, const char_type* first, const char_type* last)const;
   locale_type imbue(locale_type l);
   locale_type getloc()const;
   std::string error_string(unsigned id)const;

   mytraits();
   ~mytraits();
};
</pre>

<!--<p>The member types required by a traits class are defined as
follows:<br>
&nbsp;&nbsp; </p>-->
<p>特性クラスに求められるメンバ型は次のように定義されている:<br>
&nbsp;&nbsp; </p>

<table border="0" cellpadding="7" width="100%">
    <tr>
        <td valign="top" width="4%" bgcolor="#FFFFFF">&nbsp; </td>
<!--        <td valign="top" width="26%" bgcolor="#008080">Member
        name </td>
        <td valign="top" width="63%" bgcolor="#008080">Description
        </td>-->
        <td valign="top" width="26%" bgcolor="#008080">メンバ名</td>
        <td valign="top" width="63%" bgcolor="#008080">説明</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="4%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="26%" bgcolor="#C0C0C0">char_type </td>
<!--        <td valign="top" width="63%" bgcolor="#C0C0C0">The
        character type encapsulated by this traits class, must be
        a POD type, and be convertible to uchar_type. </td>-->
        <td valign="top" width="63%" bgcolor="#C0C0C0">
	この特性クラスがカプセル化する文字型。
	POD 型でなければならない。uchar_type に変換可能でなければならない。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="4%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="26%" bgcolor="#C0C0C0">uchar_type
        </td>
<!--        <td valign="top" width="63%" bgcolor="#C0C0C0">The
        unsigned type corresponding to char_type, must be
        convertible to size_type. </td>-->
        <td valign="top" width="63%" bgcolor="#C0C0C0">
	char_type に対応する unsigned 型。
	size_type に変換可能でなければならない。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="4%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="26%" bgcolor="#C0C0C0">size_type </td>
<!--        <td valign="top" width="63%" bgcolor="#C0C0C0">An
        unsigned integral type, with at least as much precision
        as uchar_type. </td>-->
        <td valign="top" width="63%" bgcolor="#C0C0C0">
	符号なし整数型。uchar_type と同じ精度でなければならない。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="4%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="26%" bgcolor="#C0C0C0">string_type
        </td>
<!--        <td valign="top" width="63%" bgcolor="#C0C0C0">A type
        that offers the same facilities as std::basic_string&lt;char_type.
        This is used for collating elements, and sort strings, if
        char_type has no locale dependent collation (it is not a
        &quot;character&quot;), then it could be something
        simpler than std::basic_string. </td>-->
        <td valign="top" width="63%" bgcolor="#C0C0C0">
	std::basic_string&lt;char_type&gt; と同じ能力を提供する型。
	これは照合要素、文字列のソートのために使われる。
	もし char_type がロケール依存の照合を持っていなければ
	(&quot;文字&quot;ではない)、
	これは std::basic_string よりも単純なものでよい。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="4%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="26%" bgcolor="#C0C0C0">locale_type
        </td>
<!--        <td valign="top" width="63%" bgcolor="#C0C0C0">A type
        that encapsulates the locale used by the traits class,
        probably std::locale but could be a platform specific
        type, or a dummy type if per-instance locales are not
        supported by the traits class. </td>-->
        <td valign="top" width="63%" bgcolor="#C0C0C0">
	特性クラスで使われるロケールをカプセル化する型。
	おそらく std::locale だと思うが、
	プラットフォーム特有の型も可能である。
	または、もしインスタンス毎のロケールを特性クラスがサポートしないなら、
	ダミー型も可能である。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="4%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="26%" bgcolor="#C0C0C0">uint32_t </td>
<!--        <td valign="top" width="63%" bgcolor="#C0C0C0">An
        unsigned integral type with at least 32-bits of
        precision, used as a bitmask type for character
        classification. </td>-->
        <td valign="top" width="63%" bgcolor="#C0C0C0">
	少なくとも 32ビットの精度を持つ 符号なし整数型。
	文字分類のためのビットマスク型として使われる。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="4%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="26%" bgcolor="#C0C0C0">sentry </td>
<!--        <td valign="top" width="63%" bgcolor="#C0C0C0">A class or
        struct type which is constructible from an instance of
        the traits class, and is convertible to void*. An
        instance of type sentry will be constructed before
        compiling each regular expression, it provides an
        opportunity to carry out prefix/suffix operations on the
        traits class.&nbsp; <p>For example a traits class that
        encapsulates the global locale, can use this as an
        opportunity to synchronize with the global locale (by
        updating any cached data). </p>
        </td>-->
        <td valign="top" width="63%" bgcolor="#C0C0C0">
	特性クラスのインスタンスから構築可能で、
	void* への変換可能なクラスもしくは構造体型。
	sentry 型のインスタンスはそれぞれの正規表現をコンパイルする前に構築される。
	これは、特性クラスの接頭辞/接尾辞操作を実行する機会を提供する。&nbsp;
	<p>例えば、グローバルロケールをカプセル化した特性クラスは、
	(キャッシュされたデータを更新することで)グローバルロケールと同期する機会として、
	これを利用することが出来る。</p></td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
</table>

<!--<p><br>
&nbsp;The following member constants are used to represent the
locale independent syntax of a regular expression; the member
function <i>syntax_type</i> returns one of these values, and is
used to convert a locale dependent regular expression, into a
locale-independent sequence of tokens.<br>
&nbsp;</p>-->
<p><br>
&nbsp;次のメンバ定数は、ロケール非依存な正規表現の構文をあらわすために使われる。
メンバ関数 <i>syntax_type</i> はこれらの値のうちの一つを返し、
ロケール依存の正規表現をロケール非依存なトークンのシーケンスに変換するために使われる。<br>
&nbsp;</p>

<table border="0" cellpadding="7" width="100%">
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
<!--        <td valign="top" width="40%" bgcolor="#008080">Member
        constant&nbsp; </td>
        <td valign="top" width="50%" bgcolor="#008080">English
        language representation&nbsp; </td>-->
        <td valign="top" width="40%" bgcolor="#008080">メンバ定数&nbsp; </td>
        <td valign="top" width="50%" bgcolor="#008080">英語での表現&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_char&nbsp;
        </td>
<!--        <td valign="top" width="50%" bgcolor="#C0C0C0">All non-special
        characters.&nbsp; </td>-->
        <td valign="top" width="50%" bgcolor="#C0C0C0">全ての特殊でない文字&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_open_bracket&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">(&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_close_bracket&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">)&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_dollar&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">$&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_caret&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">^&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_dot&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">.&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_star&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">*&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_plus&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">+&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_question&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">?&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_open_set&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">[&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_close_set&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">]&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_or&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">|&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_slash&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">\&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_hash&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">#&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_dash&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">-&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_open_brace&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">{&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_close_brace&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">}&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_digit&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">0123456789&nbsp;
        </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_b&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">b&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_B&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">B&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_left_word&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">&lt;&nbsp;
        </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_right_word&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_w&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">w&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_W&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">W&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_start_buffer&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">`&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_end_buffer&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">'&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_newline&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">\n&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_comma&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">,&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_a&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">a&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_f&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">f&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_n&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">n&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_r&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">r&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_t&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">t&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_v&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">v&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_x&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">x&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_c&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">c&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_colon&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">:&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_equal&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">=&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_e&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">e&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_l&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">l&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_L&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">L&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_u&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">u&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_U&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">U&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_s&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">s&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_S&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">S&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_d&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">d&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_D&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">D&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_E&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">E&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_Q&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">Q&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_X&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">X&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_C&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">C&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_Z&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">Z&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_G&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">G&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_bang&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">!&nbsp; </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="40%" bgcolor="#C0C0C0">syntax_and&nbsp;
        </td>
        <td valign="top" width="50%" bgcolor="#C0C0C0">&amp;&nbsp;
        </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
</table>

<!--<p>The following member constants are used to represent
particular character classifications:<br>
&nbsp; </p>-->
<p>次のメンバ定数は特別な文字分類を表すために使われる:<br>
&nbsp; </p>

<table border="0" cellpadding="7" width="100%">
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
<!--        <td valign="top" width="33%" bgcolor="#008080">Member
        constant&nbsp; </td>-->
        <td valign="top" width="33%" bgcolor="#008080">メンバ定数&nbsp; </td>
        <td valign="top" width="56%" bgcolor="#008080">説明</td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_none&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">No
        classification, must be zero. </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">分類なし。ゼロでなければならない。</td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_alpha&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">All
        alphabetic characters. </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">全てのアルファベット文字 </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_cntrl&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">All
        control characters. </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">全てのコントロール文字 </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_digit&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">All
        decimal digits. </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">全ての10進数字 </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_lower&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">All lower
        case characters. </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">全ての小文字 </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_punct&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">All
        punctuation characters. </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">全ての句読点 </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_space&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">All white-space
        characters. </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">全ての空白文字 </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_upper&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">All upper
        case characters. </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">全ての大文字 </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_xdigit&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">All
        hexadecimal digit characters. </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">全ての16進数字 </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_blank&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">All blank
        characters (space + tab). </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">全てのブランク文字(スペースとタブ) </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_unicode&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">All
        extended unicode characters - those that can not be
        represented as a single narrow character. </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">全ての拡張ユニコード文字。
	これらは単一のナロウキャラクタとしてあらわすことができない。</td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_alnum&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">All alpha-numeric
        characters. </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">全ての文字と数字</td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_graph&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">All
        graphic characters. </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">全ての絵文字 </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_print&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">All
        printable characters. </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">全ての印字可能文字 </td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="33%" bgcolor="#C0C0C0">char_class_word&nbsp;
        </td>
<!--        <td valign="top" width="56%" bgcolor="#C0C0C0">All word
        characters (alphanumeric characters + the underscore). </td>-->
        <td valign="top" width="56%" bgcolor="#C0C0C0">単語を形成する文字全て
	(文字、数字、アンダースコア)</td>
        <td valign="top" width="5%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
</table>

<!--<p>The following member functions are required by all regular
expression traits classes, those members that are declared here
as <i>const</i>, could be declared <i>static</i> instead if the
class does not contain instance data:<br>
&nbsp; </p>-->
<p>次のメンバ関数が全ての正規表現特性クラスに必要である。
ここで <i>const</i> として宣言されているメンバは、
もしクラスがインスタンスのデータを含まなければ
代わりに <i>static</i> として宣言することが出来る。<br>
&nbsp; </p>

<table border="0" cellpadding="7" width="100%">
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
<!--        <td valign="top" width="36%" bgcolor="#008080">Member
        function </td>
        <td valign="top" width="51%" bgcolor="#008080">Description
        </td>-->
        <td valign="top" width="36%" bgcolor="#008080">メンバ関数 </td>
        <td valign="top" width="51%" bgcolor="#008080">説明 </td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">static
        size_t length(const char_type* p); </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">Returns
        the length of the null-terminated string p. </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">null 終端文字列 p の長さを返す。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">unsigned
        int syntax_type(size_type c)const; </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Converts
        an input character into a locale independent token (one
        of the syntax_xxx member constants). Called when parsing
        the regular expression into a locale-independent parse
        tree.&nbsp; <p>Example: in English language regular
        expressions we would use &quot;[[:word:]]&quot; to
        represent the character class of all word characters, and
        &quot;\w&quot; as a shortcut for this. Consequently
        syntax_type('w') returns syntax_w. In French language
        regular expressions, we would use &quot;[[:mot:]]&quot;
        in place of &quot;[[:word:]]&quot; and therefore &quot;\m&quot;
        in place of &quot;\w&quot;, therefore it is syntax_type('m')
        that returns syntax_w. </p>
        </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;
	入力文字列をロケール非依存なトークン (syntax_xxx メンバ定数のひとつ) に変換する。
	正規表現をロケール非依存な解析木に構文解析するときに呼ばれる。&nbsp;
	<p>例: 英語での正規表現では、全ての単語形成文字の文字クラスをあらわすために、
	&quot[[:word:]]&quot; とこの略記 &quot;\w&quot; を使うことが出来る。
	結果的に、 syntax_type('w') は syntax_w を返す。
	フランス語での正規表現では、 &quot;[[:word:]]&quot; の代わりに、
	&quot;[[:mot:]]&quot; を、
	&quot;\w&quot; の代わりに &quot;\m&quot; を使うことが出来る。
	このため、 syntax_w を返すのは、 syntax_type('m') である。</p>
        </td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">char_type
        translate(char_type c, bool icase)const; </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Translates
        an input character into a unique identifier that
        represents the equivalence class that that character
        belongs to. If icase is true, then the returned value is
        insensitive to case.&nbsp; <p>[An equivalence class is
        the set of all characters that must be treated as being
        equivalent to each other.] </p>
        </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;
	入力文字を、その文字が属する等価クラスをあらわす一意の識別子に変形する。
	もし icase が真なら、戻り値は大文字小文字を考慮しない。&nbsp;
	<p>[等価クラスは互いに等価であると扱われなければならない文字すべての集合である。]</p>
        </td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">void
        transform(string_type&amp; out, const string_type&amp; in)const;
        </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Transforms
        the string <i>in</i>, into a locale-dependent sort key,
        and stores the result in <i>out</i>. </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;
	文字列 <i>in</i> をロケール依存のソートキーに変形し、
	<i>out</i> に結果を格納する。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">void
        transform_primary(string_type&amp; out, const
        string_type&amp; in)const; </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Transforms
        the string <i>in,</i> into a locale-dependent primary
        sort key, and stores the result in <i>out</i>. </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;
	文字列 <i>in</i> をロケール依存の主ソートキーに変形し、
	結果を <i>out</i> に格納する。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">bool
        is_separator(char_type c)const; </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Returns
        true only if <i>c</i> is a line separator. </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;
	<i>c</i> が行の区切りなら true を返す。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">bool
        is_combining(char_type c)const; </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Returns
        true only if <i>c</i> is a unicode combining character. </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;
	<i>c</i> がユニコード複合文字なら true を返す。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">bool
        is_class(char_type c, uint32_t f)const; </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Returns
        true only if <i>c</i> is a member of one of the character
        classes represented by the bitmap <i>f</i>. </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;
	<i>c</i> がビットマップ <i>f</i> であらわされる文字クラスの要素なら
	true を返す。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">int toi(char_type
        c)const; </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Converts
        the character <i>c</i> to a decimal integer.&nbsp; <p>[Precondition:
        is_class(c,char_class_digit)==true] </p>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;
	文字 <i>c</i> を10進整数に変換する。&nbsp;
	<p>[事前条件: is_class(c,char_class_digit)==true] </p>
        </td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">int toi(const
        char_type*&amp; first, const char_type* last, int radix)const;
        </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Converts
        the string [first-last) into an integral value using base
        <i>radix.</i> Stops when it finds the first non-digit
        character, and sets <i>first</i> to point to that
        character.&nbsp; <p>[Precondition: is_class(*first,char_class_digit)==true]
        </p>
        </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;
	文字列 [first-last) を基数 <i>radix</i> の整数値に変換する。
	最初の非数字文字を発見したら停止し、 <i>first</i> がその文字をさすように設定する。
	&nbsp; <p>[事前条件: is_class(*first,char_class_digit)==true]
        </p>
        </td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">uint32_t
        lookup_classname(const char_type* first, const char_type*
        last)const; </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Returns
        the bitmap representing the character class [first-last),
        or char_class_none if [first-last) is not recognized as a
        character class name. </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;
	文字クラス [first-last) をあらわすビットマップを返す。
	もし [first-last) が文字クラス名として認識されたければ、
	char_class_none を返す。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">bool
        lookup_collatename(string_type&amp; buf, const char_type*
        first, const char_type* last)const; </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">If the
        sequence [first-last) is the name of a known collating
        element, then stores the collating element in buf, and
        returns true, otherwise returns false. </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">
	シーケンス [first-last) が既知の照合要素名であれば、
	その照合要素を buf に格納し、 true を返す。
	そうでなければ、 false を返す。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">locale_type
        imbue(locale_type l); </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Imbues
        the class with the locale <i>l</i>. </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;
	クラスをロケール <i>l</i> にする。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">locale_type
        getloc()const; </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Returns
        the traits-class locale. </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;
	特性クラスのロケールを返す。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">std::string
        error_string(unsigned id)const; </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Returns
        the locale-dependent error-string associated with the
        error-number <i>id</i>. The parameter <i>id</i> is one of
        the REG_XXX error codes described by the POSIX standard,
        and defined in &lt;boost/cregex.hpp. </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;
	エラー番号 <i>id</i> に対するロケール依存のエラー文字列を返す。
	引数 <i>id</i> は POSIX 標準で述べられ、 &lt;boost/cregex.hpp
	で定義されている REG_XXX エラーコードのひとつである。</td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">mytraits();
        </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Constructor.
        </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;コンストラクタ
        </td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
    <tr>
        <td valign="top" width="7%" bgcolor="#FFFFFF">&nbsp; </td>
        <td valign="top" width="36%" bgcolor="#C0C0C0">~ mytraits();
        </td>
<!--        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;Destructor.
        </td>-->
        <td valign="top" width="51%" bgcolor="#C0C0C0">&nbsp;デストラクタ
        </td>
        <td valign="top" width="6%" bgcolor="#FFFFFF">&nbsp; </td>
    </tr>
</table>

<!--<p>There is also an example of a custom traits class supplied by <a
href="mailto:christian.engstrom@glindra.org">Christian Engstr・</a>,
see <a
href="example/iso8859_1_regex_traits/iso8859_1_regex_traits.cpp">iso8859_1_regex_traits.cpp</a>
and <a
href="example/iso8859_1_regex_traits/iso8859_1_regex_traits.hpp">iso8859_1_regex_traits.hpp</a>.
This example inherits from c_regex_traits and provides it's own
implementations of two locale specific functions. This ensures
that the class gives consistent behaviour (albeit tied to one
locale) on all platforms. A fuller desciption by the author is
available in the <a
href="example/iso8859_1_regex_traits/readme.txt">readme file</a>.<br>
</p>-->
<p>カスタマイズされた特性クラスの例が
<a href="mailto:christian.engstrom@glindra.org">Christian Engstr・</a>
によっても提供されている。
<a href="example/iso8859_1_regex_traits/iso8859_1_regex_traits.cpp">iso8859_1_regex_traits.cpp</a>
及び
<a href="example/iso8859_1_regex_traits/iso8859_1_regex_traits.hpp">iso8859_1_regex_traits.hpp</a>
を見よ。
この例は c_regex_traits を継承し、二つのロケール特有の関数についてのそれ自身の実装を提供している。
これは (ひとつのロケールに結び付けられる限り) 
全てのプラットフォームでそのクラスが安定した振る舞いを与えることを保証する。
作者によるより完全な説明は、
<a href="example/iso8859_1_regex_traits/readme.txt">readme file</a>
で利用可能である。<br>
</p>

<hr>

<p><i>Copyright</i> <a href="mailto:John_Maddock@compuserve.com"><i>Dr
John Maddock</i></a> <i>1998-2001 all rights reserved.</i> </p>
<hr align="left">
<p><i>Japanese Translation Copyright (C) 2003 <a href="mailto:kohske@msc.biglobe.ne.jp">Kohske Takahashi</a></i></p>
<p>
オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の
複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」
に提供されており、いかなる明示的、暗黙的保証も行わない。また、
いかなる目的に対しても、その利用が適していることを関知しない。
</p>

</body>
</html>
