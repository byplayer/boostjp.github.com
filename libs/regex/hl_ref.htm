<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=utf-8">
<meta name="Template"
content="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Regex++, RegEx Class Reference</title>
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">

<p>&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top"><h3><img src="../../c++boost.gif"
        alt="C++ Boost" width="276" height="86"></h3>
        </td>
        <td valign="top"><h3 align="center">Regex++, RegEx Class
        Reference. </h3>
        <p align="left"><i>Copyright (c) 1998-2001 </i></p>
        <p align="left"><i>Dr John Maddock</i></p>
        <p align="left"><i>Permission to use, copy, modify,
        distribute and sell this software and its documentation
        for any purpose is hereby granted without fee, provided
        that the above copyright notice appear in all copies and
        that both that copyright notice and this permission
        notice appear in supporting documentation. Dr John
        Maddock makes no representations about the suitability of
        this software for any purpose. It is provided &quot;as is&quot;
        without express or implied warranty.</i></p>
        </td>
    </tr>
</table>

<hr>

<h3><a name="RegEx"></a><i>Class RegEx</i></h3>

<p>#include &lt;boost/cregex.hpp&gt; </p>

<!--<p>The class RegEx provides a high level simplified interface to
the regular expression library, this class only handles narrow
character strings, and regular expressions always follow the
&quot;normal&quot; syntax - that is the same as the standard
POSIX extended syntax, but with locale specific collation
disabled, and escape characters inside character set declarations
are allowed. </p>-->
<p>クラス RegEx は正規表現ライブラリに対する高水準の単純化されたインタフェースを提供する。
このクラスはナロウキャラクタ文字列のみを扱い、正規表現は常に
&quot;通常の&quot; 構文に従う。
つまり、標準 POSIX 拡張構文と同じであるが、
ロケールに特殊な照合は不可能であり、
文字集合宣言の中でのエスケープ文字が許されている。</p>

<pre><b>typedef</b> <b>bool</b> (*GrepCallback)(<b>const</b> RegEx&amp; expression);
<b>typedef</b> <b>bool</b> (*GrepFileCallback)(<b>const</b> <b>char</b>* file, <b>const</b> RegEx&amp; expression);
<b>typedef</b> <b>bool</b> (*FindFilesCallback)(<b>const</b> <b>char</b>* file);

<b>class</b>&nbsp; RegEx
{
<b>public</b>:
&nbsp;&nbsp; RegEx();
&nbsp;&nbsp; RegEx(<b>const</b> RegEx&amp; o);
&nbsp;&nbsp; ~RegEx();
&nbsp;&nbsp; RegEx(<b>const</b> <b>char</b>* c, <b>bool</b> icase = <b>false</b>);
&nbsp;&nbsp; <strong>explicit</strong> RegEx(<b>const</b> std::string&amp; s, <b>bool</b> icase = <b>false</b>);
&nbsp;&nbsp; RegEx&amp; <b>operator</b>=(<b>const</b> RegEx&amp; o);
&nbsp;&nbsp; RegEx&amp; <b>operator</b>=(<b>const</b> <b>char</b>* p);
&nbsp;&nbsp; RegEx&amp; <b>operator</b>=(<b>const</b> std::string&amp; s);
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> SetExpression(<b>const</b> <b>char</b>* p, <b>bool</b> icase = <b>false</b>);
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> SetExpression(<b>const</b> std::string&amp; s, <b>bool</b> icase = <b>false</b>);
&nbsp;&nbsp; std::string Expression()<b>const</b>;
&nbsp;&nbsp; <font color="#000080"><i>//
 </i>&nbsp;&nbsp;<i>// now matching operators: </i>
&nbsp;&nbsp; <i>// </i></font>
&nbsp;&nbsp; <b>bool</b> Match(<b>const</b> <b>char</b>* p, <b>unsigned</b> <b>int</b> flags = match_default);
&nbsp;&nbsp; <b>bool</b> Match(<b>const</b> std::string&amp; s, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>bool</b> Search(<b>const</b> <b>char</b>* p, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>bool</b> Search(<b>const</b> std::string&amp; s, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Grep(GrepCallback cb, <b>const</b> <b>char</b>* p, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Grep(GrepCallback cb, <b>const</b> std::string&amp; s, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Grep(std::vector&lt;std::string&gt;&amp; v, <b>const</b> <b>char</b>* p, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Grep(std::vector&lt;std::string&gt;&amp; v, <b>const</b> std::string&amp; s, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Grep(std::vector&lt;<b>unsigned</b> <b>int</b>&gt;&amp; v, <b>const</b> <b>char</b>* p, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Grep(std::vector&lt;<b>unsigned</b> <b>int</b>&gt;&amp; v, <b>const</b> std::string&amp; s, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> GrepFiles(GrepFileCallback cb, <b>const</b> <b>char</b>* files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> GrepFiles(GrepFileCallback cb, <b>const</b> std::string&amp; files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> FindFiles(FindFilesCallback cb, <b>const</b> <b>char</b>* files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> FindFiles(FindFilesCallback cb, <b>const</b> std::string&amp; files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; std::string Merge(<b>const</b> std::string&amp; in, <b>const</b> std::string&amp; fmt, <b>bool</b> copy = <b>true</b>, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; std::string Merge(<b>const</b> char* in, <b>const</b> char* fmt, <b>bool</b> copy = <b>true</b>, <b>unsigned int </b>flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> Split(std::vector&lt;std::string&gt;&amp; v, std::string&amp; s, <b>unsigned</b> flags = match_default, <b>unsigned</b> max_count = ~0); 
&nbsp;&nbsp; <font color="#000080"><i>// 
</i>&nbsp;&nbsp; <i>// now operators for returning what matched in more detail: 
</i>&nbsp;&nbsp; <i>// 
</i></font>&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Position(<b>int</b> i = 0)<b>const</b>; 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Length(<b>int</b> i = 0)<b>const</b>; 
   <strong>bool</strong> Matched(<strong>int</strong> i = 0)<strong>const</strong>;
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Line()<b>const</b>; 
&nbsp;&nbsp; <b>unsigned int</b> Marks() const; 
&nbsp;&nbsp; std::string What(<b>int</b> i)<b>const</b>; 
&nbsp;&nbsp; std::string <b>operator</b>[](<b>int</b> i)<b>const</b> ; 

   <strong>static const unsigned int</strong> npos;
}; &nbsp; &nbsp; </pre>

<!--<p>Member functions for class RegEx are defined as follows: <br>
&nbsp; </p>-->
<p>クラス RegEx のメンバ関数は以下のように定義されている:<br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">RegEx();</td>
<!--        <td valign="top" width="42%">Default constructor,
        constructs an instance of RegEx without any valid
        expression.</td>-->
        <td valign="top" width="42%">デフォルトコンストラクタ:
	有効な正規表現を持たない RegEx のインスタンスを構築する。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">RegEx(<b>const</b>
        RegEx&amp; o);</td>
<!--        <td valign="top" width="42%">Copy constructor, all the
        properties of parameter <i>o</i> are copied.</td>-->
        <td valign="top" width="42%">コピーコンストラクタ:
	引数 <i>o</i> の全てのプロパティがコピーされる。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">RegEx(<b>const</b> <b>char</b>*
        c, <b>bool</b> icase = <b>false</b>);</td>
<!--        <td valign="top" width="42%">Constructs an instance of
        RegEx, setting the expression to <i>c</i>, if <i>icase</i>
        is <i>true</i> then matching is insensitive to case,
        otherwise it is sensitive to case. Throws <i>bad_expression</i>
        on failure.</td>-->
        <td valign="top" width="42%">正規表現を <i>c</i> に設定して、
	RegEx のインスタンスを構築する。
	もし <i>icase</i> が <i>true</i> なら一致は大文字小文字によらない。
	そうでなければ、大文字小文字を区別して一致が行われる。
	失敗したときは <i>bad_expression</i> が投げられる。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">RegEx(<b>const</b> std::string&amp;
        s, <b>bool</b> icase = <b>false</b>);</td>
<!--        <td valign="top" width="42%">Constructs an instance of
        RegEx, setting the expression to <i>s</i>, if <i>icase </i>is
        <i>true</i> then matching is insensitive to case,
        otherwise it is sensitive to case. Throws <i>bad_expression</i>
        on failure.</td>-->
        <td valign="top" width="42%">正規表現を <i>s</i> に設定して、
	RegEx のインスタンスを構築する。
	もし <i>icase</i> が <i>true</i> なら一致は大文字小文字によらない。
	そうでなければ、大文字小文字を区別して一致が行われる。
	失敗したときは <i>bad_expression</i> が投げられる。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">RegEx&amp; <b>operator</b>=(<b>const</b>
        RegEx&amp; o);</td>
<!--        <td valign="top" width="42%">Default assignment operator.</td>-->
        <td valign="top" width="42%">デフォルトの代入演算子</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">RegEx&amp; <b>operator</b>=(<b>const</b>
        <b>char</b>* p);</td>
<!--        <td valign="top" width="42%">Assignment operator,
        equivalent to calling <i>SetExpression(p, false).</i>
        Throws <i>bad_expression</i> on failure.</td>-->
        <td valign="top" width="42%">代入演算子。
	<i>SetExpression(p, false) を呼び出すのと等価である。
	失敗すれば <i>bad_expression</i> が投げられる。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">RegEx&amp; <b>operator</b>=(<b>const</b>
        std::string&amp; s);</td>
<!--        <td valign="top" width="42%">Assignment operator,
        equivalent to calling <i>SetExpression(s, false).</i>
        Throws <i>bad_expression</i> on failure.</td>-->
        <td valign="top" width="42%">代入演算子。
	<i>SetExpression(s, false) を呼び出すのと等価である。
	失敗すれば <i>bad_expression</i> が投げられる。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        SetExpression(<b>constchar</b>* p, <b>bool</b> icase = <b>false</b>);</td>
<!--        <td valign="top" width="42%">Sets the current expression
        to <i>p</i>, if <i>icase</i> is <i>true</i> then matching
        is insensitive to case, otherwise it is sensitive to case.
        Throws <i>bad_expression</i> on failure.</td>-->
        <td valign="top" width="42%">現在の正規表現を <i>p</i> に設定する。
	もし <i>icase</i> が <i>true</i> なら一致は大文字小文字によらない。
	そうでなければ、大文字小文字を区別して一致が行われる。
	失敗したときは <i>bad_expression</i> が投げられる。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        SetExpression(<b>const</b> std::string&amp; s, <b>bool</b>
        icase = <b>false</b>);</td>
<!--        <td valign="top" width="42%">Sets the current expression
        to <i>s</i>, if <i>icase</i> is <i>true</i> then matching
        is insensitive to case, otherwise it is sensitive to case.
        Throws <i>bad_expression</i> on failure.</td>-->
        <td valign="top" width="42%">現在の正規表現を <i>s</i> に設定する。
	もし <i>icase</i> が <i>true</i> なら一致は大文字小文字によらない。
	そうでなければ、大文字小文字を区別して一致が行われる。
	失敗したときは <i>bad_expression</i> が投げられる。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">std::string Expression()<b>const</b>;</td>
<!--        <td valign="top" width="42%">Returns a copy of the
        current regular expression.</td>-->
        <td valign="top" width="42%">現在の正規表現のコピーを返す。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>bool</b> Match(<b>const</b>
        <b>char</b>* p, <b>unsigned</b> <b>int</b> flags =
        match_default);</td>
<!--        <td valign="top" width="42%">Attempts to match the
        current expression against the text <i>p</i> using the
        match flags <i>flags</i> - see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        Returns <i>true</i> if the expression matches the whole
        of the input string.</td>-->
        <td valign="top" width="42%">テキスト <i>p</i> に対して
	マッチフラグ <i>flags</i> を使って現在の正規表現の一致判定を行う。
        <a href="template_class_ref.htm#match_type">match flags</a> を見よ。
	正規表現が入力文字列全体と一致すれば <i>true</i> を返す。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>bool</b> Match(<b>const</b>
        std::string&amp; s, <b>unsigned</b> <b>int</b> flags =
        match_default) ;</td>
<!--        <td valign="top" width="42%">Attempts to match the
        current expression against the text <i>s</i> using the
        match flags <i>flags</i> - see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        Returns <i>true</i> if the expression matches the whole
        of the input string.</td>-->
        <td valign="top" width="42%">テキスト <i>s</i> に対して
	マッチフラグ <i>flags</i> を使って現在の正規表現の一致判定を行う。
        <a href="template_class_ref.htm#match_type">match flags</a> を見よ。
	正規表現が入力文字列全体と一致すれば <i>true</i> を返す。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>bool</b> Search(<b>const</b>
        <b>char</b>* p, <b>unsigned</b> <b>int</b> flags =
        match_default);</td>
<!--        <td valign="top" width="42%">Attempts to find a match for
        the current expression somewhere in the text <i>p</i>
        using the match flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        Returns <i>true</i> if the match succeeds.</td>-->
        <td valign="top" width="42%">マッチフラグ <i>flags</i> を使って、
	テキスト <i>p</i> のどこかに現在の正規表現との一致があるかを判定する。
        <a href="template_class_ref.htm#match_type">match flags</a> を見よ。
        もし一致が発見されたら <i>true</i> を返す。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>bool</b> Search(<b>const</b>
        std::string&amp; s, <b>unsigned</b> <b>int</b> flags =
        match_default) ;</td>
<!--        <td valign="top" width="42%">Attempts to find a match for
        the current expression somewhere in the text <i>s</i>
        using the match flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        Returns <i>true</i> if the match succeeds.</td>-->
        <td valign="top" width="42%">マッチフラグ <i>flags</i> を使って、
	テキスト <i>s</i> のどこかに現在の正規表現との一致があるかを判定する。
        <a href="template_class_ref.htm#match_type">match flags</a> を見よ。
        もし一致が発見されたら <i>true</i> を返す。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Grep(GrepCallback cb, <b>const</b> <b>char</b>* p, <b>unsigned</b>
        <b>int</b> flags = match_default);</td>
<!--        <td valign="top" width="42%">Finds all matches of the
        current expression in the text <i>p</i> using the match
        flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match found calls the call-back function <i>cb</i>
        as: cb(*this); <p>If at any stage the call-back function
        returns false then the grep operation terminates,
        otherwise continues until no further matches are found.
        Returns the number of matches found.</p>
        </td>-->
        <td valign="top" width="42%">マッチフラグ <i>flags</i> を使って、
	テキスト <i>p</i> の中にある、現在の正規表現との一致を全て発見する。
        <a href="template_class_ref.htm#match_type">match flags</a>を見よ。
	それぞれの一致が発見されるたびに、コールバック関数 <i>cb</i> が
	cb(*this) という形で呼ばれる。
	<p>どの段階でも、コールバック関数が false を返せば、grep 操作は終了し、
	そうでなければ、一致がそれ以上発見されなくなるまで続けられる。
	発見された一致の数を返す。</p></td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Grep(GrepCallback cb, <b>const</b> std::string&amp; s, <b>unsigned</b>
        <b>int</b> flags = match_default);</td>
<!--        <td valign="top" width="42%">Finds all matches of the
        current expression in the text <i>s</i> using the match
        flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match found calls the call-back function <i>cb</i>
        as: cb(*this); <p>If at any stage the call-back function
        returns false then the grep operation terminates,
        otherwise continues until no further matches are found.
        Returns the number of matches found. </p>
        </td>-->
        <td valign="top" width="42%">マッチフラグ <i>flags</i> を使って、
	テキスト <i>s</i> の中にある、現在の正規表現との一致を全て発見する。
        <a href="template_class_ref.htm#match_type">match flags</a>を見よ。
	それぞれの一致が発見されるたびに、コールバック関数 <i>cb</i> が
	cb(*this) という形で呼ばれる。
	<p>どの段階でも、コールバック関数が false を返せば、grep 操作は終了し、
	そうでなければ、一致がそれ以上発見されなくなるまで続けられる。
	発見された一致の数を返す。</p></td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Grep(std::vector&lt;std::string&gt;&amp; v, <b>const</b> <b>char</b>*
        p, <b>unsigned</b> <b>int</b> flags = match_default);</td>
<!--        <td valign="top" width="42%">Finds all matches of the
        current expression in the text <i>p</i> using the match
        flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match pushes a copy of what matched onto <i>v</i>.
        Returns the number of matches found.</td>-->
        <td valign="top" width="42%">マッチフラグ <i>flags</i> を使って、
	テキスト <i>p</i> の中にある、現在の正規表現との一致を全て発見する。
        <a href="template_class_ref.htm#match_type">match flags</a>を見よ。
	それぞれの一致のたびに、一致したもののコピーが <i>v</i> に送られる。
	発見された一致の数を返す。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Grep(std::vector&lt;std::string&gt;&amp; v, <b>const</b>
        std::string&amp; s, <b>unsigned</b> <b>int</b> flags =
        match_default);</td>
<!--        <td valign="top" width="42%">Finds all matches of the
        current expression in the text <i>s</i> using the match
        flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match pushes a copy of what matched onto <i>v</i>.
        Returns the number of matches found.</td>-->
        <td valign="top" width="42%">マッチフラグ <i>flags</i> を使って、
	テキスト <i>s</i> の中にある、現在の正規表現との一致を全て発見する。
        <a href="template_class_ref.htm#match_type">match flags</a>を見よ。
	それぞれの一致のたびに、一致したもののコピーが <i>v</i> に送られる。
	発見された一致の数を返す。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Grep(std::vector&lt;<b>unsigned int</b>&gt;&amp; v, <b>const</b>
        <b>char</b>* p, <b>unsigned</b> <b>int</b> flags =
        match_default);</td>
<!--        <td valign="top" width="42%">Finds all matches of the
        current expression in the text <i>p</i> using the match
        flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match pushes the starting index of what matched
        onto <i>v</i>. Returns the number of matches found.</td>-->
        <td valign="top" width="42%">マッチフラグ <i>flags</i> を使って、
	テキスト <i>p</i> の中にある、現在の正規表現との一致を全て発見する。
        <a href="template_class_ref.htm#match_type">match flags</a>を見よ。
	それぞれの一致のたびに、一致したものの開始インデックスが <i>v</i>
	に送られる。発見された一致の数を返す。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Grep(std::vector&lt;<b>unsigned int</b>&gt;&amp; v, <b>const</b>
        std::string&amp; s, <b>unsigned</b> <b>int</b> flags =
        match_default);</td>
<!--        <td valign="top" width="42%">Finds all matches of the
        current expression in the text <i>s</i> using the match
        flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match pushes the starting index of what matched
        onto <i>v</i>. Returns the number of matches found.</td>-->
        <td valign="top" width="42%">マッチフラグ <i>flags</i> を使って、
	テキスト <i>s</i> の中にある、現在の正規表現との一致を全て発見する。
        <a href="template_class_ref.htm#match_type">match flags</a>を見よ。
	それぞれの一致のたびに、一致したものの開始インデックスが <i>v</i>
	に送られる。発見された一致の数を返す。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        GrepFiles(GrepFileCallback cb, <b>const</b> <b>char</b>*
        files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b>
        <b>int</b> flags = match_default);</td>
<!--        <td valign="top" width="42%">Finds all matches of the
        current expression in the files <i>files</i> using the
        match flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match calls the call-back function cb.&nbsp; <p>If
        the call-back returns false then the algorithm returns
        without considering further matches in the current file,
        or any further files.&nbsp; </p>
        <p>The parameter <i>files</i> can include wild card
        characters '*' and '?', if the parameter <i>recurse</i>
        is true then searches sub-directories for matching file
        names.&nbsp; </p>
        <p>Returns the total number of matches found.</p>
        <p>May throw an exception derived from std::runtime_error
        if file io fails.</p>
        </td>-->
        <td valign="top" width="42%">マッチフラグ <i>flags</i> を使って、
	ファイル <i>files</i> の中にある、現在の正規表現との一致を全て発見する。
        <a href="template_class_ref.htm#match_type">match flags</a>を見よ。
	それぞれの一致が発見されるたびに、コールバック関数 <i>cb</i> が呼ばれる。
	<p>コールバック関数が false を返せば、アルゴリズムは現在のファイル、
	ほかのファイルの中のそれ以降の一致を発見しないで終了する。&nbsp; </p>
	<p>引数 <i>files</i> はワイルドカード文字 '*' と '?' を含むことが出来る。
	もし引数 <i>recurse</i> が true なら、
	一致するファイル名のサブディレクトリも検索する。&nbsp; </p>
        <p>発見された一致の総数を返す。</p>
        <p>ファイル入出力が失敗すれば、 std::runtime_error から派生した
	例外が投げられるだろう。</p>
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        GrepFiles(GrepFileCallback cb, <b>const</b> std::string&amp;
        files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b>
        <b>int</b> flags = match_default);</td>
<!--        <td valign="top" width="42%">Finds all matches of the
        current expression in the files <i>files</i> using the
        match flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match calls the call-back function cb.&nbsp; <p>If
        the call-back returns false then the algorithm returns
        without considering further matches in the current file,
        or any further files.&nbsp; </p>
        <p>The parameter <i>files</i> can include wild card
        characters '*' and '?', if the parameter <i>recurse</i>
        is true then searches sub-directories for matching file
        names.&nbsp; </p>
        <p>Returns the total number of matches found.</p>
        <p>May throw an exception derived from std::runtime_error
        if file io fails.</p>
        </td>-->
        <td valign="top" width="42%">マッチフラグ <i>flags</i> を使って、
	ファイル <i>files</i> の中にある、現在の正規表現との一致を全て発見する。
        <a href="template_class_ref.htm#match_type">match flags</a>を見よ。
	それぞれの一致が発見されるたびに、コールバック関数 <i>cb</i> が呼ばれる。
	<p>コールバック関数が false を返せば、アルゴリズムは現在のファイル、
	ほかのファイルの中のそれ以降の一致を発見しないで終了する。&nbsp; </p>
	<p>引数 <i>files</i> はワイルドカード文字 '*' と '?' を含むことが出来る。
	もし引数 <i>recurse</i> が true なら、
	一致するファイル名のサブディレクトリも検索する。&nbsp; </p>
        <p>発見された一致の総数を返す。</p>
        <p>ファイル入出力が失敗すれば、 std::runtime_error から派生した
	例外が投げられるだろう。</p>
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        FindFiles(FindFilesCallback cb, <b>const</b> <b>char</b>*
        files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b>
        <b>int</b> flags = match_default);</td>
<!--        <td valign="top" width="42%">Searches <i>files</i> to
        find all those which contain at least one match of the
        current expression using the match flags <i>flags </i>-
        see <a href="template_class_ref.htm#match_type">match
        flags</a>. For each matching file calls the call-back
        function cb.&nbsp; <p>If the call-back returns false then
        the algorithm returns without considering any further
        files.&nbsp; </p>
        <p>The parameter <i>files</i> can include wild card
        characters '*' and '?', if the parameter <i>recurse</i>
        is true then searches sub-directories for matching file
        names.&nbsp; </p>
        <p>Returns the total number of files found.</p>
        <p>May throw an exception derived from std::runtime_error
        if file io fails.</p>
        </td>-->
        <td valign="top" width="42%">マッチフラグ <i>flags</i> を使って、
	<i>files</i> を検索し、現在の正規表現と少なくとも一つの一致を持つ
	全てのファイルを発見する。
        <a href="template_class_ref.htm#match_type">match flags</a>を見よ。
	それぞれの一致が発見されるたびに、コールバック関数 <i>cb</i> が呼ばれる。
	<p>コールバック関数が false を返せば、
	アルゴリズムはそれ以降のファイルを考慮せずに終了する。&nbsp; </p>
	<p>引数 <i>files</i> はワイルドカード文字 '*' と '?' を含むことが出来る。
	もし引数 <i>recurse</i> が true なら、
	一致するファイル名のサブディレクトリも検索する。&nbsp; </p>
        <p>発見されたファイルの総数を返す。</p>
        <p>ファイル入出力が失敗すれば、 std::runtime_error から派生した
	例外が投げられるだろう。</p>
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        FindFiles(FindFilesCallback cb, <b>const</b> std::string&amp;
        files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b>
        <b>int</b> flags = match_default);</td>
<!--        <td valign="top" width="42%">Searches <i>files</i> to
        find all those which contain at least one match of the
        current expression using the match flags <i>flags </i>-
        see <a href="template_class_ref.htm#match_type">match
        flags</a>. For each matching file calls the call-back
        function cb.&nbsp; <p>If the call-back returns false then
        the algorithm returns without considering any further
        files.&nbsp; </p>
        <p>The parameter <i>files</i> can include wild card
        characters '*' and '?', if the parameter <i>recurse</i>
        is true then searches sub-directories for matching file
        names.&nbsp; </p>
        <p>Returns the total number of files found.</p>
        <p>May throw an exception derived from std::runtime_error
        if file io fails.</p>
        </td>-->
        <td valign="top" width="42%">マッチフラグ <i>flags</i> を使って、
	<i>files</i> を検索し、現在の正規表現と少なくとも一つの一致を持つ
	全てのファイルを発見する。
        <a href="template_class_ref.htm#match_type">match flags</a>を見よ。
	それぞれの一致が発見されるたびに、コールバック関数 <i>cb</i> が呼ばれる。
	<p>コールバック関数が false を返せば、
	アルゴリズムはそれ以降のファイルを考慮せずに終了する。&nbsp; </p>
	<p>引数 <i>files</i> はワイルドカード文字 '*' と '?' を含むことが出来る。
	もし引数 <i>recurse</i> が true なら、
	一致するファイル名のサブディレクトリも検索する。&nbsp; </p>
        <p>発見されたファイルの総数を返す。</p>
        <p>ファイル入出力が失敗すれば、 std::runtime_error から派生した
	例外が投げられるだろう。</p>
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">std::string Merge(<b>const</b>
        std::string&amp; in, <b>const</b> std::string&amp; fmt, <b>bool</b>
        copy = <b>true</b>, <b>unsigned</b> <b>int</b> flags =
        match_default);</td>
<!--        <td valign="top" width="42%">Performs a search and
        replace operation: searches through the string <i>in</i>
        for all occurrences of the current expression, for each
        occurrence replaces the match with the format string <i>fmt</i>.
        Uses <i>flags</i> to determine what gets matched, and how
        the format string should be treated. If <i>copy</i> is
        true then all unmatched sections of input are copied
        unchanged to output, if the flag <em>format_first_only</em>
        is set then only the first occurance of the pattern found
        is replaced. Returns the new string. See <a
        href="format_string.htm#format_string">also format string
        syntax</a>, <a href="template_class_ref.htm#match_type">match
        flags</a> and <a
        href="template_class_ref.htm#format_flags">format flags</a>.</td>-->
        <td valign="top" width="42%">検索と置換の操作を行う:
	文字列 <i>in</i> を最初から最後まで検索し現在の正規表現との一致を全て発見する。
	一致のたびに、書式文字列 <i>fmt</i> で置換を行う。
	何が一致するか、書式文字列がどう扱われるかを決定するために <i>flags</i> を利用する。
	もし <i>copy</i> が true なら入力のうち全ての一致しなかった部分が、
	変更されることなく出力にコピーされる。
	もしフラグ <em>format_first_only</em> が設定されていれば、
	発見された最初のパターンだけが置換される。
	新しい文字列を返す。
        <a href="format_string.htm#format_string">書式文字列構文</a>,
	<a href="template_class_ref.htm#match_type">match flags</a>,
	<a href="template_class_ref.htm#format_flags">format flags</a>
	も参考にせよ。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">std::string Merge(<b>const</b>
        char* in, <b>const</b> char* fmt, <b>bool</b> copy = <b>true</b>,
        <b>unsigned int </b>flags = match_default);</td>
<!--        <td valign="top" width="42%">Performs a search and
        replace operation: searches through the string <i>in</i>
        for all occurrences of the current expression, for each
        occurrence replaces the match with the format string <i>fmt</i>.
        Uses <i>flags</i> to determine what gets matched, and how
        the format string should be treated. If <i>copy</i> is
        true then all unmatched sections of input are copied
        unchanged to output, if the flag <em>format_first_only</em>
        is set then only the first occurance of the pattern found
        is replaced. Returns the new string. See <a
        href="format_string.htm#format_string">also format string
        syntax</a>, <a href="template_class_ref.htm#match_type">match
        flags</a> and <a
        href="template_class_ref.htm#format_flags">format flags</a>.</td>-->
        <td valign="top" width="42%">検索と置換の操作を行う:
	文字列 <i>in</i> を最初から最後まで検索し現在の正規表現との一致を全て発見する。
	一致のたびに、書式文字列 <i>fmt</i> で置換を行う。
	何が一致するか、書式文字列がどう扱われるかを決定するために <i>flags</i> を利用する。
	もし <i>copy</i> が true なら入力のうち全ての一致しなかった部分が、
	変更されることなく出力にコピーされる。
	もしフラグ <em>format_first_only</em> が設定されていれば、
	発見された最初のパターンだけが置換される。
	新しい文字列を返す。
        <a href="format_string.htm#format_string">書式文字列構文</a>,
	<a href="template_class_ref.htm#match_type">match flags</a>,
	<a href="template_class_ref.htm#format_flags">format flags</a>
	も参考にせよ。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td valign="top"><b>unsigned</b> Split(std::vector&lt;std::string&gt;&amp;
        v, std::string&amp; s, <b>unsigned</b> flags =
        match_default, <b>unsigned</b> max_count = ~0);</td>
<!--        <td valign="top">Splits the input string and pushes each
        one onto the vector. If the expression contains no marked
        sub-expressions, then one string is outputted for each
        section of the input that does not match the expression.
        If the expression does contain marked sub-expressions,
        then outputs one string for each marked sub-expression
        each time a match occurs. Outputs no more than <i>max_count
        </i>strings. Before returning, deletes from the input
        string <i>s</i> all of the input that has been processed
        (all of the string if <i>max_count</i> was not reached).
        Returns the number of strings pushed onto the vector.</td>-->
        <td valign="top">入力文字列を分割し、vector に送る。
	もし正規表現が印付けされた子表現(訳注: 印付けされた子表現 <i>marked-expression</i>
	とは、正規表現中の <i>()</i> で囲まれたものであり、かつ <i>(?</i> で始まらないものである。)
	を含んでいなければ、
	正規表現に一致しなかった入力のそれぞれの部分につき一つの文字列が出力される。
	もし正規表現が印付けされた子表現を含んでいれば、
	それぞれの一致で印付けされた子表現につき一つの文字列が出力される。
	<i>max_count</i> 以上の文字列は出力されない。
	この関数から戻る前に、入力文字列 <i>s</i> から、処理された全ての入力を削除する
	(もし <i>max_count</i> に達しなければ、文字列全て)。
	vector に送られた文字列の数を返す。</td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Position(<b>int</b> i = 0)<b>const</b>;</td>
<!--        <td valign="top" width="42%">Returns the position of what
        matched sub-expression <i>i</i>. If <i>i = 0</i> then
        returns the position of the whole match. Returns RegEx::npos
        if the supplied index is invalid, or if the specified sub-expression
        did not participate in the match.</td>-->
        <td valign="top" width="42%"><i>i</i> 番目の子表現が一致したものの位置を返す。
	もし <i>i = 0</i> なら、全体の一致の位置を返す。
	もし与えられたインデックスが無効なら、
	または指定された子表現が一致していなかったら、 RegEx::npos を返す。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Length(<b>int</b> i = 0)<b>const</b>;</td>
<!--        <td valign="top" width="42%">Returns the length of what
        matched sub-expression <i>i</i>. If <i>i = 0</i> then
        returns the length of the whole match. Returns RegEx::npos
        if the supplied index is invalid, or if the specified sub-expression
        did not participate in the match.</td>-->
        <td valign="top" width="42%"><i>i</i> 番目の子表現と一致したものの長さを返す。
	もし <i>i = 0</i> なら全体の一致の長さを返す。
	もし <i>i = 0</i> なら、全体の一致の位置を返す。
	もし与えられたインデックスが無効なら、
	または指定された子表現が一致していなかったら、 RegEX::npos を返す。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td><strong>bool</strong> Matched(<strong>int</strong> i
        = 0)<strong>const</strong>;</td>
<!--        <td>Returns true if sub-expression <em>i</em> was
        matched, false otherwise.</td>-->
        <td><em>i</em> 番目の子表現が一致していたら true を、
	そうでなければ false を返す。</td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Line()<b>const</b>;</td>
<!--        <td valign="top" width="42%">Returns the line on which
        the match occurred, indexes start from 1 not zero, if no
        match occurred then returns RegEx::npos.</td>-->
        <td valign="top" width="42%">一致があった行番号を返す。
	番号は 0 でなく 1 で始まる。
	一致がなければ、 RegEx::npos を返す。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned int</b> Marks()
        const;</td>
<!--        <td valign="top" width="42%">Returns the number of marked
        sub-expressions contained in the expression. Note that
        this includes the whole match (sub-expression zero), so
        the value returned is always &gt;= 1.</td>-->
        <td valign="top" width="42%">正規表現に含まれる、印付けされた子表現の数を返す。
	これはマッチ全体(子表現ゼロ)も含むことに注意すること。
	つまり、戻り値は常に &gt;= 1 である。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">std::string What(<b>int</b>
        i)<b>const</b>;</td>
<!--        <td valign="top" width="42%">Returns a copy of what
        matched sub-expression <i>i</i>. If <i>i = 0</i> then
        returns a copy of the whole match. Returns a null string
        if the index is invalid or if the specified sub-expression
        did not participate in a match.</td>-->
        <td valign="top" width="42%"><i>i</i> 番目の子表現に一致したもののコピーを返す。
	もし <i>i = 0</i> なら全体の一致のコピーを返す。
	インデックスが無効であったり、指定された子表現が一致していなかったら、
	null 文字列を返す。</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">std::string <b>operator</b>[](<b>int</b>
        i)<b>const</b> ;</td>
<!--        <td valign="top" width="42%">Returns <i>what(i);</i> <p>Can
        be used to simplify access to sub-expression matches, and
        make usage more perl-like.</p>-->
        <td valign="top" width="42%"><i>what(i);</i> を返す。
	<p>子表現の一致への簡単なアクセスに使うことが出来て、
	perl-like な利用法を可能にする。</td>
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
</table>

<hr>

<p><i>Copyright </i><a href="mailto:John_Maddock@compuserve.com"><i>Dr
John Maddock</i></a><i> 1998-2000 all rights reserved.</i> </p>
<hr align="left">
<p><i>Japanese Translation Copyright (C) 2003 <a href="mailto:k_takahashi@cppll.jp">Kohske Takahashi</a></i></p>
<p>
オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の
複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」
に提供されており、いかなる明示的、暗黙的保証も行わない。また、
いかなる目的に対しても、その利用が適していることを関知しない。
</p>

</body>
</html>
