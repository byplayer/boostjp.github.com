<html>
<head>
<!--<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">-->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="Template"
content="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Regex++, template class and algorithm reference</title>
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">

<p>&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top"><h3 align="right"><img
        src="../../c++boost.gif" alt="C++ Boost" width="276"
        height="86"></h3>
        </td>
        <td valign="top"><h3 align="center"><i>Regex++ template
        class reference.</i></h3>
        <p align="left"><i>Copyright (c) 1998-2001 </i></p>
        <p align="left"><i>Dr John Maddock</i></p>
        <p align="left"><i>Permission to use, copy, modify,
        distribute and sell this software and its documentation
        for any purpose is hereby granted without fee, provided
        that the above copyright notice appear in all copies and
        that both that copyright notice and this permission
        notice appear in supporting documentation. Dr John
        Maddock makes no representations about the suitability of
        this software for any purpose. It is provided &quot;as is&quot;
        without express or implied warranty.</i></p>
        </td>
    </tr>
</table>

<hr>

<h3><a name="regbase"></a>class regbase</h3>

<p>#include &lt;<a href="../../boost/regex.hpp">boost/regex.hpp</a>&gt;
</p>

<!--<p>Class regbase is the template argument independent base class
for reg_expression, the only public members are the <i>flag_type</i>
enumerated values that determine how regular expressions are
interpreted. </p>-->
<p>regbaseクラスはreg_expressionのためのテンプレート引数に依存しない基底クラスである。
唯一の公開メンバは 列挙型の値 <i>flag_type</i> であり、これは正規表現がどのように解釈
されるかを決定する</p>

<pre><b>class</b> regbase
{
<b>public</b>:
&nbsp;&nbsp; <b>enum</b> flag_type_
&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; escape_in_lists = 1,&nbsp;                         <font
color="#000080">// '\\' special inside [...] 
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char_classes = escape_in_lists &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
color="#000080"><i>// [[:CLASS:]] allowed 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; intervals = char_classes &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
color="#000080"><i>// {x,y} allowed 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; limited_ops = intervals &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
color="#000080"><i>// all of + ? and | are normal characters 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newline_alt = limited_ops &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
color="#000080"><i>// \n is the same as | 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bk_plus_qm = newline_alt &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
color="#000080"><i>// uses \+ and \? 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bk_braces = bk_plus_qm &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
color="#000080"><i>// uses \{ and \} 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bk_parens = bk_braces &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
color="#000080"><i>// uses \( and \) 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bk_refs = bk_parens &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
color="#000080"><i>// \d allowed 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bk_vbar = bk_refs &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
color="#000080"><i>// uses \| 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use_except = bk_vbar &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
color="#000080"><i>// exception on error 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; failbit = use_except &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
color="#000080"><i>// error flag 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; literal = failbit &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
color="#000080"><i>// all characters are literals 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; icase = literal &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
color="#000080"><i>// characters are matched regardless of case 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nocollate = icase &lt;&lt; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font
color="#000080"><i>// don't use locale specific collation 
</i></font>
      basic = char_classes | intervals | limited_ops | bk_braces | bk_parens | bk_refs,
      extended = char_classes | intervals | bk_refs,
      normal = escape_in_lists | char_classes | intervals | bk_refs | nocollate,
      emacs = bk_braces | bk_parens | bk_refs | bk_vbar,
      awk = extended | escape_in_lists,
      grep = basic | newline_alt,
      egrep = extended | newline_alt,
      sed = basic,
      perl = normal
   }; 
   <b>typedef</b> <b>unsigned</b> <b>int</b> flag_type;
}; &nbsp; </pre>

<p>&nbsp; <br>
&nbsp; <br>
&nbsp; </p>

<!--<p>The enumerated type <i>regbase::flag_type</i> determines the
syntax rules for regular expression compilation, the various
flags have the following effects: <br>
&nbsp; </p>-->
<p>列挙型 <i>regbase::flag_type</i> は正規表現のコンパイルのための構文規則を決定する。
それぞれのフラグは以下のような作用を持つ: <br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase::escape_in_lists</td>
<!--        <td valign="top" width="45%">Allows the use of the escape
        &quot;\&quot; character in sets of characters, for
        example [\]] represents the set of characters containing
        only &quot;]&quot;. If this flag is not set then &quot;\&quot;
        is an ordinary character inside sets.</td>
        <td width="5%">&nbsp;</td>-->
	<td valign="top" width="45%">文字集合の中で &quot;\&quot; を使うことを認める。
	文字集合の中の文字、例えば [\]] は &quot;]&quot のみを含む文字集合を表している。
	もしこのフラグが設定されていなければ、
	&quot;\&quot; は文字集合の中では通常の文字として扱われる。</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase::char_classes</td>
<!--        <td valign="top" width="45%">When this bit is set,
        character classes [:classname:] are allowed inside
        character set declarations, for example &quot;[[:word:]]&quot;
        represents the set of all characters that belong to the
        character class &quot;word&quot;.</td>
        <td width="5%">&nbsp;</td>-->
        <td valign="top" width="45%">このビットが設定されているとき、
        文字クラス [:クラス名:] を文字集合宣言の中 で使うことを認める。
        例えば [[:word:]] は文字クラス &quot;word&quot;に属する全ての文字の
        集合を表している。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase:: intervals</td>
<!--        <td valign="top" width="45%">When this bit is set,
        repetition intervals are allowed, for example &quot;a{2,4}&quot;
        represents a repeat of between 2 and 4 letter a's.</td>-->
        <td valign="top" width="45%">このビットが設定されているとき、
        繰り返し回数の範囲指定を使うことを認める。
	例えば &quot;a{2,4}&quot; は文字 a が2回以上4回以下繰り返されることを表している。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase:: limited_ops</td>
<!--        <td valign="top" width="45%">When this bit is set all of
        &quot;+&quot;, &quot;?&quot; and &quot;|&quot; are
        ordinary characters in all situations.</td>-->
        <td valign="top" width="45%">このビットが設定されているとき、
        &quot;+&quot;、 &quot;?&quot; そして &quot;|&quot; はあらゆる状況で
        通常の文字として扱われる。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase:: newline_alt</td>
<!--        <td valign="top" width="45%">When this bit is set, then
        the newline character &quot;\n&quot; has the same effect
        as the alternation operator &quot;|&quot;.</td>-->
        <td valign="top" width="45%">このビットが設定されているとき、
        改行文字 &quot;\n&quot; は排他演算子 &quot;|&quot;と同じ作用を持つ。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase:: bk_plus_qm</td>
<!--        <td valign="top" width="45%">When this bit is set then
        &quot;\+&quot; represents the one or more repetition
        operator and &quot;\?&quot; represents the zero or one
        repetition operator. When this bit is not set then
        &quot;+&quot; and &quot;?&quot; are used instead.</td>-->
        <td valign="top" width="45%">このビットが設定されているとき、
        &quot;\+&quot; は1回以上の繰り返しを表す。そして
        &quot;\?&quot; は0回か1回の繰り返しを表す。
        このビットが設定されていないときは、代わりに
        &quot;+&quot; と &quot;?&quot; が使われる。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase:: bk_braces</td>
<!--        <td valign="top" width="45%">When this bit is set then
        &quot;\{&quot; and &quot;\}&quot; are used for bounded
        repetitions and &quot;{&quot; and &quot;}&quot; are
        normal characters. This is the opposite of default
        behavior.</td>-->
        <td valign="top" width="45%">このビットが設定されているとき、
        &quot;\{&quot; と &quot;\}&quot; が繰り返しの回数指定に使われ、
        &quot;{&quot; と &quot;}&quot; は通常の文字として扱われる。
        これはデフォルトとは反対の動作である。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase:: bk_parens</td>
<!--        <td valign="top" width="45%">When this bit is set then
        &quot;\(&quot; and &quot;\)&quot; are used to group sub-expressions
        and &quot;(&quot; and &quot;)&quot; are ordinary
        characters, this is the opposite of default behaviour.</td>-->
        <td valign="top" width="45%">このビットが設定されているとき、
        &quot;\(&quot; と &quot;\)&quot; が子表現のグループ化に使われ、
        &quot;(&quot; と &quot;)&quot; は通常の文字として扱われる。
        これはデフォルトとは反対の動作である。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase:: bk_refs</td>
<!--        <td valign="top" width="45%">When this bit is set then
        back references are allowed.</td>-->
        <td valign="top" width="45%">このビットが設定されているとき、
        後方参照が許される。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase:: bk_vbar</td>
<!--        <td valign="top" width="45%">When this bit is set then
        &quot;\|&quot; represents the alternation operator and
        &quot;|&quot; is an ordinary character. This is the
        opposite of default behaviour.</td>-->
        <td valign="top" width="45%">このビットが設定されているとき、
        &quot;\|&quot; が排他演算子を表し、
        &quot;|&quot; は通常の文字として扱われる。
        これはデフォルトとは反対の動作である。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase:: use_except</td>
<!--        <td valign="top" width="45%">When this bit is set then a <a
        href="#bad_expression">bad_expression</a> exception will
        be thrown on error.&nbsp; Use of this flag is deprecated
        - reg_expression will always throw on error.</td>-->
        <td valign="top" width="45%">このビットが設定されているとき、
	<a href="#bad_expression">bad_expression</a> 例外がエラー時に発生する。
        このフラグを使うことは賛成されない。なぜなら reg_expression はエラーの際、
	常に例外を発生させるだろう。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase:: failbit</td>
<!--        <td valign="top" width="45%">This bit is set on error, if
        regbase::use_except is not set, then this bit should be
        checked to see if a regular expression is valid before
        usage.</td>-->
        <td valign="top" width="45%">もし regbase::use_except が設定されていなければ、
	エラー時にこのビットが設定される。使う前に、正規表現が妥当かどうかを見るために
	このビットをチェックすべきである。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase::literal</td>
<!--        <td valign="top" width="45%">All characters in the string
        are treated as literals, there are no special characters
        or escape sequences.</td>-->
        <td valign="top" width="45%">文字列中の全ての文字はリテラルとして扱われる。
	特殊文字や、エスケープシーケンスは存在しない。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase::icase</td>
<!--        <td valign="top" width="45%">All characters in the string
        are matched regardless of case.</td>-->
        <td valign="top" width="45%">文字列中の全ての文字は、大文字/小文字の区別なく一致する。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase::nocollate</td>
<!--        <td valign="top" width="45%">Locale specific collation is
        disabled when dealing with ranges in character set
        declarations.&nbsp; For example when this bit is set the
        expression [a-c] would match the characters a, b and c
        only regardless of locale, where as when this is not set
        , then [a-c] matches any character which collates in the
        range a to c.</td>-->
        <td valign="top" width="45%">文字集合宣言の中で、文字範囲を扱うときに、
	ロケールに特殊な一致は不可能になる。
        例えば、このビットが設定されているとき、 [a-c] という表現は a, b そして c という文字に
	ロケールにかかわらず一致する。このビットが設定されていなければ、 [a-c] は
	a から c の並びにあるどんな文字にも一致する。</td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="5%">&nbsp;</td>
        <td valign="top" width="45%">regbase::basic</td>
<!--        <td valign="top" width="45%">Equivalent to the POSIX
        basic regular expression syntax: char_classes | intervals
        | limited_ops | bk_braces | bk_parens | bk_refs.</td>-->
        <td valign="top" width="45%">POSIX の基本正規表現構文との互換性をもつ:
	つまり、char_classes | intervals | limited_ops | bk_braces | bk_parens | bk_refs
	のビットを設定する。</td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="5%">&nbsp;</td>
        <td valign="top" width="45%">Regbase::extended</td>
<!--        <td valign="top" width="45%">Equivalent to the POSIX
        extended regular expression syntax: char_classes |
        intervals | bk_refs.</td>-->
        <td valign="top" width="45%">POSIX の拡張正規表現構文との互換性をもつ:
        つまり、 char_classes | intervals | bk_refs のビットを設定する。</td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="5%" height="24">&nbsp;</td>
        <td valign="top" width="45%" height="24">regbase::normal</td>
<!--        <td valign="top" width="45%" height="24">This is the
        default setting, and represents how most people expect
        the library to behave. Equivalent to the POSIX extended
        syntax, but with locale specific collation disabled, and
        escape characters inside set declarations enabled:
        regbase::escape_in_lists | regbase::char_classes |
        regbase::intervals | regbase::bk_refs | regbase::nocollate.</td>-->
        <td valign="top" width="45%" height="24">これはデフォルトの設定である。
        そして多くの人が、ライブラリがこのように動作することを期待している。
	POSIX 拡張構文との互換性をもつが、ロケールに特殊な一致ない。
	そして文字集合宣言の中でのエスケープ文字を使うことが出来る。
        これは regbase::escape_in_lists | regbase::char_classes |
        regbase::intervals | regbase::bk_refs | regbase::nocollate のビットを設定する。</td>
        <td valign="top" width="5%" height="24">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="5%" height="24">&nbsp;</td>
        <td valign="top" width="45%" height="24">regbase::emacs</td>
<!--        <td valign="top" width="45%" height="24">Provides
        compatability with the emacs editor, eqivalent to:
        bk_braces | bk_parens | bk_refs | bk_vbar.</td>-->
        <td valign="top" width="45%" height="24">emacs エディタとの互換性を与える。
        bk_braces | bk_parens | bk_refs | bk_vbar と等価である。</td>
        <td valign="top" width="5%" height="24">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="5%" height="24">&nbsp;</td>
        <td valign="top" width="45%" height="24">regbase::awk </td>
<!--        <td valign="top" width="45%" height="24">Provides
        compatabilty with the Unix utility Awk, the same as POSIX
        extended regular expressions, but allows escapes inside
        bracket-expressions (character sets). Equivalent to
        extended | escape_in_lists.</td>-->
        <td valign="top" width="45%" height="24">Unix のユーティリティ Awk との互換性を与える。
        POSIX 拡張正規表現と同じだが、文字集合の中にエスケープを許す。
        extended | escape_in_lists と等価である。</td>
        <td valign="top" width="5%" height="24">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="5%" height="24">&nbsp;</td>
        <td valign="top" width="45%" height="24">regbase::grep</td>
<!--        <td valign="top" width="45%" height="24">Provides
        compatabilty with the Unix grep utility, the same as
        POSIX basic regular expressions, but with the newline
        character equivalent to the alternation operator. the
        same as basic | newline_alt.</td>-->
        <td valign="top" width="45%" height="24">Unix の grep ユーティリティとの互換性を与える。
        POSIX 基本正規表現と同じだが、改行文字と排他演算子は等価である。
        つまり、 basic | newline_alt と同じである。</td>
        <td valign="top" width="5%" height="24">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="5%" height="24">&nbsp;</td>
        <td valign="top" width="45%" height="24">regbase::egrep</td>
<!--        <td valign="top" width="45%" height="24">Provides
        compatabilty with the Unix egrep utility, the same as
        POSIX extended regular expressions, but with the newline
        character equivalent to the alternation operator. the
        same as extended | newline_alt.</td>-->
        <td valign="top" width="45%" height="24">Unix の egrep ユーティリティとの互換性を与える。
        POSIX 拡張正規表現と同じだが、改行文字と排他演算子は等価である。
	つまり、 extended | newline_alt と同じである。</td>
        <td valign="top" width="5%" height="24">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="5%" height="24">&nbsp;</td>
        <td valign="top" width="45%" height="24">regbase::sed</td>
<!--        <td valign="top" width="45%" height="24">Provides
        compatabilty with the Unix sed utility, the same as POSIX
        basic regular expressions.</td>-->
        <td valign="top" width="45%" height="24">Unix の sed ユーティリティとの互換性を与える。
	POSIX 基本正規表現と同じである。</td>
        <td valign="top" width="5%" height="24">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="5%" height="24">&nbsp;</td>
        <td valign="top" width="45%" height="24">regbase::perl</td>
<!--        <td valign="top" width="45%" height="24">Provides
        compatibility with the perl programming language, the
        same as regbase::normal.</td>-->
        <td valign="top" width="45%" height="24">プログラミング言語 perl との互換性を与える。
        regbase::normal と同じである。</td>
        <td valign="top" width="5%" height="24">&nbsp;</td>
    </tr>
</table>

<hr>

<h3><a name="bad_expression"></a>Exception classes.</h3>

<p>#include &lt;<a href="../../boost/regex/pattern_except.hpp">boost/pat_except.hpp</a>&gt;
</p>

<!--<p>An instance of <i>bad_expression</i> is thrown whenever a bad
regular expression is encountered. </p>-->
<p>誤った正規表現が現れたときにいつでも、<i>bad_expression</i> のインスタンスが投げられる。</p>

<pre><b>namespace</b> boost{

<b>class</b> bad_pattern : <b>public</b> std::runtime_error
{
<b>public</b>:
&nbsp;&nbsp; <b>explicit</b> bad_pattern(<b>const</b> std::string&amp; s) : std::runtime_error(s){};
};

<b>class</b> bad_expression : <b>public</b> bad_pattern
{
<b>public</b>:
&nbsp;&nbsp; bad_expression(<b>const</b> std::string&amp; s) : bad_pattern(s) {}
};


} // namespace boost</pre>

<!--<p>Footnotes: the class <i>bad_pattern </i>forms the base class
for all pattern-matching exceptions, of which <i>bad_expression</i>
is one. The choice of <i>std::runtime_error </i>as the base class
for <i>bad_pattern</i> is moot, depending upon how the library is
used exceptions may be either logic errors (programmer supplied
expressions) or run time errors (user supplied expressions). </p>-->

<p>補足: <i>bad_pattern </i>クラスは全てのパターンマッチングでの例外の
基底クラスであり、 <i>bad_expression</i> はそのひとつである。
<i>bad_pattern</i> の基底クラスとして <i>std::runtime_error </i> を選択していることには議論の余地がある。
ライブラリがどう使われるかよるが、例外は論理的エラー(プログラマが与えた正規表現)か、
実行時エラー(ユーザが与えた正規表現)のいずれかだろう。</p>

<hr>

<h3><a name="reg_expression"></a>Class reg_expression</h3>

<p>#include &lt;<a href="../../boost/regex.hpp">boost/regex.hpp</a>&gt;
</p>

<!--<p>The template class <i>reg_expression </i>encapsulates regular
expression parsing and compilation. The class derives from class <a
href="#regbase"><i>regbase</i></a> and takes three template
parameters: </p>-->
<p>テンプレートクラス <i>reg_expression</i> は正規表現の解釈とコンパイルをカプセル化している。
このクラスは <a href="#regbase"><i>regbase</i></a> を継承していて、3つのテンプレートパラメータを持つ。
パラメータは: </p>

<!--<p><b><i>charT</i></b>: determines the character type, i.e.
either char or wchar_t. </p>-->
<p><b><i>charT</i></b>: 文字型を決定する。 つまり、 char か wchar_t のどちらかである。</p>

<!--<p><b><i>traits</i></b>: determines the behaviour of the
character type, for example whether character matching is case
sensitive or not, and which character class names are recognized.
A default traits class is provided: <a href="#regex_char_traits">regex_traits&lt;charT&gt;</a>.
</p>-->
<p><b><i>traits</i></b>: 文字型の振る舞いを決定する。例えば、
大文字小文字を考慮して照合するか、文字クラス名を認識するか、などである。
デフォルトの traits クラスが与えられている: <a href="#regex_char_traits">regex_traits&lt;charT&gt;</a> 。</p>

<!--<p><b><i>Allocator</i></b>: the allocator class used to allocate
memory by the class. </p>-->
<p><b><i>Allocator</i></b>: allocator クラスは、メモリ割り当てに使われるクラスである。</p>

<!--<p>For ease of use there are two typedefs that define the two
standard <i>reg_expression</i> instances, unless you want to use
custom allocators, you won't need to use anything other than
these: </p>-->
<p>簡単に使えるように、2つの標準的な <i>reg_expression</i> のインスタンスを定義した、
2つの typedef がある。
カスタムのアロケータクラスを使いたいのでなければ、これら以外のものを使う必要はないだろう。</p>

<pre><b>namespace</b> boost{
<b>template</b> &lt;<b>class</b> charT, <b>class</b> traits = regex_traits&lt;charT&gt;, <b>class</b> Allocator = std::allocator&lt;charT&gt;&nbsp; &gt;
<b>class</b> reg_expression;
<b>typedef</b> reg_expression&lt;<b>char</b>&gt; regex;
<b>typedef</b> reg_expression&lt;<b>wchar_t&gt; </b>wregex;
}</pre>

<!--<p>The definition of <i>reg_expression</i> follows: it is based
very closely on class basic_string, and fulfils the requirements
for a container of <i>charT</i>. </p>-->
<p><i>reg_expression</i> の定義は次の通りである: 
この定義は basic_string クラスに厳密に基づいていて、<i>charT</i> のコンテナとしての要求を満たしている。</p>

<pre><b>namespace</b> boost{
<b>template</b> &lt;<b>class</b> charT, <b>class</b> traits = regex_traits&lt;charT&gt;, <b>class</b> Allocator = std::allocator&lt;charT&gt;&nbsp; &gt;
<b>class</b> reg_expression : <b>public</b> regbase
{
<b>public</b>: 
<font color="#000080"><i>   // typedefs: </i></font>&nbsp;
&nbsp; <b> typedef</b> charT char_type; 
&nbsp;&nbsp; <b>typedef</b> traits traits_type; 
<font color="#000080">&nbsp;&nbsp; <i>// locale_type 
</i>&nbsp;&nbsp; <i>// placeholder for actual locale type used by the 
</i>&nbsp;&nbsp; <i>// traits class to localise *this. 
</i></font>&nbsp;&nbsp; <b>typedef</b> typename traits::locale_type locale_type; 
<font color="#000080">&nbsp;&nbsp; <i>// value_type 
</i></font>&nbsp;&nbsp; <b>typedef</b> charT value_type; 
<font color="#000080">&nbsp;&nbsp; <i>// reference, const_reference 
</i></font>&nbsp;&nbsp; <b>typedef</b> charT&amp; reference; 
&nbsp;&nbsp; <b>typedef</b> <b>const</b> charT&amp; const_reference; 
<font color="#000080">&nbsp;&nbsp; <i>// iterator, const_iterator 
</i></font>&nbsp;&nbsp; <b>typedef</b> <b>const</b> charT* const_iterator; 
&nbsp;&nbsp; <b>typedef</b> const_iterator iterator; 
<font color="#000080">&nbsp;&nbsp; <i>// difference_type 
</i></font>&nbsp;&nbsp; <b>typedef</b> <b>typename</b> Allocator::difference_type difference_type; 
<font color="#000080">&nbsp;&nbsp; <i>// size_type 
</i></font>&nbsp;&nbsp; <b>typedef</b> <b>typename</b> Allocator::size_type size_type;&nbsp;
&nbsp;&nbsp; <font color="#000080"><i>// allocator_type 
</i></font> <b>  typedef</b> Allocator allocator_type; 
&nbsp;&nbsp; <b>typedef</b> Allocator alloc_type; 
<font color="#000080">&nbsp;&nbsp; <i>// flag_type 
</i></font>&nbsp;&nbsp; <b>typedef</b> boost::int_fast32_t flag_type; 
<b>public</b>: 
&nbsp;  <font color="#000080"><em>// constructors</em></font> 
&nbsp;  <strong>explicit</strong> reg_expression(<b>const</b> Allocator&amp; a = Allocator()); 
&nbsp;&nbsp; <strong>explicit</strong> reg_expression(<b>const</b> charT* p, flag_type f = regbase::normal, <b>const</b> Allocator&amp; a = Allocator()); 
&nbsp;&nbsp; reg_expression(<b>const</b> charT* p1, <b>const</b> charT* p2, flag_type f = regbase::normal, <b>const</b> Allocator&amp; a = Allocator()); 
&nbsp;&nbsp; reg_expression(<b>const</b> charT* p, size_type len, flag_type f, <b>const</b> Allocator&amp; a = Allocator()); 
&nbsp;&nbsp; reg_expression(<b>const</b> reg_expression&amp;); 
<b>&nbsp;&nbsp; template</b> &lt;<b>class</b> ST, <b>class</b> SA&gt; 
&nbsp;&nbsp; <strong>explicit</strong> reg_expression(<b>const</b> std::basic_string&lt;charT, ST, SA&gt;&amp; p, flag_type f = regbase::normal, <b>const</b> Allocator&amp; a = Allocator()); 
<b>&nbsp;&nbsp; template</b> &lt;<b>class</b> I&gt; 
&nbsp;&nbsp; reg_expression(I first, I last, flag_type f = regbase::normal, <b>const</b> Allocator&amp; a = Allocator()); 
&nbsp;&nbsp; ~reg_expression(); 
&nbsp;&nbsp; reg_expression&amp; <b>operator</b>=(<b>const</b> reg_expression&amp;); 
&nbsp;&nbsp; reg_expression&amp; <b>operator</b>=(<b>const</b> charT* ptr); 
<b>&nbsp;&nbsp; template</b> &lt;<b>class</b> ST, <b>class</b> SA&gt; 
&nbsp;&nbsp; reg_expression&amp; <b>operator</b>=(<b>const</b> std::basic_string&lt;charT, ST, SA&gt;&amp; p); 
<font color="#000080">&nbsp;&nbsp; <i>// 
</i>&nbsp;&nbsp; <i>// assign: 
</i></font>&nbsp;&nbsp; reg_expression&amp; assign(<b>const</b> reg_expression&amp; that); 
&nbsp;&nbsp; reg_expression&amp; assign(<b>const</b> charT* ptr, flag_type f = regbase::normal); 
&nbsp;&nbsp; reg_expression&amp; assign(<b>const</b> charT* first, <b>const</b> charT* last, flag_type f = regbase::normal); 
<b>&nbsp;&nbsp; template</b> &lt;<b>class</b> string_traits, <b>class</b> A&gt; 
&nbsp;&nbsp;&nbsp;reg_expression&amp; assign( 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> std::basic_string&lt;charT, string_traits, A&gt;&amp; s, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flag_type f = regbase::normal); 
&nbsp;&nbsp; <b>template</b> &lt;<b>class</b> iterator&gt; 
&nbsp;&nbsp; reg_expression&amp; assign(iterator first, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flag_type f = regbase::normal); 
<font color="#000080">&nbsp;&nbsp; <i>// 
</i>&nbsp;&nbsp; <i>// allocator access: 
</i></font>&nbsp;&nbsp; Allocator get_allocator()<b>const</b>; 
<font color="#000080">&nbsp;&nbsp; <i>// 
</i>&nbsp;&nbsp; <i>// locale: 
</i></font>&nbsp;&nbsp; locale_type imbue(locale_type l); 
&nbsp;&nbsp; locale_type getloc()<b>const</b>; 
<font color="#000080"><i>&nbsp;&nbsp; // 
</i>&nbsp;&nbsp; <i>// flags: 
</i></font>&nbsp;&nbsp; flag_type getflags()<b>const</b>; 
<font color="#000080">&nbsp;&nbsp; <i>// 
</i>&nbsp;&nbsp; <i>// str: 
</i></font>&nbsp;&nbsp; std::basic_string&lt;charT&gt; str()<b>const</b>; 
<font color="#000080">&nbsp;&nbsp; <i>// 
</i>&nbsp;&nbsp; <i>// begin, end: 
</i></font>&nbsp;&nbsp; const_iterator begin()<b>const</b>; 
&nbsp;&nbsp; const_iterator end()<b>const</b>; 
<font color="#000080">&nbsp;&nbsp; <i>// 
</i>&nbsp;&nbsp; <i>// swap: 
</i></font>&nbsp;&nbsp; <b>void</b> swap(reg_expression&amp;)<b>throw</b>(); 
<font color="#000080">&nbsp;&nbsp; <i>// 
</i>&nbsp;&nbsp; <i>// size: 
</i></font>&nbsp;&nbsp; size_type size()<b>const</b>; 
<font color="#000080">&nbsp;&nbsp; <i>// 
</i>&nbsp;&nbsp; <i>// max_size: 
</i></font>&nbsp;&nbsp; size_type max_size()<b>const</b>; 
<font color="#000080">&nbsp;&nbsp; <i>// 
</i>&nbsp;&nbsp; <i>// empty: 
</i></font>&nbsp;&nbsp; <b>bool</b> empty()<b>const</b>; 
&nbsp;&nbsp; <b>unsigned</b> mark_count()<b>const</b>; 
&nbsp;&nbsp; <b>bool</b> <b>operator</b>==(<b>const</b> reg_expression&amp;)<b>const</b>; 
&nbsp;&nbsp; <b>bool</b> <b>operator</b>&lt;(<b>const</b> reg_expression&amp;)<b>const</b>; 
};
} <font color="#000080"><i>// namespace boost </i></font></pre>

<!--<p>Class reg_expression has the following public member functions:-->
<p>reg_expression クラスは次のような公開メンバ関数を持っている:</p>
<br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">reg_expression(Allocator a =
        Allocator());</td>
<!--        <td valign="top" width="45%">&nbsp;Constructs a default
        instance of reg_expression without any expression.</td>
        <td width="5%">&nbsp;</td>-->
        <td valign="top" width="45%">&nbsp;何の表現ももっていない、
        reg_expression のデフォルトのインスタンスを構築する。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">reg_expression(charT* p, <b>unsigned</b>
        f = regbase::normal, Allocator a = Allocator());</td>
<!--        <td valign="top" width="45%">&nbsp;Constructs an instance
        of reg_expression from the expression denoted by the null
        terminated string <b>p</b>, using the flags <b>f</b> to
        determine regular expression syntax. See class <a
        href="#regbase">regbase</a> for allowable flag values.</td>-->
        <td valign="top" width="45%">&nbsp;正規表現構文を決定するためのフラグ <b>f</b> を使って、
	ヌル終端文字列 <b>p</b> で表された表現から reg_expression のインスタンスを構築する。
        利用可能なフラグの値に関しては<a href="#regbase">regbase</a> を見よ。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">reg_expression(charT* p1,
        charT* p2, <b>unsigned</b> f = regbase::normal, Allocator
        a = Allocator());</td>
<!--        <td valign="top" width="45%">&nbsp;Constructs an instance
        of reg_expression from the expression denoted by pair of
        input-iterators <b>p1</b> and <b>p2</b>, using the flags <b>f</b>
        to determine regular expression syntax. See class <a
        href="#regbase">regbase</a> for allowable flag values.</td>-->
        <td valign="top" width="45%">&nbsp;正規表現構文を決定するためのフラグ <b>f</b> を使って、
	入力イテレータ <b>p1</b> と <b>p2</b> で表された表現から reg_expression のインスタンスを構築する。
        利用可能なフラグの値に関しては<a href="#regbase">regbase</a> を見よ。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">reg_expression(charT* p,
        size_type len, <b>unsigned</b> f, Allocator a = Allocator());</td>
<!--        <td valign="top" width="45%">&nbsp;Constructs an instance
        of reg_expression from the expression denoted by the
        string <b>p</b> of length <b>len</b>, using the flags <b>f</b>
        to determine regular expression syntax. See class <a
        href="#regbase">regbase</a> for allowable flag values.</td>-->
        <td valign="top" width="45%">&nbsp;正規表現構文を決定するためのフラグ <b>f</b> を使って、
	長さ <b>len</b> の文字列 <b>p</b> によって表された表現から reg_expression のインスタンスを構築する。
        利用可能なフラグの値に関しては<a href="#regbase">regbase</a> を見よ。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%"><b>template</b> &lt;class
        ST, class SA&gt; <br>
        reg_expression(<b>const</b> std::basic_string&lt;charT,
        ST, SA&gt;&amp; p, boost::int_fast32_t f = regbase::normal,
        <b>const</b> Allocator&amp; a = Allocator());</td>
<!--        <td valign="top" width="45%">&nbsp;Constructs an instance
        of reg_expression from the expression denoted by the
        string <b>p</b>, using the flags <b>f</b> to determine
        regular expression syntax. See class <a href="#regbase">regbase</a>
        for allowable flag values. <p>Note - this member may not
        be available depending upon your compiler capabilities.</p>
        </td>-->
        <td valign="top" width="45%">&nbsp;正規表現構文を決定するためのフラグ <b>f</b> を使って、
	文字列 <b>p</b> によって表された表現から reg_expression のインスタンスを構築する。
        利用可能なフラグの値に関しては<a href="#regbase">regbase</a> を見よ。</p>
	<p>注意 - このメンバはコンパイラによっては利用できないかもしれない。</p>
        </td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">template &lt;class I&gt; <br>
        reg_expression(I first, I last, flag_type f = regbase::normal,
        const Allocator&amp; a = Allocator());</td>
<!--        <td valign="top" width="45%">&nbsp;Constructs an instance
        of reg_expression from the expression denoted by pair of
        input-iterators <b>p1</b> and <b>p2</b>, using the flags <b>f</b>
        to determine regular expression syntax. See class <a
        href="#regbase">regbase</a> for allowable flag values.</td>-->
        <td valign="top" width="45%">&nbsp;正規表現構文を決定するためのフラグ <b>f</b> を使って、
	入力イテレータ <b>p1</b> と <b>p2</b> で表された表現から reg_expression のインスタンスを構築する。
        利用可能なフラグの値に関しては<a href="#regbase">regbase</a> を見よ。</td>
        <td width="5%">&nbsp;</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">reg_expression(<b>const</b>
        reg_expression&amp;);</td>
<!--        <td valign="top" width="45%">Copy constructor - copies an
        existing regular expression.</td>-->
        <td valign="top" width="45%">コピーコンストラクタ。存在する正規表現をコピーする。</td>

        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">reg_expression&amp; <b>operator</b>=(<b>const</b>
        reg_expression&amp;);</td>
<!--        <td valign="top" width="45%">Copies an existing regular
        expression.</td>-->
        <td valign="top" width="45%">存在する正規表現をコピーする。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">reg_expression&amp; <b>operator</b>=(<b>const</b>
        charT* ptr);</td>
<!--        <td valign="top" width="45%">Equivalent to assign(ptr);</td>-->
        <td valign="top" width="45%">assign(ptr) と等価。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">template &lt;class ST, class
        SA&gt; <p>reg_expression&amp; operator=(const std::basic_string&lt;charT,
        ST, SA&gt;&amp; p);</p>
        </td>
<!--        <td valign="top" width="45%">Equivalent to assign(p);</td>-->
        <td valign="top" width="45%">assign(p) と等価。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">reg_expression&amp; assign(<b>const</b>
        reg_expression&amp; that);</td>
<!--        <td valign="top" width="45%">Copies the regular
        expression contained by <b>that</b>, throws <a
        href="#bad_expression">bad_expression</a> if <b>that</b>
        does not contain a valid expression. Returns *this.</td>-->
        <td valign="top" width="45%"><b>that</b> が持っている正規表現をコピーする。
	もし <b>that</b> が有効な正規表現を持っていなければ、
	<a href="#bad_expression">bad_expression</a> が発生する。
        this ポインタを返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">reg_expression&amp; assign(<b>const</b>
        charT* p, flag_type f = regbase::normal);</td>
<!--        <td valign="top" width="45%">Compiles a regular
        expression from the expression denoted by the null
        terminated string <b>p</b>, using the flags <b>f</b> to
        determine regular expression syntax. See class <a
        href="#regbase">regbase</a> for allowable flag values.
        Throws <a href="#bad_expression">bad_expression</a> if <b>p</b>
        does not contain a valid expression. Returns *this.</td>-->
        <td valign="top" width="45%">正規表現構文を決定するためのフラグ <b>f</b> を使って、
	ヌル終端文字列 <b>p</b> で表された表現から正規表現をコンパイルする。
        利用可能なフラグの値に関しては<a href="#regbase">regbase</a> を見よ。
	もし <b>p</b> が有効な正規表現を持っていなければ
	<a href="#bad_expression">bad_expression</a> が発生する。
	this ポインタを返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">reg_expression&amp; assign(<b>const</b>
        charT* first, <b>const</b> charT* last, flag_type f =
        regbase::normal);</td>
<!--        <td valign="top" width="45%">Compiles a regular
        expression from the expression denoted by the pair of
        input-iterators <b>first-last</b>, using the flags <b>f</b>
        to determine regular expression syntax. See class <a
        href="#regbase">regbase</a> for allowable flag values.
        Throws <a href="#bad_expression">bad_expression</a> if <b>first-last</b>
        does not contain a valid expression. Returns *this.</td>-->
        <td valign="top" width="45%">正規表現構文を決定するためのフラグ <b>f</b> を使って、
	入力イテレータ <b>first-last</b> で表された表現から正規表現をコンパイルする。
        利用可能なフラグの値に関しては<a href="#regbase">regbase</a> を見よ。
	もし <b>p</b> が有効な正規表現を持っていなければ
	<a href="#bad_expression">bad_expression</a> が発生する。
	this ポインタを返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%"><b>template</b> &lt;<b>class</b>
        string_traits, <b>class</b> A&gt; <br>
        reg_expression&amp; assign(<b>const</b> std::basic_string&lt;charT,
        string_traits, A&gt;&amp; s, flag_type f = regbase::normal);</td>
<!--        <td valign="top" width="45%">Compiles a regular
        expression from the expression denoted by the string <b>s</b>,
        using the flags <b>f</b> to determine regular expression
        syntax. See class <a href="#regbase">regbase</a> for
        allowable flag values. Throws <a href="#bad_expression">bad_expression</a>
        if <b>s</b> does not contain a valid expression. Returns
        *this.</td>-->
        <td valign="top" width="45%">正規表現構文を決定するためのフラグ <b>f</b> を使って、
	文字列 <b>s</b> で表された表現から正規表現をコンパイルする。
        利用可能なフラグの値に関しては<a href="#regbase">regbase</a> を見よ。
	もし <b>p</b> が有効な正規表現を持っていなければ
	<a href="#bad_expression">bad_expression</a> が発生する。
	this ポインタを返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">template &lt;class
        iterator&gt; <br>
        reg_expression&amp; assign(iterator first, iterator last,
        flag_type f = regbase::normal);</td>
<!--        <td valign="top" width="45%">Compiles a regular
        expression from the expression denoted by the pair of
        input-iterators <b>first-last</b>, using the flags <b>f</b>
        to determine regular expression syntax. See class <a
        href="#regbase">regbase</a> for allowable flag values.
        Throws <a href="#bad_expression">bad_expression</a> if <b>first-last</b>
        does not contain a valid expression. Returns *this.</td>-->
        <td valign="top" width="45%">正規表現構文を決定するためのフラグ <b>f</b> を使って、
	入力イテレータ <b>first-last</b> で表された表現から正規表現をコンパイルする。
        利用可能なフラグの値に関しては<a href="#regbase">regbase</a> を見よ。
	もし <b>p</b> が有効な正規表現を持っていなければ
	<a href="#bad_expression">bad_expression</a> が発生する。
	this ポインタを返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">Allocator get_allocator()<b>const</b>;</td>
<!--        <td valign="top" width="45%">Returns the allocator used
        by the expression.</td>-->
        <td valign="top" width="45%">正規表現で使われるアロケータを返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">locale_type imbue(<b>const</b>
        locale_type&amp; l);</td>
<!--        <td valign="top" width="45%">Imbues the expression with
        the specified locale, and invalidates the current
        expression. May throw std::runtime_error if the call
        results in an attempt to open a non-existent message
        catalogue.</td>-->
        <td valign="top" width="45%">正規表現を特定のロケールに変更し、
	現在の表現を無効にする。
	もし呼び出しの結果、実在しないメッセージカタログが開かれようとしたら、
	std::runtime_error が発生するだろう。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">locale_type getloc()<b>const</b>;</td>
<!--        <td valign="top" width="45%">Returns the locale used by
        the expression.</td>-->
        <td valign="top" width="45%">表現で使われているロケールを返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">flag_type getflags()<b>const</b>;</td>
<!--        <td valign="top" width="45%">Returns the flags used to
        compile the current expression.</td>-->
        <td valign="top" width="45%">現在の表現をコンパイルするのに使われているフラグを返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">std::basic_string&lt;charT&gt;
        str()<b>const</b>;</td>
<!--        <td valign="top" width="45%">Returns the current
        expression as a string.</td>-->
        <td valign="top" width="45%">現在の表現を文字列として返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">const_iterator begin()<b>const</b>;</td>
<!--        <td valign="top" width="45%">Returns a pointer to the
        first character of the current expression.</td>-->
        <td valign="top" width="45%">現在の表現の最初の文字へのポインタを返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">const_iterator end()<b>const</b>;</td>
<!--        <td valign="top" width="45%">Returns a pointer to the end
        of the current expression.</td>-->
        <td valign="top" width="45%">現在の表現の最後の文字へのポインタを返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">size_type size()<b>const</b>;</td>
<!--        <td valign="top" width="45%">Returns the length of the
        current expression.</td>-->
        <td valign="top" width="45%">現在の表現の長さを返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">size_type max_size()<b>const</b>;</td>
<!--        <td valign="top" width="45%">Returns the maximum length
        of a regular expression text.</td>-->
        <td valign="top" width="45%">正規表現文字列の最大長を返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%"><b>bool</b> empty()<b>const</b>;</td>
<!--        <td valign="top" width="45%">Returns true if the object
        contains no valid expression.</td>-->
        <td valign="top" width="45%">オブジェクトが有効な表現を持っていなければ true を返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%"><b>unsigned</b> mark_count()<b>const</b>
        ;</td>
<!--        <td valign="top" width="45%">Returns the number of sub-expressions
        in the compiled regular expression. Note that this
        includes the whole match (subexpression zero), so the
        value returned is always &gt;= 1.</td>-->
        <td valign="top" width="45%">コンパイルされた正規表現の中の子表現の数を返す
	これは全体の一致(子表現がゼロ)も含み、常に1以上を返すことに注意せよ。</td>
        <td width="5%">&nbsp;</td>
    </tr>
</table>

<hr>

<h3><a name="regex_char_traits"></a><i>Class regex_traits</i></h3>

<p>#include &lt;<a href="../../boost/regex/regex_traits.hpp">boost/regex/regex_traits.hpp</a>&gt;
</p>

<!--<p><i>This is a preliminary version of the regular expression
traits class, and is subject to change</i>. </p>-->
<p><i>これは正規表現特性クラスの予備的なバージョンであり、変更を必要とする。</i></p>

<!--<p>The purpose of the traits class is to make it easier to
customise the behaviour of <i>reg_expression </i>and the
associated matching algorithms. Custom traits classes can handle
special character sets or define additional character classes,
for example one could define [[:kanji:]] as the set of all (Unicode)
kanji characters. This library provides three traits classes and
a wrapper class <i>regex_traits</i>, which inherits from one of
these depending upon the default localisation model in use, class
<i>c_regex_traits</i> encapsulates the global C locale, class <i>w32_regex_traits</i>
encapsulates the global Win32 locale (only available on Win32
systems), and class <i>cpp_regex_traits</i> encapsulates the C++
locale (only provided if std::locale is supported): </p>-->
<p>特性クラスの目的は、 <i>reg_expression</i> クラスと、それに関連する
マッチングアルゴリズムの振る舞いのカスタマイズをより簡単にすることである。
カスタム特性クラスは特殊文字セットを扱うことが出来て、追加の文字クラスを定義する。
例えば、全ての(ユニコード)漢字文字として [[:kanji:]] を定義することが出来る。
このライブラリは3つの特性クラスと、使われているデフォルトのロケールモデルに依存して
この3つのうちのひとつを継承するラッパクラス <i>regex_traits</i> を提供している。
<i>c_regex_traits</i> クラスは C のグローバルロケールをカプセル化している。
<i>w32_regex_traits</i> クラスは Win32 グローバルロケールをカプセル化している
(Win32 システム上だけで利用できる)。
<i>cpp_regex_traits</i> は C++ のロケールをカプセル化している
(std::locale がサポートされているときのみ提供される):</p>

<pre>template &lt;class charT&gt; class c_regex_traits;
template&lt;&gt; class c_regex_traits&lt;char&gt; { /*details*/ };
template&lt;&gt; class c_regex_traits&lt;wchar_t&gt; { /*details*/ };

template &lt;class charT&gt; class w32_regex_traits;
template&lt;&gt; class w32_regex_traits&lt;char&gt; { /*details*/ };
template&lt;&gt; class w32_regex_traits&lt;wchar_t&gt; { /*details*/ };

template &lt;class charT&gt; class cpp_regex_traits;
template&lt;&gt; class cpp_regex_traits&lt;char&gt; { /*details*/ };
template&lt;&gt; class cpp_regex_traits&lt;wchar_t&gt; { /*details*/ };

template &lt;class charT&gt; class regex_traits : public base_type { /*detailts*/ };</pre>

<!--<p>Where &quot;<i>base_type</i>&quot; defaults to <i>w32_regex_traits</i>
on Win32 systems, and <i>c_regex_traits</i> otherwise. The
default behaviour can be changed by defining one of
BOOST_REGEX_USE_C_LOCALE (forces use of <i>c_regex_traits</i> by
default), or BOOST_REGEX_USE_CPP_LOCALE (forces use of <i>cpp_regex_traits</i>
by default). Alternatively a specific traits class can be passed
to the <i>reg_expression</i> template. </p>-->
<p>&quot;<i>base_type</i>&quot; は Win32 システム上では、
デフォルトで <i>w32_regex_traits</i> である。そうでなければ、
<i>c_regex_traits</i> がデフォルトである。
デフォルトの振る舞いは BOOST_REGEX_USE_C_LOCALE 
(<i>c_regex_traits</i> をデフォルトで使うように強制する)、または
BOOST_REGEX_USE_CPP_LOCALE 
(<i>cpp_regex_traits</i> をデフォルトで使うように強制する) 
を定義することによって変更できる
もう一つの選択肢として、特定の特性クラスを <i>reg_expression</i> テンプレートに
渡すことも出来る。</p>

<!--<p>The requirements for custom traits classes are <a
href="traits_class_ref.htm">documented separately here....</a> </p>-->
<p>カスタムの制約クラスのための要求は
<a href="traits_class_ref.htm">ここに記されている</a>。 </p>

<!--<p>There is also an example of a custom traits class supplied by <a
href="mailto:christian.engstrom@glindra.org">Christian Engstr</a>,
see <a
href="example/iso8859_1_regex_traits/iso8859_1_regex_traits.cpp">iso8859_1_regex_traits.cpp</a>
and <a
href="example/iso8859_1_regex_traits/iso8859_1_regex_traits.hpp">iso8859_1_regex_traits.hpp</a>,
see <a href="example/iso8859_1_regex_traits/readme.txt">the
readme file</a> for more details.</p>-->
<p>また、カスタムの制約クラスの例が
<a href="mailto:christian.engstrom@glindra.org">Christian Engstr</a> によって提供されている。
<a href="example/iso8859_1_regex_traits/iso8859_1_regex_traits.cpp">iso8859_1_regex_traits.cpp</a> 及び
<a href="example/iso8859_1_regex_traits/iso8859_1_regex_traits.hpp">iso8859_1_regex_traits.hpp</a> を見よ。
より詳細は<a href="example/iso8859_1_regex_traits/readme.txt">readme file</a> を見よ。</p>

<hr>

<h3><a name="reg_match"></a><i>Class match_results</i></h3>

<p>#include &lt;<a href="../../boost/regex.hpp">boost/regex.hpp</a>&gt;
</p>

<!--<p>Regular expressions are different from many simple pattern-matching
algorithms in that as well as finding an overall match they can
also produce sub-expression matches: each sub-expression being
delimited in the pattern by a pair of parenthesis (...). There
has to be some method for reporting sub-expression matches back
to the user: this is achieved this by defining a class <i>match_results</i>
that acts as an indexed collection of sub-expression matches,
each sub-expression match being contained in an object of type <i>sub_match</i>.
</p>-->
<p>正規表現は、多くの単純なパターンマッチングのアルゴリズムとはことなる。
なぜなら全体での一致を発見し、子表現の一致を作ることも出来るからである: 
それぞれの子表現は、パターンの中で、丸括弧 (...) の組により区切られている。
子表現の一致をユーザに報告するための方法もある:
これは、 子表現の一致の集合の索引としての機能をもつ <i>match_results</i> クラス
により実現されている。
それぞれの子表現の一致は <i>sub_match</i> 型のオブジェクトの中に格納されている。</p>

<pre><font color="#000080"><i>// 
// class sub_match: 
// denotes one sub-expression match. 
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</i></font><b>template</b> &lt;<b>class</b> iterator&gt;
<b>struct</b> sub_match
{
&nbsp;&nbsp; <b>typedef</b> <b>typename</b> std::iterator_traits&lt;iterator&gt;::value_type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_type;
&nbsp;&nbsp; <b>typedef</b> <b>typename</b> std::iterator_traits&lt;iterator&gt;::difference_type&nbsp; difference_type;
&nbsp;&nbsp; <b>typedef</b> iterator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator_type;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; iterator first;
&nbsp;&nbsp; iterator second;
&nbsp;&nbsp; <b>bool</b> matched;

&nbsp;&nbsp; <b>operator</b> std::basic_string&lt;value_type&gt;()<b>const</b>;

&nbsp;&nbsp; <b>bool</b> <b>operator</b>==(<b>const</b> sub_match&amp; that)<b>const</b>;
&nbsp;&nbsp; <b>bool</b> <b>operator</b> !=(<b>const</b> sub_match&amp; that)<b>const</b>;
&nbsp;&nbsp; difference_type length()<b>const</b>;
};

<font color="#000080">// 
// class match_results: 
// contains an indexed collection of matched sub-expressions. 
// 
</font><b>template</b> &lt;<b>class</b> iterator, <b>class</b> Allocator = std::allocator&lt;<strong>typename</strong> std::iterator_traits&lt;iterator&gt;::value_type &gt; &gt; 
<b>class</b> match_results 
{ 
<b>public</b>: 
&nbsp;&nbsp; <b>typedef</b> Allocator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alloc_type; 
&nbsp;&nbsp; <b>typedef</b> <b>typename</b> Allocator::<b>template</b> Rebind&lt;iterator&gt;::size_type&nbsp; size_type; 
&nbsp;&nbsp; <b>typedef</b> <b>typename</b> std::iterator_traits&lt;iterator&gt;::value_type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char_type; 
&nbsp;&nbsp; <b>typedef</b> sub_match&lt;iterator&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value_type; 
&nbsp;&nbsp; <b>typedef</b> <b>typename</b> std::iterator_traits&lt;iterator&gt;::difference_type&nbsp; difference_type; 
&nbsp;&nbsp; <b>typedef</b> iterator&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator_type; 
&nbsp;&nbsp; <strong>explicit</strong> match_results(<b>const</b> Allocator&amp; a = Allocator()); 
&nbsp;&nbsp; match_results(<b>const</b> match_results&amp; m); 
&nbsp;&nbsp; match_results&amp; <b>operator</b>=(<b>const</b> match_results&amp; m); 
&nbsp;&nbsp; ~match_results(); 
&nbsp;&nbsp; size_type size()<b>const</b>; 
&nbsp;&nbsp; <b>const</b> sub_match&lt;iterator&gt;&amp; <b>operator</b>[](<b>int</b> n) <b>const</b>; 
&nbsp;&nbsp; Allocator allocator()<b>const</b>; 
&nbsp;&nbsp; difference_type length(<b>int</b> sub = 0)<b>const</b>; 
&nbsp;&nbsp; difference_type position(<b>unsigned</b> <b>int</b> sub = 0)<b>const</b>; 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> line()<b>const</b>; 
&nbsp;&nbsp; iterator line_start()<b>const</b>; 
&nbsp;&nbsp; std::basic_string&lt;char_type&gt; str(<b>int</b> sub = 0)<b>const</b>; 
&nbsp;&nbsp; <b>void</b> swap(match_results&amp; that); 
&nbsp;&nbsp; <b>bool</b> <b>operator</b>==(<b>const</b> match_results&amp; that)<b>const</b>; 
&nbsp;&nbsp; <b>bool</b> <b>operator</b>&lt;(<b>const</b> match_results&amp; that)<b>const</b>; 
};
<strong>typedef</strong> match_results&lt;<strong>const</strong> <strong>char</strong>*&gt; cmatch;
<strong>typedef</strong> match_results&lt;<strong>const</strong> <strong>wchar_t</strong>*&gt; wcmatch; 
<strong>typedef</strong> match_results&lt;std::string::const_iterator&gt; smatch;
<strong>typedef</strong> match_results&lt;std::wstring::const_iterator&gt; wsmatch; </pre>

<!--<p>Class match_results is used for reporting what matched a
regular expression, it is passed to the matching algorithms <a
href="#query_match">regex_match</a> and <a href="#reg_search">regex_search</a>,
and is used by <a href="#reg_grep">regex_grep</a> to notify the
callback function (or function object) what matched. Note that
the default allocator parameter has been chosen to match the
default allocator parameter to reg_expression. match_results has
the following public member functions: <br>
&nbsp; </p>-->
<p>match_results クラスは正規表現に一致したものを報告するのに使われる。
これはマッチングアルゴリズム <a href="#query_match">regex_match</a> と
<a href="#reg_search">regex_search</a> を渡されて、
<a href="#reg_grep">regex_grep</a> によってコールバック関数(または関数オブジェクト)
にに何が一致したのかを知らせる。
一致判定の為に選ばれるデフォルトのアロケータパラメータは、 reg_expresion の
デフォルトのアロケータパラメータであることに注意せよ。
match_results には次の公開メンバ関数がある: <br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">match_results(Allocator a =
        Allocator());</td>
<!--        <td valign="top" width="45%">Constructs an instance of
        match_results, using allocator instance a.</td>-->
        <td valign="top" width="45%">アロケータのインスタンス a を使って、
	match_results のインスタンスを構築する。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">match_results(const
        match_results&amp; m);</td>
<!--       <td valign="top" width="45%">Copy constructor.</td>-->
        <td valign="top" width="45%">コピーコンストラクタ</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">match_results&amp; operator=(const
        match_results&amp; m);</td>
<!--        <td valign="top" width="45%">Assignment operator.</td>-->
        <td valign="top" width="45%">代入演算子。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%"><b>const</b>
        sub_match&lt;iterator&gt;&amp; <b>operator</b>[](size_type
        n) const;</td>
<!--        <td valign="top" width="45%">Returns what matched, item 0
        represents the whole string, item 1 the first sub-expression
        and so on.</td>-->
        <td valign="top" width="45%">一致したものを返す。
	<b>n</b> が 0 なら文字列全体を、 <b>n</b> が 1 なら最初の子表現を表している。
	(訳注: 以下、その数字に対応する子表現を表している)</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">Allocator&amp; allocator()const;</td>
<!--        <td valign="top" width="45%">Returns the allocator used
        by the class.</td>-->
        <td valign="top" width="45%">このクラスで使われているアロケータを返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">difference_type length(<b>unsigned
        int</b> sub = 0);</td>
<!--        <td valign="top" width="45%">Returns the length of the
        matched subexpression, defaults to the length of the
        whole match, in effect this is equivalent to operator[](sub).second
        - operator[](sub).first.</td>-->
        <td valign="top" width="45%">一致した子表現の長さを返す。
	デフォルトでは全体の一致の長さを返す。
	要するにこれは、operator [](sub).second - operator[](sub).first と等価である。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">difference_type position(<b>unsigned
        int</b> sub = 0);</td>
<!--        <td valign="top" width="45%">Returns the position of the
        matched sub-expression, defaults to the position of the
        whole match. The returned value is the position of the
        match relative to the start of the string.</td>-->
        <td valign="top" width="45%">一致した子表現の位置を返す。
	デフォルトでは全体の一致の位置を返す。
	戻り値は、文字列の先頭からの相対的な一致の位置である。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%"><b>unsigned</b> <b>int</b>
        line()<b>const</b>;</td>
<!--        <td valign="top" width="45%">Returns the index of the
        line on which the match occurred, indices start with 1,
        not zero. Equivalent to the number of newline characters
        prior to operator[](0).first plus one.</td>-->
        <td valign="top" width="45%">一致が起こった行番号を返す。
	行番号の先頭は 0 でなく 1 である。
	operator[](0) より前の改行文字の数に 1 を加えたものと等価である。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">iterator line_start()<b>const;</b></td>
<!--        <td valign="top" width="45%">Returns an iterator denoting
        the start of the line on which the match occurred.</td>-->
        <td valign="top" width="45%">一致が起こった行の先頭を示すイテレータを返す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">size_type size()<b>const;</b></td>
<!--        <td valign="top" width="45%">Returns how many sub-expressions
        are present in the match, including sub-expression zero (the
        whole match). This is the case even if no matches were
        found in the search operation - you must use the returned
        value from <a href="#reg_search">regex_search</a> / <a
        href="#query_match">regex_match</a> to determine whether
        any match occured.</td>-->
        <td valign="top" width="45%">一致の中に、
	子表現 0 (全体の一致) も含めて、
	いくつの子表現が存在するかを返す。
	もし検索の操作で一致が見つからなかったとき、これは重要である。
	一致が起こったかどうか決定するのに、
	<a href="#reg_search">regex_search</a> / 
	<a href="#query_match">regex_match</a> からの戻り値を使わなければならない。</td>
        <td width="5%">&nbsp;</td>
    </tr>
</table>

<p><br>
&nbsp; </p>

<!--<p>The operator[] member function needs further explanation: it
returns a const reference to a structure of type
sub_match&lt;iterator&gt;, which has the following public members:
<br>
&nbsp; </p>-->
<p>メンバ関数 operator[] は更に説明が必要である。これは sub_match&lt;iterator&gt; 型
の構造体への const の参照を返す。
sub_match&lt;iterator&gt; は次の公開メンバを持っている:
<br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top" width="6%">&nbsp;</td>
        <td valign="top" width="44%"><b>typedef</b> <b>typename</b>
        std::iterator_traits&lt;iterator&gt;::value_type
        value_type;</td>
<!--        <td valign="top" width="44%">The type pointed to by the
        iterators.</td>-->
        <td valign="top" width="44%">イテレータによって指されている型。</td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="6%">&nbsp;</td>
        <td valign="top" width="44%"><b>typedef</b> <b>typename</b>
        std::iterator_traits&lt;iterator&gt;::difference_type
        difference_type;</td>
<!--        <td valign="top" width="44%">A type that represents the
        difference between two iterators.</td>-->
        <td valign="top" width="44%">二つのイテレータの違いを表す型。</td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="6%">&nbsp;</td>
        <td valign="top" width="44%"><b>typedef</b> iterator
        iterator_type;</td>
<!--        <td valign="top" width="44%">The iterator type.</td>-->
        <td valign="top" width="44%">イテレータの型。</td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="6%">&nbsp;</td>
        <td valign="top" width="44%">iterator first</td>
<!--        <td valign="top" width="44%">An iterator denoting the
        position of the start of the match.</td>-->
        <td valign="top" width="44%">一致の先頭の位置を示すイテレータ。</td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="6%">&nbsp;</td>
        <td valign="top" width="44%">iterator second</td>
<!--        <td valign="top" width="44%">An iterator denoting the
        position of the end of the match.</td>-->
        <td valign="top" width="44%">一致の終端の位置を示すイテレータ。</td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="6%">&nbsp;</td>
        <td valign="top" width="44%"><b>bool</b> matched</td>
<!--        <td valign="top" width="44%">A Boolean value denoting
        whether this sub-expression participated in the match.</td>-->
        <td valign="top" width="44%">この子表現が一致したものの中にあるかを示す bool 値。</td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="6%">&nbsp;</td>
        <td valign="top" width="44%">difference_type length()<b>const;</b></td>
<!--        <td valign="top" width="44%">Returns the length of the
        sub-expression match.</td>-->
        <td valign="top" width="44%">子表現の一致の長さを返す。</td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="6%">&nbsp;</td>
        <td valign="top" width="44%"><b>operator</b> std::basic_string&lt;value_type&gt;
        ()<b>const</b>;</td>
<!--        <td valign="top" width="44%">Converts the sub-expression
        match into an instance of std::basic_string&lt;&gt;. Note
        that this member may be either absent, or present to a
        more limited degree depending upon your compiler
        capabilities.</td>-->
        <td valign="top" width="44%">子表現の一致を std::basic_string&lt;&gt; 
	のインスタンスに変換する。
	このメンバは存在しないか、コンパイラに依存して、より限られて存在するかのどちらかだろう、
	ということに注意せよ。</td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
</table>

<!--<p>Operator[] takes an integer as an argument that denotes the
sub-expression for which to return information, the argument can
take the following special values: <br>
&nbsp; </p>-->
<p>operator [] は情報を返す子表現を表す引数として整数値を取る。
引数は次のような特殊な値を取りうる:<br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top" width="6%">&nbsp;</td>
        <td valign="top" width="44%">-2</td>
<!--        <td valign="top" width="44%">Returns everything from the
        end of the match, to the end of the input string,
        equivalent to $' in perl. If this is a null string, then:
        <p>first == second </p>
        <p>And </p>
        <p>matched == false.</p>
        </td>-->
        <td valign="top" width="44%">一致の終端から、入力された文字列の終端までの
	全てを返す。これは perl での $' と等価である。
	もしこれが null 文字列なら:
        <p>first == second </p>
        <p>かつ</p>
        <p>matched == false</p>
	<p>である。</p>
        </td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="6%">&nbsp;</td>
        <td valign="top" width="44%">-1</td>
<!--        <td valign="top" width="44%">Returns everything from the
        start of the input string (or the end of the last match
        if this is a grep operation), to the start of this match.
        Equivalent to $` in perl. If this is a null string, then:
        <p>first == second </p>
        <p>And </p>
        <p>matched == false.</p>
        </td>-->
        <td valign="top" width="44%">入力された文字列の先頭から
	(または、もし grep の操作であれば最後の一致の終端から)
	この一致の先頭までの全てを返す。
	perl での $` と等価である。
	もしこれが null 文字列なら:
        <p>first == second </p>
        <p>かつ</p>
        <p>matched == false.</p>
	<p>である。</p>
        </td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="6%">&nbsp;</td>
        <td valign="top" width="44%">0</td>
<!--        <td valign="top" width="44%">Returns the whole of what
        matched, equivalent to $&amp; in perl. The matched
        parameter is always true.</td>-->
        <td valign="top" width="44%">一致したもの全体を返す。
	perl での $&amp; と等価である。
	パラメータ matched は常に true である。</td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="6%">&nbsp;</td>
        <td valign="top" width="44%">0 &lt; N &lt; size()</td>
<!--        <td valign="top" width="44%">Returns what matched sub-expression
        N, if this sub-expression did not participate in the
        match then&nbsp; <p>matched == false </p>
        <p>otherwise: </p>
        <p>matched == true.</p>
        </td>-->
        <td valign="top" width="44%">子表現 N に一致したものを返す。
	もしこの子表現が何も一致していなかったら、
        <p>matched == false </p>
        <p>そうでなければ</p>
        <p>matched == true</p>
	<p>である。</p>
        </td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="6%">&nbsp;</td>
        <td valign="top" width="44%">N &lt; -2 or N &gt;= size()</td>
<!--        <td valign="top" width="44%">Represents an out-of range
        non-existent sub-expression. Returns a &quot;null&quot;
        match in which <p>first == last </p>
        <p>And </p>
        <p>matched == false.</p>
        </td>-->
        <td valign="top" width="44%">範囲外の存在しない子表現を表している。
	「空の」一致を返す。つまり、
        <p>first == last </p>
        <p>かつ</p>
        <p>matched == false.</p>
	<p>である。</p>
        </td>
        <td valign="top" width="5%">&nbsp;</td>
    </tr>
</table>

<!--<p>Note that as well as being parameterised for an allocator,
match_results&lt;&gt; also takes an iterator type, this allows
any pair of iterators to be searched for a given regular
expression, provided the iterators have at least bi-directional
properties. </p>-->
<p>アロケータのパラメータと同様に、 match_results&lt;&gt; もまた
イテレータ型をもち、これはどんなイテレータの組み合わせも、それが
双方向イテレータであるなら、
与えられた正規表現で検索することが出来る、ということに注意せよ。
</p>

<hr>

<h3><a name="query_match"></a>Algorithm regex_match</h3>

<p>#include &lt;<a href="../../boost/regex.hpp">boost/regex.hpp</a>&gt;
</p>

<!--<p>The algorithm regex _match determines whether a given regular
expression matches a given sequence denoted by a pair of
bidirectional-iterators, the algorithm is defined as follows, <em>note
that the result is true only if the expression matches the whole
of the input sequence</em>, the main use of this function is data
input validation: </p>-->
<p>アルゴリズム regex_match は与えられた正規表現が、
一組の双方向イテレータによって表されるシーケンスに一致するかを決定する。
このアルゴリズムは以下のように定義されている。
<em>入力シーケンス全体と一致したときのみ結果が true であることに注意せよ。</em>
この関数の主要な使い道は、入力データの検証である:</p>

<pre><b>template</b> &lt;<b>class</b> iterator, <b>class</b> Allocator, <b>class</b> charT, <b>class</b> traits, <b>class</b> Allocator2&gt;
<b>bool</b> regex_match(iterator first,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match_results&lt;iterator, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = match_default);</pre>

<!--<p>The library also defines the following convenience versions,
which take either a const charT*, or a const std::basic_string&lt;&gt;&amp;
in place of a pair of iterators [note - these versions may not be
available, or may be available in a more limited form, depending
upon your compilers capabilities]: </p>-->
<p>ライブラリは次の簡易版も定義している。
これは const charT* 型か、或いは const std::basic_string&lt;&gt;&amp; 型を
一組のイテレータの代わりにとる。[コンパイラによってはこれらの簡易版は
利用できないかもしれないこと、或いは限られた形でしか利用できないかもしれないこと
に注意せよ]:</p>

<pre><b>template</b> &lt;<b>class</b> charT, <b>class</b> Allocator, <b>class</b> traits, <b>class</b> Allocator2&gt;
<b>bool</b> regex_match(<b>const</b> charT* str,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match_results&lt;<b>const</b> charT*, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = match_default)

<b>template</b> &lt;<b>class</b> ST, <b>class</b> SA, <b>class</b> Allocator, <b>class</b> charT, <b>class</b> traits, <b>class</b> Allocator2&gt;
<b>bool</b> regex_match(<b>const</b> std::basic_string&lt;charT, ST, SA&gt;&amp; s,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match_results&lt;<b>typename</b> std::basic_string&lt;charT, ST, SA&gt;::const_iterator, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = match_default);</pre>

<!--<p>Finally there is a set of convenience versions that simply
return true or false and do not indicate what matched: </p>-->
<p>最後に、ただ true か false を返すだけで、
何が一致したかに関与しない簡易版がある。</p>

<pre><b>template</b> &lt;<b>class</b> iterator, <b>class</b> Allocator, <b>class</b> charT, <b>class</b> traits, <b>class</b> Allocator2&gt;
<b>bool</b> regex_match(iterator first,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last,&nbsp;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const</b> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = match_default);

<b>template</b> &lt;<b>class</b> charT, <b>class</b> Allocator, <b>class</b> traits, <b>class</b> Allocator2&gt;
<b>bool</b> regex_match(<b>const</b> charT* str,&nbsp;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const</b> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = match_default)

<b>template</b> &lt;<b>class</b> ST, <b>class</b> SA, <b>class</b> Allocator, <b>class</b> charT, <b>class</b> traits, <b>class</b> Allocator2&gt;
<b>bool</b> regex_match(<b>const</b> std::basic_string&lt;charT, ST, SA&gt;&amp; s,&nbsp;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const</b> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = match_default);</pre>

<!--<p>The parameters for the main function version are as follows: <br>
&nbsp; </p>-->
<p>主要版(訳注:簡易版ではない定義)の関数のパラメータは次の通りである。<br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td width="5%">&nbsp;</td>
        <td width="51%">iterator first</td>
<!--        <td>Denotes the start of the range to be matched.</td>-->
        <td>一致させる範囲の先頭を示す。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td valign="top" width="51%">iterator last</td>
<!--        <td valign="top" width="51%">Denotes the end of the range
        to be matched.</td>-->
        <td valign="top" width="51%">一致させる範囲の終端を示す。</td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td valign="top" width="51%">match_results&lt;iterator,
        Allocator&gt;&amp; m</td>
<!--        <td valign="top" width="51%">An instance of match_results
        in which what matched will be reported. On exit if a
        match occurred then m[0] denotes the whole of the string
        that matched, m[0].first must be equal to first, m[0].second
        will be less than or equal to last. m[1] denotes the
        first subexpression m[2] the second subexpression and so
        on. If no match occurred then m[0].first = m[0].second =
        last.<p>Note that since the match_results structure
        stores only iterators, and not strings, the iterators/strings
        passed to regex_match must be valid for as long as the
        result is to be used. For that reason never pass
        temporary string objects to regex_match.</p>-->
        </td>
        <td valign="top" width="51%">何が一致したかを報告するための
	match_results のインスタンス。関数を抜けるときに、もし一致が起こっていたら
	m[0] は一致した文字列の全体を表す。 m[0].first は first と等しく、
	m[0].second は last より少ないか、等しい。
	m[1] は最初の子表現、 m[2] は2番目の子表現を示し、以下それが続く。
	もし一致が起こらなければ、 m[0].first = m[0].second = last である。
	<p>match_results 構造体はイテレータのみを保持し、文字列を保持していないので、
	regex_match に渡されるイテレータと文字列は、その結果が使われる限り
	有効でなければならないことに注意せよ。このため、決して一時的文字列オブジェクトを
	regex_match に渡してはならない。</p>
        </td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td valign="top" width="51%">const
        reg_expression&lt;charT, traits, Allocator2&gt;&amp; e</td>
<!--        <td valign="top" width="51%">Contains the regular
        expression to be matched.</td>-->
        <td valign="top" width="51%">一致判定につかう正規表現を持つ。</td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td valign="top" width="51%">unsigned flags =
        match_default</td>
<!--        <td valign="top" width="51%">Determines the semantics
        used for matching, a combination of one or more <a
        href="#match_type">match_flags</a> enumerators.</td>-->
        <td valign="top" width="51%">一致に使われるセマンティクスを決定する。
	ひとつ以上の <a href="#match_type">match_flags</a> 列挙子の組み合わせである。</td>
        <td>&nbsp;</td>
    </tr>
</table>

<!--<p>regex_match returns false if no match occurs or true if it
does. A match only occurs if it starts at <b>first</b> and
finishes at <b>last</b>. Example: the following <a
href="example/snippets/regex_match_example.cpp">example</a>
processes an ftp response: </p>-->
<p>regex_match は一致が起こらなければ false を、起これば true を返す。
一致は、 <b>first</b> で始まり、 <b>last</b> で終わるときにだけ起こる。
例えば、次の例: 
<a href="example/snippets/regex_match_example.cpp">example</a>
は FTP レスポンスの処理である。
</p>

<pre><font color="#008000">#include &lt;stdlib.h&gt; 
#include &lt;boost/regex.hpp&gt; 
#include &lt;string&gt; 
#include &lt;iostream&gt; 

</font><b>using namespace</b> boost; 

regex expression(<font color="#000080">&quot;([0-9]+)(\\-| |$)(.*)&quot;</font>); 

<font color="#000080"><i>// process_ftp: 
// on success returns the ftp response code, and fills 
// msg with the ftp response message. 
</i></font><b>int</b> process_ftp(<b>const</b> <b>char</b>* response, std::string* msg) 
{ 
&nbsp;&nbsp; cmatch what; 
&nbsp;&nbsp; <b>if</b>(regex_match(response, what, expression)) 
&nbsp;&nbsp; { 
<font color="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>// what[0] contains the whole string 
</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>// what[1] contains the response code 
</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>// what[2] contains the separator character 
</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>// what[3] contains the text message. 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>if</b>(msg) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg-&gt;assign(what[3].first, what[3].second); 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>return</b> std::atoi(what[1].first); 
&nbsp;&nbsp; } 
<font color="#000080">&nbsp;&nbsp; <i>// failure did not match 
</i></font>&nbsp;&nbsp; <b>if</b>(msg) 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg-&gt;erase(); 
&nbsp;&nbsp; <b>return</b> -1; 
}</pre>

<!--<p><a name="match_type"></a>The value of the flags parameter
passed to the algorithm must be a combination of one or more of
the following values: <br>
&nbsp; </p>-->
<p><a name="match_type"></a>アルゴリズムに渡されるフラグパラメータの値は
次の値のひとつ以上の組み合わせでなければならない。<br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">match_default</td>
<!--        <td valign="top" width="45%">The default value, indicates
        that <b>first</b> represents the start of a line, the
        start of a buffer, and (possibly) the start of a word.
        Also implies that <b>last</b> represents the end of a
        line, the end of the buffer and (possibly) the end of a
        word. Implies that a dot sub-expression &quot;.&quot;
        will match both the newline character and a null.</td>-->
        <td valign="top" width="45%">デフォルトの値である。
	<b>first</b> は行の先頭、バッファの先頭、そして(可能なら)単語の先頭を表す。
	<b>last</b> は行の最後、バッファの最後、そして(可能なら)単語の最後を表す。
	子表現ドット &quot;.&quot;は改行文字とヌル文字の両方にも一致する。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">match_not_bol</td>
<!--        <td valign="top" width="45%">When this flag is set then <b>first</b>
        does not represent the start of a new line.</td>-->
        <td valign="top" width="45%">このフラグが設定されているとき、
	<b>first</b> は新しい行の先頭を表さない。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">match_not_eol</td>
<!--        <td valign="top" width="45%">When this flag is set then <b>last</b>
        does not represent the end of a line.</td>-->
        <td valign="top" width="45%">このフラグが設定されているとき、
	<b>last</b> は行の最後を表さない。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">match_not_bob</td>
<!--        <td valign="top" width="45%">When this flag is set then <b>first</b>
        is not the beginning of a buffer.</td>-->
        <td valign="top" width="45%">このフラグが設定されているとき、
	<b>first</b> はバッファの始まりを表さない。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">match_not_eob</td>
<!--        <td valign="top" width="45%">When this flag is set then <b>last</b>
        does not represent the end of a buffer.</td>-->
        <td valign="top" width="45%">このフラグが設定されているとき、
	<b>last</b> はバッファの終わりを表さない。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">match_not_bow</td>
<!--        <td valign="top" width="45%">When this flag is set then <b>first</b>
        can never match the start of a word.</td>-->
        <td valign="top" width="45%">このフラグが設定されているとき、
	<b>first</b> は単語の先頭に一致することが出来ない。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">match_not_eow</td>
<!--        <td valign="top" width="45%">When this flag is set then <b>last</b>
        can never match the end of a word.</td>-->
        <td valign="top" width="45%">このフラグが設定されているとき、
	<b>last</b> は単語の終わりに一致することが出来ない。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">match_not_dot_newline</td>
<!--        <td valign="top" width="45%">When this flag is set then a
        dot expression &quot;.&quot; can not match the newline
        character.</td>-->
        <td valign="top" width="45%">このフラグが設定されているとき、
	ドット表現 &quot;.&quot; は改行文字に一致しない</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="45%">match_not_dot_null</td>
<!--        <td valign="top" width="45%">When this flag is set then a
        dot expression &quot;.&quot; can not match a null
        character.</td>-->
        <td valign="top" width="45%">このフラグが設定されているとき、
	ドット表現 &quot;.&quot; はヌル文字に一致しない。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%" height="75">&nbsp;</td>
        <td valign="top" width="45%" height="75">match_prev_avail</td>
<!--        <td valign="top" width="45%" height="75">When this flag
        is set, then *--<b>first</b> is a valid expression and
        the flags match_not_bol and match_not_bow have no effect,
        since the value of the previous character can be used to
        check these.</td>-->
        <td valign="top" width="45%">このフラグが設定されているとき、
	*--<b>first</b> は有効な表現であり、これらを検証するのに前の文字の値が使われるので
	match_not_bol と match_not_bow は作用しない。</td>
        <td width="5%" height="75">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%" height="15">&nbsp;</td>
        <td valign="top" width="45%" height="15">match_any</td>
<!--        <td valign="top" width="45%" height="15">When this flag
        is set, then the first string matched is returned, rather
        than the longest possible match. This flag can
        significantly reduce the time taken to find a match, but
        what matches is undefined.</td>-->
        <td valign="top" width="45%">このフラグが設定されているとき、
	可能な限り長く一致するのではなく、
	一致した最初の文字列が返される。
	このフラグは一致を発見するのにかかる時間を非常に削減するが、
	何が一致するかは未定義である。</td>
        <td width="5%" height="15">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%" height="15">&nbsp;</td>
        <td valign="top" width="45%" height="15">match_not_null</td>
<!--        <td valign="top" width="45%" height="15">When this flag
        is set, then the expression will never match a null
        string.</td>-->
        <td valign="top" width="45%">このフラグが設定されているとき、
	正規表現はヌル文字列には決して一致しない。</td>
        <td width="5%" height="15">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%" height="15">&nbsp;</td>
        <td valign="top" width="45%" height="15">match_continuous</td>
<!--        <td valign="top" width="45%" height="15">When this flags
        is set, then during a grep operation, each successive
        match must start from where the previous match finished.</td>-->
        <td valign="top" width="45%">このフラグが設定されているとき、
	grep 操作の間に、一連の一致はそれぞれ、
	以前の一致が終了した場所から始まる。</td>
        <td width="5%" height="15">&nbsp;</td>
    </tr>
    <tr>
        <td width="5%" height="15">&nbsp;</td>
        <td valign="top" width="45%" height="15">match_partial</td>
<!--        <td valign="top" width="45%" height="15">When this flag
        is set, the regex algorithms will report <a
        href="#partial_matches">partial matches</a> - that is
        where one or more characters at the end of the text input
        matched some prefix of the regular expression.</td>-->
        <td valign="top" width="45%">このフラグが設定されているとき、
	正規表現アルゴリズムは部分一致:
	<a href="#partial_matches">partial matches</a> を報告する。
	これは入力文字列の最後のひとつ以上の文字が、
	正規表現の接頭辞(訳注:入力文字列の最後の任意の部分と、
	正規表現の前からいくつかが一致するということ)
	に一致するということである。
        <td width="5%" height="15">&nbsp;</td>
    </tr>
</table>

<p>&nbsp;</p>

<hr align="right">

<h3><a name="reg_search"></a>Algorithm regex_search</h3>

<p>&nbsp;#include &lt;<a href="../../boost/regex.hpp">boost/regex.hpp</a>&gt;
</p>

<!--<p>The algorithm regex_search will search a range denoted by a
pair of bidirectional-iterators for a given regular expression.
The algorithm uses various heuristics to reduce the search time
by only checking for a match if a match could conceivably start
at that position. The algorithm is defined as follows: </p>-->
<p>アルゴリズム regex_search は一組の双方向イテレータによって示される範囲を、
与えられた正規表現で検索する。
このアルゴリズムは、一致がその位置で始まる可能性があるときのみ、
一致を検証することで、検索時間を削減するために様々な探索的方法を利用する。
このアルゴリズムは次のように定義されている。</p>

<pre><b>template</b> &lt;<b>class</b> iterator, <b>class</b> Allocator, <b>class</b> charT, <b>class</b> traits, <b>class</b> Allocator2&gt;
<b>bool</b> regex_search(iterator first,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match_results&lt;iterator, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = match_default);</pre>

<!--<p>The library also defines the following convenience versions,
which take either a const charT*, or a const std::basic_string&lt;&gt;&amp;
in place of a pair of iterators [note - these versions may not be
available, or may be available in a more limited form, depending
upon your compilers capabilities]: </p>-->
<p>ライブラリは次の簡易版も定義している。
これは 一組のイテレータの代わりに、
const charT* 型か、或いは const std::basic_string&lt;&gt;&amp; 型をとる。
[コンパイラによってはこれらの簡易版は利用できないかもしれないこと、
或いは限られた形でしか利用できないかもしれないことに注意せよ]:</p>

<pre><b>template</b> &lt;<b>class</b> charT, <b>class</b> Allocator, <b>class</b> traits, <b>class</b> Allocator2&gt;
<b>bool</b> regex_search(<b>const</b> charT* str,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match_results&lt;<b>const</b> charT*, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = match_default);

<b>template</b> &lt;<b>class</b> ST, <b>class</b> SA, <b>class</b> Allocator, <b>class</b> charT, <b>class</b> traits, <b>class</b> Allocator2&gt;
<b>bool</b> regex_search(<b>const</b> std::basic_string&lt;charT, ST, SA&gt;&amp; s,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; match_results&lt;<b>typename</b> std::basic_string&lt;charT, ST, SA&gt;::const_iterator, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> reg_expression&lt;charT, traits, Allocator2&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = match_default);</pre>

<!--<p>The parameters for the main function version are as follows: <br>
&nbsp; </p>-->
<p>主要版(訳注:簡易版ではない定義)の関数のパラメータは次の通りである。<br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="50%">iterator first</td>
<!--        <td valign="top" width="50%">The starting position of the
        range to search.</td>-->
        <td valign="top" width="50%">検索範囲の開始位置。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td valign="top" width="50%">iterator last</td>
<!--        <td valign="top" width="50%">The ending position of the
        range to search.</td>-->
        <td valign="top" width="50%">検索範囲の終了位置。</td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td valign="top" width="50%">match_results&lt;iterator,
        Allocator&gt;&amp; m</td>
<!--        <td valign="top" width="50%">An instance of match_results
        in which what matched will be reported. On exit if a
        match occurred then m[0] denotes the whole of the string
        that matched, m[0].first and m[0].second will be less
        than or equal to last. m[1] denotes the first sub-expression
        m[2] the second sub-expression and so on. If no match
        occurred then m[0].first = m[0].second = last.<p>Note
        that since the match_results structure stores only
        iterators, and not strings, the iterators/strings passed
        to regex_search must be valid for as long as the result
        is to be used. For that reason never pass temporary
        string objects to regex_search.</p>-->
        <td valign="top" width="51%">何が一致したかを報告するための
	match_results のインスタンス。関数を抜けるときに、もし一致が起こっていたら
	m[0] は一致した文字列の全体を表す。 m[0].first は first と等しく、
	m[0].second は last より少ないか、等しい。
	m[1] は最初の子表現、 m[2] は2番目の子表現を示し、以下それが続く。
	もし一致が起こらなければ、 m[0].first = m[0].second = last である。
	<p>match_results 構造体はイテレータのみを保持し、文字列を保持していないので、
	regex_search に渡されるイテレータと文字列は、その結果が使われる限り
	有効でなければならないことに注意せよ。このため、決して一時的文字列オブジェクトを
	regex_search に渡してはならない。</p>
        </td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td valign="top" width="50%">const
        reg_expression&lt;charT, traits, Allocator2&gt;&amp; e</td>
<!--        <td valign="top" width="50%">The regular expression to
        search for.</td>-->
        <td valign="top" width="50%">検索に使われる正規表現。</td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td valign="top" width="50%">unsigned flags =
        match_default</td>
<!--        <td valign="top" width="50%">The flags that determine
        what gets matched, a combination of one or more <a
        href="#match_type">match_flags</a> enumerators.</td>-->
        <td valign="top" width="50%">何が一致するかを決定するフラグ。
	<a href="#match_type">match_flags</a> 列挙子のひとつ以上の組み合わせ。</td>
        <td>&nbsp;</td>
    </tr>
</table>

<p><br>
&nbsp; </p>

<!--<p>Example: the following <a
href="example/snippets/regex_search_example.cpp">example</a>,
takes the contents of a file in the form of a string, and
searches for all the C++ class declarations in the file. The code
will work regardless of the way that std::string is implemented,
for example it could easily be modified to work with the SGI rope
class, which uses a non-contiguous storage strategy. </p>-->
<p>次の例: <a href="example/snippets/regex_search_example.cpp">example</a>
は文字列の形でファイルの内容を受け取り、ファイルの中の全ての C++ クラス宣言を検索する。
コードは std::string がどのように実装されていようが動く。
例えば 不連続の保持(訳注: コンテナの要素がメモリ上で連続していないこと)を使っている
SGI rope クラスでこれが動くように簡単に変更できる。</p>

<pre><font color="#008000">#include &lt;string&gt; 
#include &lt;map&gt; 
#include &lt;boost/regex.hpp&gt; 
</font><font color="#000080"><i>
// purpose: 
// takes the contents of a file in the form of a string 
// and searches for all the C++ class definitions, storing 
// their locations in a map of strings/int's 
</i></font><b>typedef</b> std::map&lt;std::string, <b>int</b>, std::less&lt;std::string&gt; &gt; map_type; 

boost::regex expression(&quot;^(template[[:space:]]*&lt;[^;:{]+&gt;[[:space:]]*)?(class|struct)[[:space:]]*(\\&lt;\\w+\\&gt;([[:blank:]]*\\([^)]*\\))?[[:space:]]*)*(\\&lt;\\w*\\&gt;)[[:space:]]*(&lt;[^;:{]+&gt;[[:space:]]*)?(\\{|:[^;\\{()]*\\{)&quot;); 
<b>
void</b> IndexClasses(map_type&amp; m, <b>const</b> std::string&amp; file) 
{ 
&nbsp;&nbsp; std::string::const_iterator start, end; 
&nbsp;&nbsp; start = file.begin(); 
&nbsp;&nbsp; end = file.end();&nbsp;
&nbsp;&nbsp; &nbsp;&nbsp; boost::match_results&lt;std::string::const_iterator&gt; what; 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> flags = boost::match_default; 
&nbsp;&nbsp; <b>while</b>(regex_search(start, end, what, expression, flags))&nbsp;
&nbsp;&nbsp; { 
<font color="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>// what[0] contains the whole string 
</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>// what[5] contains the class name. 
</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>// what[6] contains the template specialisation if any. 
</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>// add class name and position to map: 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] =&nbsp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; what[5].first - file.begin();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#000080"><i>// update search position: 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start = what[0].second;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#000080"><i>// update flags: 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags |= boost::match_prev_avail;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flags |= boost::match_not_bob;&nbsp;
&nbsp;&nbsp; } 
}
 </pre>

<hr>

<h3><a name="reg_grep"></a>Algorithm regex_grep</h3>

<p>#include &lt;<a href="../../boost/regex.hpp">boost/regex.hpp</a>&gt;
</p>

<!--<p>&nbsp;Regex_grep allows you to search through a bidirectional-iterator
range and locate all the (non-overlapping) matches with a given
regular expression. The function is declared as: </p>-->
<p>&nbsp;Regex_grep は、双方向イテレータの範囲を最初から最後まで検索し、
与えられた正規表現との全ての(重ならない)一致を発見する。
この関数は次のように宣言されている:</p>

<pre><b>template</b> &lt;<b>class</b> Predicate, <b>class</b> iterator, <b>class</b> charT, <b>class</b> traits, <b>class</b> Allocator&gt;
<b>unsigned</b> <b>int</b> regex_grep(Predicate foo,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator first,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last,&nbsp;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const</b> reg_expression&lt;charT, traits, Allocator&gt;&amp; e,&nbsp;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned</b> flags = match_default)</pre>

<!--<p>The library also defines the following convenience versions,
which take either a const charT*, or a const std::basic_string&lt;&gt;&amp;
in place of a pair of iterators [note - these versions may not be
available, or may be available in a more limited form, depending
upon your compilers capabilities]: </p>-->
<p>ライブラリは次の簡易版も定義している。
これは 一組のイテレータの代わりに、
const charT* 型か、或いは const std::basic_string&lt;&gt;&amp; 型をとる。
[コンパイラによってはこれらの簡易版は利用できないかもしれないこと、
或いは限られた形でしか利用できないかもしれないことに注意せよ]:</p>

<pre><b>template</b> &lt;<b>class</b> Predicate, <b>class</b> charT, <b>class</b> Allocator, <b>class</b> traits&gt;
<b>unsigned</b> <b>int</b> regex_grep(Predicate foo,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> charT* str,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> reg_expression&lt;charT, traits, Allocator&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = match_default);

<b>template</b> &lt;<b>class</b> Predicate, <b>class</b> ST, <b>class</b> SA, <b>class</b> Allocator, <b>class</b> charT, <b>class</b> traits&gt;
<b>unsigned</b> <b>int</b> regex_grep(Predicate foo,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> std::basic_string&lt;charT, ST, SA&gt;&amp; s,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> reg_expression&lt;charT, traits, Allocator&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = match_default);</pre>

<!--<p>The parameters for the primary version of regex_grep have the
following meanings: <br>
&nbsp; </p>-->
<p>主要版(訳注:簡易版ではない定義)の関数のパラメータは次の通りである。<br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="624">
    <tr>
        <td width="5%">&nbsp;</td>
        <td valign="top" width="50%">foo</td>
<!--        <td valign="top" width="50%">A predicate function object
        or function pointer, see below for more information.</td>-->
        <td valign="top" width="50%">述語関数オブジェクトや関数ポインタ。
	より詳しい情報は下を見よ。</td>
        <td width="5%">&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td valign="top" width="50%">first</td>
<!--        <td valign="top" width="50%">The start of the range to
        search.</td>-->
        <td valign="top" width="50%">検索範囲の先頭。</td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td valign="top" width="50%">last</td>
<!--        <td valign="top" width="50%">The end of the range to
        search.</td>-->
        <td valign="top" width="50%">検索範囲の末端。</td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td valign="top" width="50%">e</td>
<!--        <td valign="top" width="50%">The regular expression to
        search for.</td>-->
        <td valign="top" width="50%">検索のための正規表現。</td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td valign="top" width="50%">flags</td>
<!--        <td valign="top" width="50%">The flags that determine how
        matching is carried out, one of the <a href="#match_type">match_flags</a>
        enumerators.</td>-->
        <td valign="top" width="50%">どのように一致が行われるかを決定するフラグ。
        <a href="#match_type">match_flags</a> 列挙子のひとつ。</td>
        <td>&nbsp;</td>
    </tr>
</table>

<!--<p>&nbsp;The algorithm finds all of the non-overlapping matches
of the expression e, for each match it fills a <a
href="#reg_match">match_results</a>&lt;iterator, Allocator&gt;
structure, which contains information on what matched, and calls
the predicate foo, passing the match_results&lt;iterator,
Allocator&gt; as a single argument. If the predicate returns
true, then the grep operation continues, otherwise it terminates
without searching for further matches. The function returns the
number of matches found.</p>-->
<p>&nbsp;このアルゴリズムは、正規表現 e に対する、
重ならない全ての一致を発見する。それぞれの一致で、
<a href="#reg_match">match_results</a>&lt;iterator, Allocator&gt;
構造体に情報が入る。これは何が一致したかについての情報を保持し、
述語関数 foo を呼び出し、ひとつの引数として
 match_results&lt;iterator,Allocator&gt; を渡す。
もし述語関数が true を返せば grep 操作は引き続き行われる。
そうでなければ grep 操作はそれ以降の一致を検索することなく終了する。
この関数は、発見された一致の数を返す。</p>

<!--<p>The general form of the predicate is: </p>-->
<p>述語関数の一般的な形式は以下の通りである: </p>

<pre><b>struct</b> grep_predicate
{
<b>&nbsp;&nbsp; bool</b> <b>operator</b>()(<b>const</b> match_results&lt;iterator_type, expression_type::alloc_type&gt;&amp; m);
};</pre>

<!--<p>For example the regular expression &quot;a*b&quot; would find
one match in the string &quot;aaaaab&quot; and two in the string
&quot;aaabb&quot;. </p>-->
<p>例えば、正規表現 &quot;a*b&quot; は文字列 &quot;aaaaab&quot; 
の中でひとつの一致を発見し、文字列 &quot;aaabb&quot; 
の中に二つの一致を発見する。</p>

<!--<p>Remember this algorithm can be used for a lot more than
implementing a version of grep, the predicate can be and do
anything that you want, grep utilities would output the results
to the screen, another program could index a file based on a
regular expression and store a set of bookmarks in a list, or a
text file conversion utility would output to file. The results of
one regex_grep can even be chained into another regex_grep to
create recursive parsers. </p>-->
<p>このアルゴリズムは、grep の実装よりも多くのことに使うことが出来ることを覚えておくこと。
述語関数があるので、やりたいことはそこで何でも出来る。
grep ユーティリティは結果を画面に出力する。
別のプログラムは正規表現に基づいてファイルを索引付けし、ブックマークの集合を
リストに蓄えることが出来る。
テキストファイル変換ユーティリティはファイルに出力する。
再帰的な解析のために、
ひとつの regex_grep の結果を別の regex_grep に連鎖することさえ可能である。</p>

<!--<p><a href="example/snippets/regex_grep_example_1.cpp">Example</a>:
convert the example from <i>regex_search</i> to use <i>regex_grep</i>
instead: </p>-->
<p><a href="example/snippets/regex_grep_example_1.cpp">Example</a>:
<i>regex_search</i> の例を、代わりに <i>regex_grep</i> を使って変換している:</p>

<pre><font color="#008000">#include &lt;string&gt; 
#include &lt;map&gt; 
#include &lt;boost/regex.hpp&gt; 

</font><font color="#000080"><i>// IndexClasses: 
// takes the contents of a file in the form of a string 
// and searches for all the C++ class definitions, storing 
// their locations in a map of strings/int's 
</i></font><b>
typedef</b> std::map&lt;std::string, <b>int</b>, std::less&lt;std::string&gt; &gt; map_type; 

boost::regex expression(<font color="#000080">&quot;^(template[[:space:]]*&lt;[^;:{]+&gt;[[:space:]]*)?&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;(class|struct)[[:space:]]*(\\&lt;\\w+\\&gt;([[:blank:]]*\\([^)]*\\))?[[:space:]]*)*(\\&lt;\\w*\\&gt;)&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;[[:space:]]*(&lt;[^;:{]+&gt;[[:space:]]*)?(\\{|:[^;\\{()]*\\{)&quot;</font>); 
<b>
class</b> IndexClassesPred 
{ 
&nbsp;&nbsp; map_type&amp; m; 
&nbsp;&nbsp; std::string::const_iterator base; 
<b>public</b>: 
&nbsp;&nbsp; IndexClassesPred(map_type&amp; a, std::string::const_iterator b) : m(a), base(b) {} 
&nbsp;&nbsp; <b>bool</b> <b>operator</b>()(<b>const</b> match_results&lt;std::string::const_iterator, regex::alloc_type&gt;&amp; what) 
&nbsp;&nbsp; { 
<font color="#000080">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>// what[0] contains the whole string 
</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>// what[5] contains the class name. 
</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>// what[6] contains the template specialisation if any. 
</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i>// add class name and position to map: 
</i></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] =&nbsp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; what[5].first - base; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>return</b> <b>true</b>; 
&nbsp;&nbsp; } 
}; 
<b>
void</b> IndexClasses(map_type&amp; m, <b>const</b> std::string&amp; file) 
{ 
&nbsp;&nbsp; std::string::const_iterator start, end; 
&nbsp;&nbsp; start = file.begin(); 
&nbsp;&nbsp; end = file.end(); 
&nbsp;&nbsp; regex_grep(IndexClassesPred(m, start), start, end, expression); 
} </pre>

<!--<p><a href="example/snippets/regex_grep_example_2.cpp">Example</a>:
Use regex_grep to call a global callback function: </p>-->
<p><a href="example/snippets/regex_grep_example_2.cpp">Example</a>:
グローバルコールバック関数呼び出しに regex_grep を使っている:</p>

<pre><font color="#008000">#include &lt;string&gt; 
#include &lt;map&gt; 
#include &lt;boost/regex.hpp&gt; 

</font><font color="#000080"><i>// purpose: 
// takes the contents of a file in the form of a string 
// and searches for all the C++ class definitions, storing 
// their locations in a map of strings/int's 
</i></font><b>
typedef</b> std::map&lt;std::string, <b>int</b>, std::less&lt;std::string&gt; &gt; map_type; 

boost::regex expression(<font color="#000080">&quot;^(template[[:space:]]*&lt;[^;:{]+&gt;[[:space:]]*)?(class|struct)[[:space:]]*(\\&lt;\\w+\\&gt;([[:blank:]]*\\([^)]*\\))?[[:space:]]*)*(\\&lt;\\w*\\&gt;)[[:space:]]*(&lt;[^;:{]+&gt;[[:space:]]*)?(\\{|:[^;\\{()]*\\{)&quot;</font>); 

map_type class_index; 
std::string::const_iterator base; 

<b>bool</b> grep_callback(<b>const</b> boost::match_results&lt;std::string::const_iterator, boost::regex::alloc_type&gt;&amp; what) 
{ 
<font color="#000080">&nbsp;&nbsp; <i>// what[0] contains the whole string 
</i>&nbsp;&nbsp; <i>// what[5] contains the class name. 
</i>&nbsp;&nbsp; <i>// what[6] contains the template specialisation if any. 
</i>&nbsp;&nbsp; <i>// add class name and position to map: 
</i></font>&nbsp;&nbsp; class_index[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] =&nbsp;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; what[5].first - base; 
&nbsp;&nbsp; <b>return</b> <b>true</b>; 
} 
<b>
void</b> IndexClasses(<b>const</b> std::string&amp; file) 
{ 
&nbsp;&nbsp; std::string::const_iterator start, end; 
&nbsp;&nbsp; start = file.begin(); 
&nbsp;&nbsp; end = file.end(); 
&nbsp;&nbsp; base = start; 
&nbsp;&nbsp; regex_grep(grep_callback, start, end, expression, match_default); 
}
&nbsp; </pre>

<!--<p><a href="example/snippets/regex_grep_example_3.cpp">Example</a>:
use regex_grep to call a class member function, use the standard
library adapters <i>std::mem_fun</i> and <i>std::bind1st</i> to
convert the member function into a predicate: </p>-->
<p><a href="example/snippets/regex_grep_example_3.cpp">Example</a>:
regex_grep を使ってクラスメンバ関数を呼び出している。
標準ライブラリアダプタ <i>std::mem_fun</i> と <i>std::bind1st</i>
はメンバ関数を述語関数に変換するために使われている。</p>

<pre><font color="#008000">#include &lt;string&gt; 
#include &lt;map&gt; 
#include &lt;boost/regex.hpp&gt; 
#include &lt;functional&gt; 
</font><font color="#000080"><i>
// purpose: 
// takes the contents of a file in the form of a string 
// and searches for all the C++ class definitions, storing 
// their locations in a map of strings/int's 

</i></font><b>typedef</b> std::map&lt;std::string, <b>int</b>, std::less&lt;std::string&gt; &gt; map_type; 
<b>
class</b> class_index 
{ 
&nbsp;&nbsp; boost::regex expression; 
&nbsp;&nbsp; map_type index; 
&nbsp;&nbsp; std::string::const_iterator base; 
&nbsp;&nbsp; <b>bool</b> grep_callback(boost::match_results&lt;std::string::const_iterator, boost::regex::alloc_type&gt; what); 
<b>public</b>: 
<b>&nbsp;&nbsp; void</b> IndexClasses(<b>const</b> std::string&amp; file); 
&nbsp;&nbsp; class_index() 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : index(), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression(<font
color="#000080">&quot;^(template[[:space:]]*&lt;[^;:{]+&gt;[[:space:]]*)?&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;(class|struct)[[:space:]]*(\\&lt;\\w+\\&gt;([[:blank:]]*\\([^)]*\\))?&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;[[:space:]]*)*(\\&lt;\\w*\\&gt;)[[:space:]]*(&lt;[^;:{]+&gt;[[:space:]]*)?&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;(\\{|:[^;\\{()]*\\{)&quot; 
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ){} 
}; 
<b>
bool</b> class_index::grep_callback(boost::match_results&lt;std::string::const_iterator, boost::regex::alloc_type&gt; what) 
{ 
<font color="#000080">&nbsp;&nbsp; <i>// what[0] contains the whole string 
</i>&nbsp;&nbsp; <i>// what[5] contains the class name. 
</i>&nbsp;&nbsp; <i>// what[6] contains the template specialisation if any. 
</i>&nbsp;&nbsp; <i>// add class name and position to map: 
</i></font>&nbsp;&nbsp; index[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] = 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; what[5].first - base; 
&nbsp;&nbsp; <b>return</b> <b>true</b>; 
} 

<b>void</b> class_index::IndexClasses(<b>const</b> std::string&amp; file) 
{ 
&nbsp;&nbsp; std::string::const_iterator start, end; 
&nbsp;&nbsp; start = file.begin(); 
&nbsp;&nbsp; end = file.end(); 
&nbsp;&nbsp; base = start; 
&nbsp;&nbsp; regex_grep(std::bind1st(std::mem_fun(&amp;class_index::grep_callback), <b>this</b>), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   start, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   end, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   expression); 
} 
&nbsp; </pre>

<!--<p><a href="example/snippets/regex_grep_example_4.cpp">Finally</a>,
C++ Builder users can use C++ Builder's closure type as a
callback argument: </p>-->
<p><a href="example/snippets/regex_grep_example_4.cpp">最後に</a>、
C++ Builder のユーザは C++ Builder のクロージャ型をコールバック引数として使うことが出来る。</p>

<pre><font color="#008000">#include &lt;string&gt; 
#include &lt;map&gt; 
#include &lt;boost/regex.hpp&gt; 
#include &lt;functional&gt; 
</font><font color="#000080"><i>
// purpose: 
// takes the contents of a file in the form of a string 
// and searches for all the C++ class definitions, storing 
// their locations in a map of strings/int's 

</i></font><b>typedef</b> std::map&lt;std::string, <b>int</b>, std::less&lt;std::string&gt; &gt; map_type; 
<b>class</b> class_index 
{ 
&nbsp;&nbsp; boost::regex expression; 
&nbsp;&nbsp; map_type index; 
&nbsp;&nbsp; std::string::const_iterator base; 
&nbsp;&nbsp; <b>typedef</b> boost::match_results&lt;std::string::const_iterator, boost::regex::alloc_type&gt; arg_type; 
&nbsp;&nbsp; <b>bool</b> grep_callback(<b>const</b> arg_type&amp; what); 
<b>public</b>: 
&nbsp;&nbsp; <b>typedef</b> <b>bool</b> (<b>__closure</b>* grep_callback_type)(<b>const</b> arg_type&amp;); 
&nbsp;&nbsp; <b>void</b> IndexClasses(<b>const</b> std::string&amp; file); 
&nbsp;&nbsp; class_index() 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : index(), 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression(<font
color="#000080">&quot;^(template[[:space:]]*&lt;[^;:{]+&gt;[[:space:]]*)?&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;(class|struct)[[:space:]]*(\\&lt;\\w+\\&gt;([[:blank:]]*\\([^)]*\\))?&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;[[:space:]]*)*(\\&lt;\\w*\\&gt;)[[:space:]]*(&lt;[^;:{]+&gt;[[:space:]]*)?&quot; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;(\\{|:[^;\\{()]*\\{)&quot; 
</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ){} 
}; 

<b>bool</b> class_index::grep_callback(<b>const</b> arg_type&amp; what) 
{ 
<font color="#000080">&nbsp;&nbsp; <i>// what[0] contains the whole string </i>&nbsp;&nbsp; 
<i>// what[5] contains the class name. </i>&nbsp;&nbsp; 
<i>// what[6] contains the template specialisation if any. </i>&nbsp;&nbsp; 
<i>// add class name and position to map: </i></font>&nbsp;&nbsp; 
index[std::string(what[5].first, what[5].second) + std::string(what[6].first, what[6].second)] = 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; what[5].first - base; 
&nbsp;&nbsp; <b>return</b> <b>true</b>; 
} 

<b>void</b> class_index::IndexClasses(<b>const</b> std::string&amp; file) 
{ 
&nbsp;&nbsp; std::string::const_iterator start, end; 
&nbsp;&nbsp; start = file.begin(); 
&nbsp;&nbsp; end = file.end(); 
&nbsp;&nbsp; base = start; 
&nbsp;&nbsp; class_index::grep_callback_type cl = &amp;(<b>this</b>-&gt;grep_callback); 
&nbsp;&nbsp; regex_grep(cl, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; start, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expression); 
} </pre>

<hr>

<h3>&nbsp;<a name="reg_format"></a>Algorithm regex_format</h3>

<p>#include &lt;<a href="../../boost/regex.hpp">boost/regex.hpp</a>&gt;
</p>

<!--<p>The algorithm regex_format takes the results of a match and
creates a new string based upon a <a
href="format_string.htm#format_string">format string</a>,
regex_format can be used for search and replace operations: </p>-->
<p>アルゴリズム regex_format は一致の結果を受け取り、
<a href="format_string.htm#format_string">書式指定子</a>
に基づいて新しい文字列を作成する。
regex_format は検索と置換の操作の為に使うことが出来る:</p>

<pre><b>template</b> &lt;<b>class</b> OutputIterator, <b>class</b> iterator, <b>class</b> Allocator, <b>class</b> charT&gt;
OutputIterator regex_format(OutputIterator out,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> match_results&lt;iterator, Allocator&gt;&amp; m,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> charT* fmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = 0);
<b>
template</b> &lt;<b>class</b> OutputIterator, <b>class</b> iterator, <b>class</b> Allocator, <b>class</b> charT&gt;
OutputIterator regex_format(OutputIterator out,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> match_results&lt;iterator, Allocator&gt;&amp; m,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> std::basic_string&lt;charT&gt;&amp; fmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = 0);</pre>

<!--<p>The library also defines the following convenience variation
of regex_format, which returns the result directly as a string,
rather than outputting to an iterator [note - this version may
not be available, or may be available in a more limited form,
depending upon your compilers capabilities]: </p>-->
<p>ライブラリは次のような regex_format の簡易版も用意している。
これは結果を、イテレータに出力するのではなく、文字列として直接返す。
[注意: この簡易版はコンパイラによっては使えないか、使えても機能が限られているかもしれない。]</p>

<pre><b>template</b> &lt;<b>class</b> iterator, <b>class</b> Allocator, <b>class</b> charT&gt;
std::basic_string&lt;charT&gt; regex_format
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b>const</b> match_results&lt;iterator, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> charT* fmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = 0);

<b>template</b> &lt;<b>class</b> iterator, <b>class</b> Allocator, <b>class</b> charT&gt;
std::basic_string&lt;charT&gt; regex_format
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (<b>const</b> match_results&lt;iterator, Allocator&gt;&amp; m,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> std::basic_string&lt;charT&gt;&amp; fmt,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = 0);</pre>

<!--<p>Parameters to the main version of the function are passed as
follows: <br>
&nbsp; </p>-->
<p>主要版の関数に渡されるパラメータは次の通りである。<br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top" width="9%">&nbsp;</td>
        <td valign="top" width="39%">OutputIterator out</td>
<!--        <td valign="top" width="44%">An output iterator type, the
        output string is sent to this iterator. Typically this
        would be a std::ostream_iterator.</td>-->
        <td valign="top" width="44%">出力イテレータ型。
	出力文字列はこのイテレータに送られる。
	通常は std::ostream_iterator である。</td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="9%">&nbsp;</td>
        <td valign="top" width="39%"><b>const</b>
        match_results&lt;iterator, Allocator&gt;&amp; m</td>
<!--        <td valign="top" width="44%">An instance of
        match_results&lt;&gt; obtained from one of the matching
        algorithms above, and denoting what matched.</td>-->
        <td valign="top" width="44%">match_result&lt;&gt; のインスタンス。
	これは上の一致判定アルゴリズムのうちのひとつから得られ、
	何が一致したを表す。</td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="9%">&nbsp;</td>
        <td valign="top" width="39%"><b>const</b> charT* fmt</td>
<!--        <td valign="top" width="44%">A format string that
        determines how the match is transformed into the new
        string.</td>-->
        <td valign="top" width="44%">一致がどのように新しい文字列に変換されるかを
	決定する書式指定子。</td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="9%">&nbsp;</td>
        <td valign="top" width="39%"><b>unsigned</b> flags</td>
<!--        <td valign="top" width="44%">Optional flags which
        describe how the format string is to be interpreted.</td>-->
        <td valign="top" width="44%">書式指定子がどのように解釈されるかを示す、
	オプションのフラグ。</td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
</table>

<!--<p><a name="format_flags"></a>Format flags are defined as follows:
<br>
&nbsp; </p>-->
<p><a name="format_flags"></a>書式のフラグは以下のように定義されている。<br>
<br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top" width="9%">&nbsp;</td>
        <td valign="top" width="39%">format_all</td>
<!--        <td valign="top" width="43%">Enables all syntax options (perl-like
        plus extentions).</td>-->
        <td valign="top" width="43%">すべての構文のオプションを可能にする。
	(拡張正規表現構文に加え perl-like の構文も可能)。</td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="9%">&nbsp;</td>
        <td valign="top" width="39%">format_sed</td>
<!--        <td valign="top" width="43%">Allows only a sed-like
        syntax.</td>-->
        <td valign="top" width="43%">sed-like の構文のみ許す。</td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="9%">&nbsp;</td>
        <td valign="top" width="39%">format_perl</td>
<!--        <td valign="top" width="43%">Allows only a perl-like
        syntax.</td>-->
        <td valign="top" width="43%">perl-like の構文のみ許す。</td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="9%">&nbsp;</td>
        <td valign="top" width="39%">format_no_copy</td>
<!--        <td valign="top" width="43%">Disables copying of
        unmatched sections to the output string during <a
        href="#reg_merge">regex_merge</a> operations.</td>-->
        <td valign="top" width="43%"><a href="#reg_merge">regex_merge</a> 
	操作の間に、一致しなかった部分を出力文字列にコピーできなくする。</td>
        <td valign="top" width="9%">&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td>format_first_only</td>
<!--        <td>When this flag is set only the first occurance will
        be replaced (applies to regex_merge only).</td>-->
        <td>このフラグが設定されているときは、最初の一致だけが置換される。
	(regex_merge だけに適用される。)</td>
        <td>&nbsp;</td>
    </tr>
</table>

<p><br>
&nbsp; </p>

<!--<p>The format string syntax (and available options) is described
more fully under <a href="format_string.htm#format_string">format
strings</a>. </p>-->
<p>書式指定子の構文(そして利用可能なオプション)は
<a href="format_string.htm#format_string">書式指定子</a> 
でより完全に書かれている。 </p>

<hr>

<h3><a name="reg_merge"></a>Algorithm regex_merge</h3>

<p>#include &lt;<a href="../../boost/regex.hpp">boost/regex.hpp</a>&gt;
</p>

<!--<p>The algorithm regex_merge is a combination of <a
href="#reg_grep">regex_grep</a> and <a href="#reg_format">regex_format</a>.
That is, it greps through the string finding all the matches to
the regular expression, for each match it then calls <a
href="#reg_format">regex_format</a> to format the string and
sends the result to the output iterator. Sections of text that do
not match are copied to the output unchanged only if the flags
parameter does not have the flag <a href="#format_flags">format_no_copy</a>
set. If the flag <a href="#format_flags">format_first_only</a> is
set then only the first occurance is replaced rather than all
occurrences.</p>-->
<p>アルゴリズム regex_merge は
<a href="#reg_grep">regex_grep</a> と <a href="#reg_format">regex_format</a>
を組み合わせたものである。
つまり、文字列の最初から最後まで、正規表現との全ての一致を発見し、
その一致それぞれに対して、文字列を書式化するために
<a href="#reg_format">regex_format</a> を呼び出し、
結果を出力イテレータに送る。一致しなかった部分のテキストは
フラグパラメータ <a href="#format_flags">format_no_copy</a>
が設定されていなければ、変更されることなく出力される。
<a href="#format_flags">format_first_only</a>
が設定されていれば、全ての一致ではなく、最初の一致だけが置換される。</p>

<pre><b>template</b> &lt;<b>class</b> OutputIterator, <b>class</b> iterator, <b>class</b> traits, <b>class</b> Allocator, <b>class</b> charT&gt;
OutputIterator regex_merge(OutputIterator out,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>const</b> reg_expression&lt;charT, traits, Allocator&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>const</b> charT* fmt,&nbsp;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned</b> <b>int</b> flags = match_default);

<b>template</b> &lt;<b>class</b> OutputIterator, <b>class</b> iterator, <b>class</b> traits, <b>class</b> Allocator, <b>class</b> charT&gt;
OutputIterator regex_merge(OutputIterator out,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator first,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iterator last,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>const</b> reg_expression&lt;charT, traits, Allocator&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::basic_string&lt;charT&gt;&amp; fmt,&nbsp;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned</b> <b>int</b> flags = match_default);</pre>

<!--<p>The library also defines the following convenience variation
of regex_merge, which returns the result directly as a string,
rather than outputting to an iterator [note - this version may
not be available, or may be available in a more limited form,
depending upon your compilers capabilities]: </p>-->
<p>このライブラリは次のような regex_merge の簡易版も定義している。
これは、イテレータに出力するのではなく、結果を文字列として直接返す。
[注意：コンパイラによってはこの簡易版は利用できないか、利用できても
限られた形でしか使えない。]</p>

<pre><b>template</b> &lt;<b>class</b> traits, <b>class</b> Allocator, <b>class</b> charT&gt;
std::basic_string&lt;charT&gt; regex_merge(<b>const</b> std::basic_string&lt;charT&gt;&amp; text,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>const</b> reg_expression&lt;charT, traits, Allocator&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>const</b> charT* fmt,&nbsp;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned</b> <b>int</b> flags = match_default);

<b>template</b> &lt;<b>class</b> traits, <b>class</b> Allocator, <b>class</b> charT&gt;
std::basic_string&lt;charT&gt; regex_merge(<b>const</b> std::basic_string&lt;charT&gt;&amp; text,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>const</b> reg_expression&lt;charT, traits, Allocator&gt;&amp; e,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>const</b> std::basic_string&lt;charT&gt;&amp; fmt,&nbsp;
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned</b> <b>int</b> flags = match_default);</pre>

<!--<p>Parameters to the main version of the function are passed as
follows: <br>
&nbsp; </p>-->
<p>主要版の関数に渡されるパラメータは次の通りである:<br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="40%">OutputIterator out</td>
<!--        <td valign="top" width="45%">An output iterator type, the
        output string is sent to this iterator. Typically this
        would be a std::ostream_iterator.</td>-->
        <td valign="top" width="45%">出力イテレータ型。
	通常は std::ostream_iterator である。</td>
        <td valign="top" width="8%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="40%">iterator first</td>
<!--        <td valign="top" width="45%">The start of the range of
        text to grep (bidirectional-iterator).</td>-->
        <td valign="top" width="45%">検索するテキストの範囲の最初。
	(双方向イテレータ)</td>
        <td valign="top" width="8%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="40%">iterator last</td>
<!--        <td valign="top" width="45%">The end of the range of text
        to grep (bidirectional-iterator).</td>-->
        <td valign="top" width="45%">検索するテキストの範囲の最後。
	(双方向イテレータ)</td>
        <td valign="top" width="8%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="40%"><b>const</b>
        reg_expression&lt;charT, traits, Allocator&gt;&amp; e</td>
<!--        <td valign="top" width="45%">The expression to search for.</td>-->
        <td valign="top" width="45%">検索のための正規表現</td>
        <td valign="top" width="8%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="40%"><b>const</b> charT* fmt</td>
<!--        <td valign="top" width="45%">The format string to be
        applied to sections of text that match.</td>-->
        <td valign="top" width="45%">一致した部分のテキストに適用される書式指定子。</td>
        <td valign="top" width="8%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="40%"><b>unsigned</b> <b>int</b>
        flags = match_default</td>
<!--        <td valign="top" width="45%">Flags which determine how
        the expression is matched - see <a href="#match_type">match_flags</a>,
        and how the format string is interpreted - see <a
        href="#format_flags">format_flags</a>.</td>-->
        <td valign="top" width="45%">正規表現がどのように一致するかを決定するフラグ。
	<a href="#match_type">match_flags</a> を見よ。
	また、書式指定子がどのように解釈されるかを決定するフラグ。
        <a href="#format_flags">format_flags</a> を見よ。</td>
        <td valign="top" width="8%">&nbsp;</td>
    </tr>
</table>

<!--<p>Example: the following <a
href="example/snippets/regex_merge_example.cpp">example</a> takes
C/C++ source code as input, and outputs syntax highlighted HTML
code. </p>-->
<p>次 <a href="example/snippets/regex_merge_example.cpp">例</a> は
C/C++ のソースコードをインプットとして受け取り、
構文が強調された HTML コードを出力する。</p>

<pre>
<font color="#008080">#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;iterator&gt;
#include &lt;boost/regex.hpp&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
</font>
<font color="#000080"><i>// purpose:
// takes the contents of a file and transform to
// syntax highlighted code in html format
</i></font>
boost::regex e1, e2;
<b>extern</b> <b>const</b> <b>char</b>* expression_text;
<b>extern</b> <b>const</b> <b>char</b>* format_string;
<b>extern</b> <b>const</b> <b>char</b>* pre_expression;
<b>extern</b> <b>const</b> <b>char</b>* pre_format;
<b>extern</b> <b>const</b> <b>char</b>* header_text;
<b>extern</b> <b>const</b> <b>char</b>* footer_text;

<b>void</b> load_file(std::string&amp; s, std::istream&amp; is)
{
   s.erase();
   s.reserve(is.rdbuf()-&gt;in_avail());
   <b>char</b> c;
   <b>while</b>(is.get(c))
   {
      <b>if</b>(s.capacity() == s.size())
         s.reserve(s.capacity() * <font color="#000080">3</font>);
      s.append(<font color="#000080">1</font>, c);
   }
}

<b>int</b> main(<b>int</b> argc, <b>const</b> <b>char</b>** argv)
{
   try{
   e1.assign(expression_text);
   e2.assign(pre_expression);
   <b>for</b>(<b>int</b> i = <font color="#000080">1</font>; i &lt; argc; ++i)
   {
      std::cout &lt;&lt; <font color="#0000FF">&quot;Processing file &quot;</font> &lt;&lt; argv[i] &lt;&lt; std::endl;
      std::ifstream fs(argv[i]);
      std::string in;
      load_file(in, fs);
      std::string out_name(std::string(argv[i]) + std::string(<font
color="#0000FF">&quot;.htm&quot;</font>));
      std::ofstream os(out_name.c_str());
      os &lt;&lt; header_text;
      <font color="#000080"><i>// strip '&lt;' and '&gt;' first by outputting to a
</i></font>      <font color="#000080"><i>// temporary string stream
</i></font>      std::ostringstream t(std::ios::out | std::ios::binary);
      std::ostream_iterator&lt;<b>char</b>, <b>char</b>&gt; oi(t);
      boost::regex_merge(oi, in.begin(), in.end(), e2, pre_format);
      <font color="#000080"><i>// then output to final output stream
</i></font>      <font color="#000080"><i>// adding syntax highlighting:
</i></font>      std::string s(t.str());
      std::ostream_iterator&lt;<b>char</b>, <b>char</b>&gt; out(os);
      boost::regex_merge(out, s.begin(), s.end(), e1, format_string);
      os &lt;&lt; footer_text;
   }
   }
   <strong>catch</strong>(...)
   { <strong>return</strong> -1; }
   <b>return</b> <font color="#000080">0</font>;
}

<b>extern</b> <b>const</b> <b>char</b>* pre_expression = <font
color="#0000FF">&quot;(&lt;)|(&gt;)|\\r&quot;</font>;
<b>extern</b> <b>const</b> <b>char</b>* pre_format = <font
color="#0000FF">&quot;(?1&lt;)(?2&gt;)&quot;</font>;


<b>const</b> <b>char</b>* expression_text = <font color="#000080"><i>// preprocessor directives: index 1
</i></font>                              <font color="#0000FF">&quot;(^[[:blank:]]*#(?:[^\\\\\\n]|\\\\[^\\n[:punct:][:word:]]*[\\n[:punct:][:word:]])*)|&quot;
</font>                              <font color="#000080"><i>// comment: index 2
</i></font>                              <font color="#0000FF">&quot;(//[^\\n]*|/\\*.*?\\*/)|&quot;
</font>                              <font color="#000080"><i>// literals: index 3
</i></font>                              <font color="#0000FF">&quot;\\&lt;([+-]?(?:(?:0x[[:xdigit:]]+)|(?:(?:[[:digit:]]*\\.)?[[:digit:]]+(?:[eE][+-]?[[:digit:]]+)?))u?(?:(?:int(?:8|16|32|64))|L)?)\\&gt;|&quot;
</font>                              <font color="#000080"><i>// string literals: index 4
</i></font>                              <font color="#0000FF">&quot;('(?:[^\\\\']|\\\\.)*'|\&quot;(?:[^\\\\\&quot;]|\\\\.)*\&quot;)|&quot;
</font>                              <font color="#000080"><i>// keywords: index 5
</i></font>                              <font color="#0000FF">&quot;\\&lt;(__asm|__cdecl|__declspec|__export|__far16|__fastcall|__fortran|__import&quot;
</font>                              <font color="#0000FF">&quot;|__pascal|__rtti|__stdcall|_asm|_cdecl|__except|_export|_far16|_fastcall&quot;
</font>                              <font color="#0000FF">&quot;|__finally|_fortran|_import|_pascal|_stdcall|__thread|__try|asm|auto|bool&quot;
</font>                              <font color="#0000FF">&quot;|break|case|catch|cdecl|char|class|const|const_cast|continue|default|delete&quot;
</font>                              <font color="#0000FF">&quot;|do|double|dynamic_cast|else|enum|explicit|extern|false|float|for|friend|goto&quot;
</font>                              <font color="#0000FF">&quot;|if|inline|int|long|mutable|namespace|new|operator|pascal|private|protected&quot;
</font>                              <font color="#0000FF">&quot;|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_cast&quot;
</font>                              <font color="#0000FF">&quot;|struct|switch|template|this|throw|true|try|typedef|typeid|typename|union|unsigned&quot;
</font>                              <font color="#0000FF">&quot;|using|virtual|void|volatile|wchar_t|while)\\&gt;&quot;
</font>                              ;

<b>const</b> <b>char</b>* format_string = <font color="#0000FF">&quot;(?1&lt;font color=\&quot;#008040\&quot;&gt;$&amp;&lt;/font&gt;)&quot;
</font>                            <font color="#0000FF">&quot;(?2&lt;I&gt;&lt;font color=\&quot;#000080\&quot;&gt;$&amp;&lt;/font&gt;&lt;/I&gt;)&quot;
</font>                            <font color="#0000FF">&quot;(?3&lt;font color=\&quot;#0000A0\&quot;&gt;$&amp;&lt;/font&gt;)&quot;
</font>                            <font color="#0000FF">&quot;(?4&lt;font color=\&quot;#0000FF\&quot;&gt;$&amp;&lt;/font&gt;)&quot;
</font>                            <font color="#0000FF">&quot;(?5&lt;B&gt;$&amp;&lt;/B&gt;)&quot;</font>;

<b>const</b> <b>char</b>* header_text = <font color="#0000FF">&quot;&lt;HTML&gt;\n&lt;HEAD&gt;\n&quot;
</font>                          <font color="#0000FF">&quot;&lt;TITLE&gt;Auto-generated html formated source&lt;/TITLE&gt;\n&quot;
</font>                          <font color="#0000FF">&quot;&lt;META HTTP-EQUIV=\&quot;Content-Type\&quot; CONTENT=\&quot;text/html; charset=windows-1252\&quot;&gt;\n&quot;
</font>                          <font color="#0000FF">&quot;&lt;/HEAD&gt;\n&quot;
</font>                          <font color="#0000FF">&quot;&lt;BODY LINK=\&quot;#0000ff\&quot; VLINK=\&quot;#800080\&quot; BGCOLOR=\&quot;#ffffff\&quot;&gt;\n&quot;
</font>                          <font color="#0000FF">&quot;&lt;P&gt; &lt;/P&gt;\n&lt;PRE&gt;&quot;</font>;

<b>const</b> <b>char</b>* footer_text = <font color="#0000FF">&quot;&lt;/PRE&gt;\n&lt;/BODY&gt;\n\n&quot;</font>;</pre>

<hr>

<h3><a name="regex_split"></a>Algorithm regex_split</h3>

<p>#include &lt;<a href="../../boost/regex.hpp">boost/regex.hpp</a>&gt;
</p>

<!--<p>Algorithm regex_split performs a similar operation to the perl
split operation, and comes in three overloaded forms: </p>-->
<p>アルゴリズム regex_split は perl の spilit 操作と似たようなことをおこなう。
そして3種類のオーバロードの形で提供されている。</p>

<pre><b>template</b> &lt;<b>class</b> OutputIterator, <b>class</b> charT, <b>class</b> Traits1, <b>class</b> Alloc1, <b>class</b> Traits2, <b>class</b> Alloc2&gt;
std::size_t regex_split(OutputIterator out,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::basic_string&lt;charT, Traits1, Alloc1&gt;&amp; s,&nbsp;
&nbsp;<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const</b> reg_expression&lt;charT, Traits2, Alloc2&gt;&amp; e,
&nbsp;<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned</b> flags,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::size_t max_split);

<b>template</b> &lt;<b>class</b> OutputIterator, <b>class</b> charT, <b>class</b> Traits1, <b>class</b> Alloc1, <b>class</b> Traits2, <b>class</b> Alloc2&gt;
std::size_t regex_split(OutputIterator out,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::basic_string&lt;charT, Traits1, Alloc1&gt;&amp; s,&nbsp;
&nbsp;<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const</b> reg_expression&lt;charT, Traits2, Alloc2&gt;&amp; e,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>unsigned</b> flags = match_default);

<b>template</b> &lt;<b>class</b> OutputIterator, <b>class</b> charT, <b>class</b> Traits1, <b>class</b> Alloc1&gt;
std::size_t regex_split(OutputIterator out, 
                        std::basic_string&lt;charT, Traits1, Alloc1&gt;&amp; s);</pre>

<!--<p>Each version takes an output-iterator for output, and a string
for input. If the expression contains no marked sub-expressions,
then the algorithm writes one string onto the output-iterator for
each section of input that does not match the expression. If the
expression does contain marked sub-expressions, then each time a
match is found, one string for each marked sub-expression will be
written to the output-iterator. No more than <i>max_split </i>strings
will be written to the output-iterator. Before returning, all the
input processed will be deleted from the string <i>s</i> (if <i>max_split
</i>is not reached then all of <i>s</i> will be deleted). Returns
the number of strings written to the output-iterator. If the
parameter <i>max_split</i> is not specified then it defaults to
UINT_MAX. If no expression is specified, then it defaults to
&quot;\s+&quot;, and splitting occurs on whitespace. </p>-->
<p>それぞれの関数は出力のための出力イテレータ、入力文字列を受け取る。
正規表現が、印付けされた子表現を含まないとき、
アルゴリズムは正規表現と一致しないテキストのそれぞれの部分を
ひとつの文字列として、出力イテレータに書き込む。
もし正規表現が印付けされた子表現を含んでいれば、一致が発見される度に、
印付けされた子表現それぞれに対してひとつの文字列が、
出力イテレータに書き込まれる。
<i>max_split</i> 以上の文字列は出力イテレータに書き込まれない。
関数を抜ける前に、処理された全ての入力は文字列 s から削除される
(もし <i>max_split</i> まで到達しなければ、全ての <i>s</i> が削除される)。
出力イテレータに書き込まれた文字列の数を返す。
もしパラメータ <i>max_split</i> が特定されていなければ、
デフォルトでは UINT_MAX が使われる。
正規表現が特定されていなければ、デフォルトでは
&quot;\s+&quot; が使われ、空白によって分割される。
(訳注: この関数は、正規表現が子表現を持っているかどうかで、動作が大きく異なる。
正規表現が子表現を持っていないとき、この関数はまさに、 perl の split と同様に動作する。
正規表現が子表現を持っているとき、その一致した子表現が出力イテレータに書き込まれる。)
</p>


<p><a href="example/snippets/regex_split_example_1.cpp">Example</a>:
the following function will split the input string into a series
of tokens, and remove each token from the string <i>s</i>: </p>

<pre><b>unsigned</b> tokenise(std::list&lt;std::string&gt;&amp; l, std::string&amp; s)
{
<b>&nbsp;&nbsp; return</b> boost::regex_split(std::back_inserter(l), s);
}</pre>

<p><a href="example/snippets/regex_split_example_2.cpp">Example</a>:
the following short program will extract all of the URL's from a
html file, and print them out to <i>cout</i>: </p>

<pre><font color="#008000">#include &lt;list&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;boost/regex.hpp&gt;
</font>
boost::regex e(<font color="#000080">&quot;&lt;\\s*A\\s+[^&gt;]*href\\s*=\\s*\&quot;([^\&quot;]*)\&quot;&quot;</font>,
               boost::regbase::normal | boost::regbase::icase);

<b>void</b> load_file(std::string&amp; s, std::istream&amp; is)
{
   s.erase();
   <font color="#000080">//
   // attempt to grow string buffer to match file size,
   // this doesn't always work...
</font>   s.reserve(is.rdbuf()-&amp;gtin_avail());
   <b>char</b> c;
   <b>while</b>(is.get(c))
   {
      <font color="#000080">// use logarithmic growth stategy, in case
      // in_avail (above) returned zero:
</font>      <b>if</b>(s.capacity() == s.size())
         s.reserve(s.capacity() * 3);
      s.append(1, c);
   }
}


<b>int</b> main(<b>int</b> argc, <b>char</b>** argv)
{
   std::string s;
   std::list&lt;std::string&gt; l;

   <b>for</b>(<b>int</b> i = 1; i &lt; argc; ++i)
   {
      std::cout &lt;&lt; <font color="#000080">&quot;Findings URL's in &quot;</font> &lt;&lt; argv[i] &lt;&lt; <font
color="#000080">&quot;:&quot;</font> &lt;&lt; std::endl;
      s.erase();
      std::ifstream is(argv[i]);
      load_file(s, is);
      boost::regex_split(std::back_inserter(l), s, e);
      <b>while</b>(l.size())
      {
         s = *(l.begin());
         l.pop_front();
         std::cout &lt;&lt; s &lt;&lt; std::endl;
      }
   }
   <b>return</b> 0;
}</pre>

<hr>

<h3><a name="partial_matches"></a>Partial Matches</h3>

<!--<p>The match-flag <code>match_partial</code> can be passed to the
following algorithms: <a href="#reg_match">regex_match</a>, <a
href="#reg_search">regex_search</a>, and <a href="#reg_grep">regex_grep</a>.
When used it indicates that partial as well as full matches
should be found. A partial match is one that matched one or more
characters at the end of the text input, but did not match all of
the regular expression (although it may have done so had more
input been available). Partial matches are typically used when
either validating data input (checking each character as it is
entered on the keyboard), or when searching texts that are either
too long to load into memory (or even into a memory mapped file),
or are of indeterminate length (for example the source may be a
socket or similar). Partial and full matches can be
differentiated as shown in the following table (the variable M
represents an instance of match_results&lt;&gt; as filled in by
regex_match, regex_search or regex_grep):<br>
</p>-->
<p>一致フラグ <code>match_partial</code> は次のアルゴリズムに渡すことが出来る:
<a href="#reg_match">regex_match</a>, <a href="#reg_search">regex_search</a>, そして
 <a href="#reg_grep">regex_grep</a> 。
これは、全体一致と同様に部分一致が発見されることを表す。
部分一致は、入力テキストの終端に1文字以上の一致があるが、
それが正規表現の全体と一致しているのではない、というものである
(テキストが終了したかもしれないが、まだ続くかもしれない、というような時だ)。
部分一致は通常、入力データの検証(キーボードが押される度に
それぞれの文字を検証する)、とか、メモリ(やメモリマップドファイルにさえ)
に読み込むには長すぎるようなテキスト、または不確定な長さのテキスト
(例えばテキストの元はソケットや、それに似たようなものかもしれない)
を検索するときである。
部分一致と全体一致は次の表に示されるように、区別されている
(変数 M は regex_match, regex_search, regex_grep によって結果を
書き込まれた match_results&lt;&gt; のインスタンスを表している)。
</p>

<table border="0" cellpadding="7" cellspacing="0" width="638">
    <tr>
        <td valign="top" width="20%">&nbsp;</td>
        <td valign="top" width="20%">Result</td>
        <td valign="top" width="20%">M[0].matched</td>
        <td valign="top" width="20%">M[0].first</td>
        <td valign="top" width="20%">M[0].second</td>
    </tr>
    <tr>
<!--        <td valign="top" width="20%">No match</td>
        <td valign="top" width="20%">False</td>
        <td valign="top" width="20%">Undefined</td>
        <td valign="top" width="20%">Undefined</td>
        <td valign="top" width="20%">Undefined</td>-->
        <td valign="top" width="20%">一致無し</td>
        <td valign="top" width="20%">False</td>
        <td valign="top" width="20%">未定義</td>
        <td valign="top" width="20%">未定義</td>
        <td valign="top" width="20%">未定義</td>
    </tr>
    <tr>
<!--        <td valign="top" width="20%">Partial match</td>
        <td valign="top" width="20%">True</td>
        <td valign="top" width="20%">False</td>
        <td valign="top" width="20%">Start of partial match.</td>
        <td valign="top" width="20%">End of partial match (end of
        text).</td>-->
        <td valign="top" width="20%">部分一致</td>
        <td valign="top" width="20%">True</td>
        <td valign="top" width="20%">False</td>
        <td valign="top" width="20%">部分一致の先頭</td>
        <td valign="top" width="20%">部分一致の終端(テキストの終端)</td>
    </tr>
    <tr>
<!--        <td valign="top" width="20%">Full match</td>
        <td valign="top" width="20%">True</td>
        <td valign="top" width="20%">True</td>
        <td valign="top" width="20%">Start of full match.</td>
        <td valign="top" width="20%">End of full match.</td>-->
        <td valign="top" width="20%">全体一致</td>
        <td valign="top" width="20%">True</td>
        <td valign="top" width="20%">True</td>
        <td valign="top" width="20%">全体一致の先頭</td>
        <td valign="top" width="20%">全体一致の終端</td>
    </tr>
</table>

<!--<p>The following <a
href="example/snippets/partial_regex_match.cpp">example</a> tests
to see whether the text could be a valid credit card number, as
the user presses a key, the character entered would be added to
the string being built up, and passed to <code>is_possible_card_number</code>.
If this returns true then the text could be a valid card number,
so the user interface's OK button would be enabled. If it returns
false, then this is not yet a valid card number, but could be
with more input, so the user interface would disable the OK
button. Finally, if the procedure throws an exception the input
could never become a valid number, and the inputted character
must be discarded, and a suitable error indication displayed to
the user.</p>-->
<p><a href="example/snippets/partial_regex_match.cpp">次の例</a>
はユーザがキーを押す度に、テキストが有効なクレジットカードの番号かどうか検証する。
入力された文字は積み上げられた文字列に付け加えられ、
<code>is_possible_card_number</code> に渡される。
もしこれが true を返せばテキストは有効なカード番号であり、
ユーザインタフェースの OK ボタンが有効になる。
もし false を返せばこれはまだ有効なカードナンバーではないが、
更に入力が可能で、ユーザインタフェースの OK ボタンは無効である。
最後にこの手続きで、入力が決して有効な番号にはならないという例外が
発生すれば、入力された文字は破棄され、ユーザに適したエラーを表示する。</p>

<pre>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;boost/regex.hpp&gt;

boost::regex e(&quot;(\\d{3,4})[- ]?(\\d{4})[- ]?(\\d{4})[- ]?(\\d{4})&quot;);

bool is_possible_card_number(const std::string&amp; input)
{
   //
   // return false for partial match, true for full match, or throw for
   // impossible match based on what we have so far...
   boost::match_results&lt;std::string::const_iterator&gt; what;
   if(0 == boost::regex_match(input, what, e, boost::match_default | boost::match_partial))
   {
      // the input so far could not possibly be valid so reject it:
      throw std::runtime_error(&quot;Invalid data entered - this could not possibly be a valid card number&quot;);
   }
   // OK so far so good, but have we finished?
   if(what[0].matched)
   {
      // excellent, we have a result:
      return true;
   }
   // what we have so far is only a partial match...
   return false;
}</pre>

<!--<p>In the following <a
href="example/snippets/partial_regex_match.cpp">example</a>, text
input is taken from a stream containing an unknown amount of
text; this example simply counts the number of html tags
encountered in the stream. The text is loaded into a buffer and
searched a part at a time, if a partial match was encountered,
then the partial match gets searched a second time as the start
of the next batch of text:</p>-->
<p><a href="example/snippets/partial_regex_match.cpp">次の例</a> では、
不定な長さのテキストを含むストリームから入力を受け取る。
この例は単に、ストリームの中に現れる html タグの数を数えるだけである。
テキストはバッファに読み込まれ、同時に一部を検索する。
部分一致が現れれば、その部分一致は、次のひとまとまりのテキストの先頭として
次回に検索される: </p>

<pre>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;boost/regex.hpp&gt;

// match some kind of html tag:
boost::regex e(&quot;&lt;[^&gt;]*&gt;&quot;);
// count how many:
unsigned int tags = 0;
// saved position of partial match:
char* next_pos = 0;

bool grep_callback(const boost::match_results&lt;char*&gt;&amp; m)
{
   if(m[0].matched == false)
   {
      // save position and return:
      next_pos = m[0].first;
   }
   else
      ++tags;
   return true;
}

void search(std::istream&amp; is)
{
   char buf[4096];
   next_pos = buf + sizeof(buf);
   bool have_more = true;
   while(have_more)
   {
      // how much do we copy forward from last try:
      unsigned leftover = (buf + sizeof(buf)) - next_pos;
      // and how much is left to fill:
      unsigned size = next_pos - buf;
      // copy forward whatever we have left:
      memcpy(buf, next_pos, leftover);
      // fill the rest from the stream:
      unsigned read = is.readsome(buf + leftover, size);
      // check to see if we've run out of text:
      have_more = read == size;
      // reset next_pos:
      next_pos = buf + sizeof(buf);
      // and then grep:
      boost::regex_grep(grep_callback,
                        buf,
                        buf + read + leftover,
                        e,
                        boost::match_default | boost::match_partial);
   }
}</pre>

<hr align="left">

<p><i>Copyright </i><a href="mailto:John_Maddock@compuserve.com"><i>Dr
John Maddock</i></a><i> 1998-2001 all rights reserved.</i> </p>

<hr align="left">
<p>
<p><i>Japanese Translation Copyright (C) 2003 <a href="mailto:kohske@msc.biglobe.ne.jp">Kohske Takahashi</a></i></p>
<p>
オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の
複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」
に提供されており、いかなる明示的、暗黙的保証も行わない。また、
いかなる目的に対しても、その利用が適していることを関知しない。
</p>
</body>
</html>
