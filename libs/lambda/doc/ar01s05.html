<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<head>
<title>5. Lambda expressions in details</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.48">
<link rel="home" href="index.html" title="
      C++ BOOST

      The Boost Lambda Library"><link rel="up" href="index.html" title="
      C++ BOOST

      The Boost Lambda Library">
<link rel="previous" href="ar01s04.html" title="4. Using the library">
<link rel="next" href="ar01s06.html" title="6. Extending return type deduction system">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr>
<th colspan="3" align="center">5. Lambda expressions in details</th>
</tr>
<tr>
<td width="20%" align="left"><a accesskey="p" href="ar01s04.html">Prev</a></td>
<th width="60%" align="center"></th>
<td width="20%" align="right"><a accesskey="n" href="ar01s06.html">Next</a></td>
</tr>
</table>
<hr>
</div>
<div class="section">
<div class="titlepage">
<div>
<h2 class="title" style="clear: both"><a name="sect:lambda_expressions_in_details"></a>5. Lambda expressions in details</h2></div>
</div>
<p>
このセクションでは様々な形のλ式を詳しく説明する。
個々のサブセクションではそれぞれ有効なλ式の形式について説明している。
</p>
<p>
This section describes different categories of lambda expressions in details.
We devote a separate section for each of the possible forms of a lambda expression.


</p>
<div class="section">
<div class="titlepage">
<div>
<h3 class="title"><a name="sect:placeholders"></a>5.1. Placeholders</h3>
</div>
</div>
<p>
BLL では、<tt>placeholder1_type</tt>、<tt>placeholder2_type</tt>、<tt>placeholder3_type</tt>という 3 つのプレースホルダー型を定義されている。
また、BLL ではそれぞれのプレースホルダー型の変数、<tt>_1</tt>, <tt>_2</tt> and <tt>_3</tt> があらかじめ定義されている。
しかし、ユーザはこれらのプレースホルダーを使用しなくともよい。
別な名前のプレースホルダーは簡単に定義できる。
プレースホルダー型の新しい変数を定義すればよい。
例えば、次のようになる。
<pre class="programlisting">boost::lambda::placeholder1_type X;
boost::lambda::placeholder2_type Y;
boost::lambda::placeholder3_type Z;
</pre>
これらの変数を定義すれば、<tt>X += Y * Z</tt> は <tt>_1 += _2 * _3</tt> と等価である。

</p><p>
The BLL defines three placeholder types: <tt>placeholder1_type</tt>, <tt>placeholder2_type</tt> and <tt>placeholder3_type</tt>. 
BLL has a predefined placeholder variable for each placeholder type: <tt>_1</tt>, <tt>_2</tt> and <tt>_3</tt>. 
However, the user is not forced to use these placeholders. 
It is easy to define placeholders with alternative names.
This is done by defining new variables of placeholder types. 
For example:

<pre class="programlisting">boost::lambda::placeholder1_type X;
boost::lambda::placeholder2_type Y;
boost::lambda::placeholder3_type Z;
</pre>

With these variables defined, <tt>X += Y * Z</tt> is equivalent to <tt>_1 += _2 * _3</tt>.
</p><p>
λ式でのプレースホルダーの使用法によって、そのλ式が表現する関数が、無引数か、一引数か、二引数か、三引数かが決まる。
最も大きいインデックスのプレースホルダーが決定する。
例えば、次のようになる。
<pre class="programlisting">
_1 + 5              // unary
_1 * _1 + _1        // unary
_1 + _2             // binary
bind(f, _1, _2, _3) // 3-ary
_3 + 10             // 3-ary
</pre>
注意が必要なのは、最後の行のλ式は三引数の関数を生成することである。
その関数は、第一、第二引数を無視し、<span class="emphasis"><i>第三引数</i></span>に 10 を加える。
さらに、λファンクタは最低限の引数しかもたない。
しかし、より多くの引数を(サポートされているプレースホルダーの数までであれば)与えることが可能である。このことは実際に必要となる。
余剰な引数は単に無視されるだけである。
例えば、
<pre class="programlisting">
int i, j, k; 
_1(i, j, k)        // returns i, discards j and k
(_2 + _2)(i, j, k) // returns j+j, discards i and k
</pre>
となる。
この機能の背景にある設計理由にについては、<a href="apa.html#sect:why_weak_arity" title="1. Lambda functor arity">Section 1</a>を見よ。
</p><p>

The use of placeholders in the lambda expression determines whether the resulting function is nullary, unary, binary or 3-ary. 
The highest placeholder index is decisive. For example:
<pre class="programlisting">
_1 + 5              // unary
_1 * _1 + _1        // unary
_1 + _2             // binary
bind(f, _1, _2, _3) // 3-ary
_3 + 10             // 3-ary
</pre>

Note that the last line creates a 3-ary function, which adds <tt>10</tt> to its <span class="emphasis"><i>third</i></span> argument. 
The first two arguments are discarded.
Furthermore, lambda functors only have a minimum arity.
One can always provide more arguments (up the number of supported placeholders)
that is really needed.
The remaining arguments are just discarded.
For example:

<pre class="programlisting">
int i, j, k; 
_1(i, j, k)        // returns i, discards j and k
(_2 + _2)(i, j, k) // returns j+j, discards i and k
</pre>

See
<a href="apa.html#sect:why_weak_arity" title="1. 
Lambda functor arity
">Section 1</a> for the design rationale behind this
functionality.

</p><p>
これら三つのプレースホルダー型に加えて、四つ目のプレースホルダー型 <tt>placeholderE_type</tt> もある。
このプレースホルダーの使い方は、λ式内での例外処理を説明する <a href="ar01s05.html#sect:exceptions" title="5.7. Exceptions">Section 5.7</a> で定義している。 
</p><p>
In addition to these three placeholder types, there is also a fourth placeholder type <tt>placeholderE_type</tt>.
The use of this placeholder is defined in <a href="ar01s05.html#sect:exceptions" title="5.7. Exceptions">Section 5.7</a> describing exception handling in lambda expressions. 
</p><p>
実引数がプレースホルダーに渡されたとき、パラメタはいつも参照によって渡される。
これは、プレースホルダーに対するいかなる副作用も実引数に反映させるためである。
例えば、次のようになる。
<pre class="programlisting">
int i = 1; 
(_1 += 2)(i);         // i is now 3
(++_1, cout &lt;&lt; _1)(i) // i is now 4, outputs 4
</pre>
</p><p>When an actual argument is supplied for a placeholder, the parameter passing mode is always by reference. 
This means that any side-effects to the placeholder are reflected to the actual argument. 
For example:


<pre class="programlisting">
int i = 1; 
(_1 += 2)(i);         // i is now 3
(++_1, cout &lt;&lt; _1)(i) // i is now 4, outputs 4
</pre>
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<h3 class="title"><a name="sect:operator_expressions"></a>5.2. Operator expressions</h3>
</div>
</div>
<p>
基本的な規則では、少なくとも一つのλ式を引数とするすべての C++ の演算子の呼出しは、それ自身がλ式である。
オーバーロード可能な演算子のほとんどはサポートしている。
例えば、以下のものは有効なλ式である。
<pre class="programlisting">
cout &lt;&lt; _1, _2[_3] = _1 &amp;&amp; false
</pre>
</p><p>
The basic rule is that any C++ operator invocation with at least one argument being a lambda expression is itself a lambda expression.
Almost all overloadable operators are supported. 
For example, the following is a valid lambda expression:

<pre class="programlisting">cout &lt;&lt; _1, _2[_3] = _1 &amp;&amp; false</pre>
</p><p>
しかし、いくつかの制限もある。それらは、C++ の演算子のオーバーロードの規則に基づくものと、特別な場合のものとある。
</p>
</p><p>
However, there are some restrictions that originate from the C++ operator overloading rules, and some special cases.
</p>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="id2740636"></a>5.2.1. Operators that cannot be overloaded</h4>
</div>
</div>
<p>
いくつかの演算子は完全にオーバーロードすることができない。(例えば、<tt>::</tt>, <tt>.</tt>, <tt>.*</tt>)
また、いくつかの演算子に関しては、返り値の型の認識が必要なために、λ式を生成するためのオーバーロードをすることができない。<tt>-&gt;.</tt>, <tt>-&gt;</tt>, <tt>new</tt>, <tt>new[]</tt>, <tt>delete</tt>, <tt>delete[]</tt> and <tt>?:</tt>(条件演算子)がそういった演算子である。
</p><p>
Some operators cannot be overloaded at all (<tt>::</tt>, <tt>.</tt>, <tt>.*</tt>).
For some operators, the requirements on return types prevent them to be overloaded to create lambda functors.
These operators are <tt>-&gt;.</tt>, <tt>-&gt;</tt>, <tt>new</tt>, <tt>new[]</tt>, <tt>delete</tt>, <tt>delete[]</tt> and <tt>?:</tt> (the conditional operator).
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="sect:assignment_and_subscript"></a>5.2.2. Assignment and subscript operators</h4>
</div>
</div>
<p>
こういった演算子はクラスのメンバ関数として実装しなければならない。
よって、演算子の左側の引数はλ式でなければならない。
例えば次のようになる。
<pre class="programlisting">
int i; 
_1 = i;      // ok
i = _1;      // not ok. i is not a lambda expression
</pre>
この制限に関する単純な解決策を<a href="ar01s05.html#sect:delaying_constants_and_variables" title="5.5. Delaying constants and variables">Section 5.5</a>において説明する。
簡潔にいうと、
左側のオペランドを 次のように特別な関数 <tt>var</tt> でラップして明示的にλファンクタとすればよい。
<pre class="programlisting">
var(i) = _1; // ok
</pre>
</p>
<p>
These operators must be implemented as class members. 
Consequently, the left operand must be a lambda expression. For example:

<pre class="programlisting">
int i; 
_1 = i;      // ok
i = _1;      // not ok. i is not a lambda expression
</pre>

There is a simple solution around this limitation, described in <a href="ar01s05.html#sect:delaying_constants_and_variables" title="5.5. Delaying constants and variables">Section 5.5</a>.
In short, 
the left hand argument can be explicitly turned into a lambda functor by wrapping it with a special <tt>var</tt> function:
<pre class="programlisting">
var(i) = _1; // ok
</pre>

</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="sect:logical_operators"></a>5.2.3. Logical operators</h4>
</div>
</div>
<p>
論理演算子は短絡評価の規則に従う。
例えば、次のコードでは、<tt>i</tt>は決してインクリメントされることはない。
<pre class="programlisting">
bool flag = true; int i = 0;
(_1 || ++_2)(flag, i);
</pre>
</p>
<p>
Logical operators obey the short-circuiting evaluation rules. For example, in the following code, <tt>i</tt> is never incremented:
<pre class="programlisting">
bool flag = true; int i = 0;
(_1 || ++_2)(flag, i);
</pre>
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="sect:comma_operator"></a>5.2.4. Comma operator</h4>
</div>
</div>
<p>
コンマ演算子はλ式中の文の区切りである。
コンマは関数呼出しの引数の区切りでもあるため、余分な括弧が必要になることがある。
例えば、次のようなときである。
<pre class="programlisting">
for_each(a.begin(), a.end(), (++_1, cout &lt;&lt; _1));
</pre>
<tt>++_1, cout &lt;&lt; _1</tt> を囲う余分な括弧がないと、このコードは <tt>for_each</tt> を 4 つの引数で呼出そうとしていると解釈されてしまう。
</p>
<p>
Comma operator is the &#8216;statement separator&#8217; in lambda expressions. 
Since comma is also the separator between arguments in a function call, extra parenthesis are sometimes needed:

<pre class="programlisting">
for_each(a.begin(), a.end(), (++_1, cout &lt;&lt; _1));
</pre>

Without the extra parenthesis around <tt>++_1, cout &lt;&lt; _1</tt>, the code would be interpreted as an attempt to call <tt>for_each</tt> with four arguments.
</p><p>
コンマ演算子を用いて作成されたλファンクタは、左のオペランドを評価してから、右のオペランドを評価するという C++ の規則と同じように評価する。
上に挙げた例では、<tt>a</tt> の要素それぞれに対して、まずインクリメントされ、その後でストリームへ書き出される。
</p><p>
The lambda functor created by the comma operator adheres to the C++ rule of always evaluating the left operand before the right one.
In the above example, each element of <tt>a</tt> is first incremented, then written to the stream.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="sect:function_call_operator"></a>5.2.5. Function call operator</h4>
</div>
</div>
<p>
関数呼出し演算子にはλファンクタを評価する効果がある。
少ない引数での呼出しはコンパイル時エラーとして検出される。
</p>
<p>
The function call operators have the effect of evaluating the lambda
functor. 
Calls with too few arguments lead to a compile time error.
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="sect:member_pointer_operator"></a>5.2.6. Member pointer operator</h4>
</div>
</div>
<p>
メンバポインタ演算子 <tt>operator-&gt;*</tt> は自由にオーバーロード可能である。
<font color="red">
よって、ユーザ定義型に関してはメンバポインタ演算子の特別な場合はない。
しかし、組み込み型においてはもう少し複雑な場合がある。
組み込みのメンバポインタ演算子は、左の引数があるクラス <tt>A</tt> のオブジェクトを指すポインタであり、右側の引数が <tt>A</tt> のメンバへのポインタであるか、<tt>A</tt> から派生したクラスのメンバへのポインタであった場合に適用される。
さらに、次の二つの場合は分けて考えなければならない。
</font>
<br><br>
The member pointer operator <tt>operator-&gt;*</tt> can be overloaded freely. 
Hence, for user defined types, member pointer operator is no special case.
The built-in meaning, however, is a somewhat more complicated case.
The built-in member pointer operator is applied if the left argument is a pointer to an object of some class <tt>A</tt>, and the right hand argument is a pointer to a member of <tt>A</tt>, or a pointer to a member of a class from which <tt>A</tt> derives.
We must separate two cases:

<div class="itemizedlist">
<ul type="disc">
<li><p>
まず、右側の引数がメンバ変数へのポインタであるときである。
この場合は、λファンクタは単純に実引数の代入を行い、引数のポインタが指しているメンバ変数の参照を返す組み込みのメンバポインタ演算子が呼ばれる。
例えば、次のようになる。
<pre class="programlisting">
struct A { int d; };
A* a = new A();
  ...
(a -&gt;* &amp;A::d);     // returns a reference to a-&gt;d 
(_1 -&gt;* &amp;A::d)(a); // likewise
</pre>
</p></li>
<li><p>
次に、右側の引数がメンバ関数へのポインタであるときである。
このような組み込みの演算子の呼出しは、一種のメンバ関数の遅延呼出しのような結果となる。
このような式の後には、メンバ関数の遅延呼出しのための引数リストが続かなくてはならない。
例えば、次のようになる。
<pre class="programlisting">
struct B { int foo(int); };
B* b = new B();
  ...
(b -&gt;* &amp;B::foo)         // returns a delayed call to b-&gt;foo
                        // a function argument list must follow
(b -&gt;* &amp;B::foo)(1)      // ok, calls b-&gt;foo(1)

(_1 -&gt;* &amp;B::foo)(b);    // returns a delayed call to b-&gt;foo, 
                        // no effect as such
(_1 -&gt;* &amp;B::foo)(b)(1); // calls b-&gt;foo(1)
</pre>
</p></li>
<li><p>
The right hand argument is a pointer to a data member. 
In this case the lambda functor simply performs the argument substitution and calls the built-in member pointer operator, which returns a reference to the member pointed to. 
For example:
<pre class="programlisting">
struct A { int d; };
A* a = new A();
  ...
(a -&gt;* &amp;A::d);     // returns a reference to a-&gt;d 
(_1 -&gt;* &amp;A::d)(a); // likewise
</pre>
</p></li>
<li><p>
The right hand argument is a pointer to a member function.
For a built-in call like this, the result is kind of a delayed member function call. 
Such an expression must be followed by a function argument list, with which the delayed member function call is performed.
For example:
<pre class="programlisting">
struct B { int foo(int); };
B* b = new B();
  ...
(b -&gt;* &amp;B::foo)         // returns a delayed call to b-&gt;foo
                        // a function argument list must follow
(b -&gt;* &amp;B::foo)(1)      // ok, calls b-&gt;foo(1)

(_1 -&gt;* &amp;B::foo)(b);    // returns a delayed call to b-&gt;foo, 
                        // no effect as such
(_1 -&gt;* &amp;B::foo)(b)(1); // calls b-&gt;foo(1)
</pre>
</p></li>
</ul>
</div>
</p>
</div>
</div>
<div class="section">
<div class="titlepage">
<div>
<h3 class="title"><a name="sect:bind_expressions"></a>5.3. Bind expressions</h3>
</div>
</div>
<p>
bind 式には次の二つの形がある。
<pre class="programlisting">
bind(<i><tt>target-function</tt></i>, <i><tt>bind-argument-list</tt></i>)
bind(<i><tt>target-member-function</tt></i>, <i><tt>object-argument</tt></i>, <i><tt>bind-argument-list</tt></i>)
</pre>
bind 式は関数の呼出しを遅延させる。
もし、<span class="emphasis"><i>target-function</i></span> が <span class="emphasis"><i>n</i></span>引数の関数であれば、<tt><span class="emphasis"><i>bind-argument-list</i></span></tt> も同様に <span class="emphasis"><i>n</i></span> 個の引数を含んでいなければならない。
現在のバージョンの BLL では、引数の数 n には、0 &lt;= n &lt;= 9 という制限がある。
メンバ関数に適用する場合には、対象のオブジェクトが引数として渡されるため、引数の数は最大 8 個に抑えなければならない。
基本的には、引数がプレースホルダーである、またより一般的に言えば、λ式であることを除けば、<span class="emphasis"><i><tt>bind-argument-list</tt></i></span> は目的の関数への有効な引数のリストでなければならない。
また、目的の関数はλ式であってもよい。
bind 式の結果は、無引数、一引数、二引数、または、三引数の関数オブジェクトである。
この引数の数は、<span class="emphasis"><i><tt>bind-argument-list</tt></i></span> 内のプレースホルダーの使い方によって決定される。(詳しくは <a href="ar01s05.html#sect:placeholders" title="5.1. Placeholders">Section 5.1</a> を見よ)
</p><p>
Bind expressions can have two forms: 

<pre class="programlisting">
bind(<i><tt>target-function</tt></i>, <i><tt>bind-argument-list</tt></i>)
bind(<i><tt>target-member-function</tt></i>, <i><tt>object-argument</tt></i>, <i><tt>bind-argument-list</tt></i>)
</pre>

A bind expression delays the call of a function. 
If this <span class="emphasis"><i>target function</i></span> is <span class="emphasis"><i>n</i></span>-ary, then the <tt><span class="emphasis"><i>bind-argument-list</i></span></tt> must contain <span class="emphasis"><i>n</i></span> arguments as well.
In the current version of the BLL, 0 &lt;= n &lt;= 9 must hold. 
For member functions, the number of arguments must be at most 8, as the object argument takes one argument position.

Basically, the
<span class="emphasis"><i><tt>bind-argument-list</tt></i></span> must be a valid argument list for the target function, except that any argument can be replaced with a placeholder, or more generally, with a lambda expression. 
Note that also the target function can be a lambda expression.

The result of a bind expression is either a nullary, unary, binary or 3-ary function object depending on the use of placeholders in the <span class="emphasis"><i><tt>bind-argument-list</tt></i></span> (see <a href="ar01s05.html#sect:placeholders" title="5.1. Placeholders">Section 5.1</a>).
</p><p>
次の例で示すように、bind 式で作成されたλファンクタの返り値は、テンプレート引数として明示的に指定される。
<pre class="programlisting">
bind&lt;<span class="emphasis"><i>RET</i></span>&gt;(<span class="emphasis"><i>target-function</i></span>, <span class="emphasis"><i>bind-argument-list</i></span>)
</pre>
この明示的な指定は、目的の関数の返り値の型を推論できなかった場合のみ必要となる。
</p><p>
The return type of the lambda functor created by the bind expression can be given as an explicitly specified template parameter, as in the following example:
<pre class="programlisting">
bind&lt;<span class="emphasis"><i>RET</i></span>&gt;(<span class="emphasis"><i>target-function</i></span>, <span class="emphasis"><i>bind-argument-list</i></span>)
</pre>
This is only necessary if the return type of the target function cannot be deduced.
</p><p>
以下のサブセクションでは、様々な bind 式の形について説明している。
</p><p>
The following sections describe the different types of bind expressions.
</p>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="sect:function_pointers_as_targets"></a>5.3.1. Function pointers or references as targets</h4>
</div>
</div>
<p>
目的の関数は、関数のポインタであっても参照であってもよく、また、その関数が束縛されても、束縛されてなくともよい。
例えば、次の例の bind 式は全て有効である。
<pre class="programlisting">
X foo(A, B, C); A a; B b; C c;
bind(foo, _1, _2, c)(a, b);
bind(&amp;foo, _1, _2, c)(a, b);
bind(_1, a, b, c)(foo);
</pre>
返り値の型の推論はこれらの bind 式では全て解決できる。
</p><p>
The target function can be a pointer or a reference to a function and it can be either bound or unbound. For example:
<pre class="programlisting">
X foo(A, B, C); A a; B b; C c;
bind(foo, _1, _2, c)(a, b);
bind(&amp;foo, _1, _2, c)(a, b);
bind(_1, a, b, c)(foo);
</pre>
 
The return type deduction always succeeds with this type of bind expressions. 
</p><p>
C++ ではオーバーロードされた関数のアドレスは、直接アドレスが指定されるか、
<font color="red">
曖昧さを解決する型を持つ変数の初期化として使用されるか、
</font>
明示的なキャストが使用された場合のみ取得することができる。
つまり、オーバーロードされた関数は、次に示すように直接 bind 式で使用することはできない。
<pre class="programlisting">
void foo(int);
void foo(float);
int i; 
  ...
bind(&amp;foo, _1)(i);                            // error 
  ...
void (*pf1)(int) = &amp;foo;
bind(pf1, _1)(i);                             // ok
bind(static_cast&lt;void(*)(int)&gt;(&amp;foo), _1)(i); // ok
</pre>
</p><p>
Note, that in C++ it is possible to take the address of an overloaded function only if the address is assigned to, or used as an initializer of, a variable, the type of which solves the amibiguity, or if an explicit cast expression is used.
This means that overloaded functions cannot be used in bind expressions directly, e.g.:
<pre class="programlisting">
void foo(int);
void foo(float);
int i; 
  ...
bind(&amp;foo, _1)(i);                            // error 
  ...
void (*pf1)(int) = &amp;foo;
bind(pf1, _1)(i);                             // ok
bind(static_cast&lt;void(*)(int)&gt;(&amp;foo), _1)(i); // ok
</pre>
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="member_functions_as_targets"></a>5.3.2. Member functions as targets</h4>
</div>
</div>
<p>
bind 式においてメンバ関数へのポインタを使用するための文法は次の通りである。
The syntax for using pointers to member function in bind expression is:
<pre class="programlisting">
bind(<i><tt>target-member-function</tt></i>, <i><tt>object-argument</tt></i>, <i><tt>bind-argument-list</tt></i>)
</pre>
オブジェクトは、参照でもポインタでもよい。BLL は両方の場合を同一のインターフェースでサポートしている。
<pre class="programlisting">
bool A::foo(int) const; 
A a;
vector&lt;int&gt; ints; 
  ...
find_if(ints.begin(), ints.end(), bind(&amp;A::foo, a, _1)); 
find_if(ints.begin(), ints.end(), bind(&amp;A::foo, &amp;a, _1));
</pre>

The syntax for using pointers to member function in bind expression is:
<pre class="programlisting">
bind(<i><tt>target-member-function</tt></i>, <i><tt>object-argument</tt></i>, <i><tt>bind-argument-list</tt></i>)
</pre>

The object argument can be a reference or pointer to the object, the BLL supports both cases with a uniform interface: 

<pre class="programlisting">
bool A::foo(int) const; 
A a;
vector&lt;int&gt; ints; 
  ...
find_if(ints.begin(), ints.end(), bind(&amp;A::foo, a, _1)); 
find_if(ints.begin(), ints.end(), bind(&amp;A::foo, &amp;a, _1));
</pre>

同様に、オブジェクトが束縛されていなければ、bind 式の結果のλファンクタは実際に渡された引数がポインタか参照かによってどちらも呼ぶことができる。次にその例を示す。
<pre class="programlisting">
bool A::foo(int); 
list&lt;A&gt; refs; 
list&lt;A*&gt; pointers; 
  ...
find_if(refs.begin(), refs.end(), bind(&amp;A::foo, _1, 1)); 
find_if(pointers.begin(), pointers.end(), bind(&amp;A::foo, _1, 1));
</pre>

Similarly, if the object argument is unbound, the resulting lambda functor can be called both via a pointer or a reference:

<pre class="programlisting">
bool A::foo(int); 
list&lt;A&gt; refs; 
list&lt;A*&gt; pointers; 
  ...
find_if(refs.begin(), refs.end(), bind(&amp;A::foo, _1, 1)); 
find_if(pointers.begin(), pointers.end(), bind(&amp;A::foo, _1, 1));
</pre>

</p><p>
インターフェースは同じであっても、オブジェクトがポインタであるか、参照であるかには、重要な意味的な違いがある。この違いは、関数 <tt>bind</tt> の引数の取り方と、束縛された引数をλファンクタ内に格納する方法によるものである。
オブジェクトは他の bind の引数と同様に渡され、格納される。(<a href="ar01s04.html#sect:storing_bound_arguments" title="4.4. Storing bound arguments in lambda functions">Section 4.4</a> 参照);
つまり、const な参照として渡され、const なコピーとしてλファンクタに格納される。
これにより、λファンクタと元々のメンバ関数や、見た目には同じλファンクタの間に非対称性が生じてしまう。例えば、次のような場合である。
<pre class="programlisting">
class A {
  int i; mutable int j;
public:

  A(int ii, int jj) : i(ii), j(jj) {};
  void set_i(int x) { i = x; }; 
  void set_j(int x) const { j = x; }; 
};
</pre>

Even though the interfaces are the same, there are important semantic differences between using a pointer or a reference as the object argument.
The differences stem from the way <tt>bind</tt>-functions take their parameters, and how the bound parameters are stored within the lambda functor.
The object argument has the same parameter passing and storing mechanism as any other bind argument slot (see <a href="ar01s04.html#sect:storing_bound_arguments" title="4.4. Storing bound arguments in lambda functions">Section 4.4</a>); it is passed as a const reference and stored as a const copy in the lambda functor.
This creates some asymmetry between the lambda functor and the original member function, and between seemingly similar lambda functors. For example:
<pre class="programlisting">
class A {
  int i; mutable int j;
public:

  A(int ii, int jj) : i(ii), j(jj) {};
  void set_i(int x) { i = x; }; 
  void set_j(int x) const { j = x; }; 
};
</pre>
ポインタとして使用された場合には、次の動作は恐らくプログラマが期待したものである。
<pre class="programlisting">
A a(0,0); int k = 1;
bind(&amp;A::set_i, &amp;a, _1)(k); // a.i == 1
bind(&amp;A::set_j, &amp;a, _1)(k); // a.j == 1
</pre>
オブジェクトの const なコピーが格納されていたとしても、元のオブジェクト <tt>a</tt>も変更されている。
これは、オブジェクトがポインタとして渡されたためであり、ポインタが指すオブジェクトがコピーされたのではなく、ポインタ自身がコピーされたためである。
参照として使用された場合には、異った動作となる。
<pre class="programlisting">
A a(0,0); int k = 1;
bind(&amp;A::set_i, a, _1)(k); // error; a const copy of a is stored. 
                           // Cannot call a non-const function set_i
bind(&amp;A::set_j, a, _1)(k); // a.j == 0, as a copy of a is modified
</pre>
When a pointer is used, the behavior is what the programmer might expect:

<pre class="programlisting">
A a(0,0); int k = 1;
bind(&amp;A::set_i, &amp;a, _1)(k); // a.i == 1
bind(&amp;A::set_j, &amp;a, _1)(k); // a.j == 1
</pre>

Even though a const copy of the object argument is stored, the original object <tt>a</tt> is still modified.
This is since the object argument is a pointer, and the pointer is copied, not the object it points to.
When we use a reference, the behaviour is different:

<pre class="programlisting">
A a(0,0); int k = 1;
bind(&amp;A::set_i, a, _1)(k); // error; a const copy of a is stored. 
                           // Cannot call a non-const function set_i
bind(&amp;A::set_j, a, _1)(k); // a.j == 0, as a copy of a is modified
</pre>
</p><p>
コピーの発生を防ぐためには、次のように <tt>ref</tt> や <tt>cref</tt> のラッパを使用すればよい。(<tt>var</tt> や <tt>constant_ref</tt> も同様である )
<pre class="programlisting">
bind(&amp;A::set_i, ref(a), _1)(k); // a.j == 1
bind(&amp;A::set_j, cref(a), _1)(k); // a.j == 1
</pre>
</p><p>
To prevent the copying from taking place, one can use the <tt>ref</tt> or <tt>cref</tt> wrappers (<tt>var</tt> and <tt>constant_ref</tt> would do as well):
<pre class="programlisting">
bind(&amp;A::set_i, ref(a), _1)(k); // a.j == 1
bind(&amp;A::set_j, cref(a), _1)(k); // a.j == 1
</pre>
</p><p>
ここまでの事項の内容は束縛された引数にのみ関係する。
オブジェクトが束縛されていない場合には、引数は常に参照として渡される。
よって、次の二つのλファンクタでは、引数 <tt>a</tt> はコピーされない。
<pre class="programlisting">
A a(0,0);
bind(&amp;A::set_i, _1, 1)(a); // a.i == 1
bind(&amp;A::set_j, _1, 1)(a); // a.j == 1
</pre>
</p><p>
Note that the preceding discussion is relevant only for bound arguments. 
If the object argument is unbound, the parameter passing mode is always by reference. 
Hence, the argument <tt>a</tt> is not copied in the calls to the two lambda functors below:
<pre class="programlisting">
A a(0,0);
bind(&amp;A::set_i, _1, 1)(a); // a.i == 1
bind(&amp;A::set_j, _1, 1)(a); // a.j == 1
</pre>
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="sect:members_variables_as_targets"></a>5.3.3. Member variables as targets</h4>
</div>
</div>
<p>
メンバ変数へのポインタは実際には関数ではない。
しかし、それにも関らず、関数 <tt>bind</tt> は第一引数にメンバ変数へのポインタを取ることが可能である。
このような bind を呼出すと、そのメンバ変数の参照が返される。
例えば、次のようになる。
<pre class="programlisting">
struct A { int data; };
A a;
bind(&amp;A::data, _1)(a) = 1;     // a.data == 1
</pre>
参照されるメンバ変数を持つオブジェクトの const/volatile の修飾子は尊重される。
例えば、次の例では const な位置へ書き込もうとしている。
For example, the following tries to write into a const location:
<pre class="programlisting">
const A ca = a;
bind(&amp;A::data, _1)(ca) = 1;     // error
</pre>

</p>
<p>
A pointer to a member variable is not really a function, but 
the first argument to the <tt>bind</tt> function can nevertheless
be a pointer to a member variable.
Invoking such a bind expression returns a reference to the data member.
For example:

<pre class="programlisting">
struct A { int data; };
A a;
bind(&amp;A::data, _1)(a) = 1;     // a.data == 1
</pre>

The cv-qualifiers of the object whose member is accessed are respected.
For example, the following tries to write into a const location:
<pre class="programlisting">
const A ca = a;
bind(&amp;A::data, _1)(ca) = 1;     // error
</pre>

</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="sect:function_objects_as_targets"></a>5.3.4. Function objects as targets</h4>
</div>
</div>
<p>
関数オブジェクトも目的の関数として使用できる。
関数オブジェクトとは、関数呼出し演算子が定義されたクラスオブジェクトのことである。
一般的には、BLL は任意の関数オブジェクトの返り値の型を推論することはできない。
しかし、この機能を特定の関数オブジェクトのクラスに提供する方法がある。
</p>
<p>

Function objects, that is, class objects which have the function call 
operator defined, can be used as target functions. 

In general, BLL cannot deduce the return type of an arbitrary function object. 

However, there is a method for giving BLL this capability for a certain 
function object class.

</p>
<div class="simplesect">
<div class="titlepage">
<div>
<h5 class="title"><a name="id2803238"></a>The sig template</h5>
</div>
</div>
<p>
BLL が関数オブジェクトの返り値の型を認識するためには、
<tt>type</tt> という返り値の型を指定する typedef を持った
<tt>sig&lt;Args&gt;</tt> メンバテンプレート構造体を提供する必要がある。
これが簡単な例である。
<pre class="programlisting">
struct A {
  template &lt;class Args&gt; struct sig { typedef B type; }
  B operator()(X, Y, Z); 
};
</pre>

To make BLL aware of the return type(s) of a function object one needs to 
provide a member template struct 
<tt>sig&lt;Args&gt;</tt> with a typedef 
<tt>type</tt> that specifies the return type.

Here is a simple example:
<pre class="programlisting">
struct A {
  template &lt;class Args&gt; struct sig { typedef B type; }
  B operator()(X, Y, Z); 
};
</pre>
テンプレート引数 <tt>Args</tt> は <tt>tuple</tt>(より正確に言えば、<tt>cons</tt>リスト) 型 [<a href="bi01.html#cit:boost::tuple" title="[tuple]">tuple</a>] である。
そして、最初の要素は関数オブジェクト自身であり、残りの要素は関数オブジェクトが呼ばれるときの引数の型である。
これは、<tt>return_type</tt> typedef で指定する標準ライブラリの関数オブジェクトの返り値の型の定義の仕様と比較すると、必要以上に複雑に見えるかもしれない。
しかし、返り値の型を単純な typedef で示すためには、二つの重要な制限が必要となる。
<br><br>

The template argument <tt>Args</tt> is a 
<tt>tuple</tt> (or more precisely a <tt>cons</tt> list) 
type [<a href="bi01.html#cit:boost::tuple" title="[tuple]">tuple</a>], where the first element 
is the function 
object type itself, and the remaining elements are the types of 
the arguments, with which the function object is being called.

This may seem overly complex compared to the Standard Library 
convention for defining the return type of a function
object with  the <tt>return_type</tt> typedef.
Howver, there are two significant restrictions with using just a simple
typedef to express the return type:
<div class="orderedlist">
<ol type="1">
<li>
<p>
関数オブジェクトが複数の関数呼出し演算子を定義していた場合、それらに対し異なる返り値の型を指定する方法がない。
<br><br>
If the function object defines several function call operators, there is no way to specify different result types for them.
</p>
</li>
<li>
<p>
関数呼出し演算子がテンプレートであった場合、返り値の型はそのテンプレート引数に依存するかもしれない。
よって、typedef もテンプレートであるはずである。しかし、C++ はこれをサポートしていない。
<br><br>
If the function call operator is a template, the result type may 
depend on the template parameters. 
Hence, the typedef ought to be a template too, which the C++ language 
does not support.
</p>
</li>
</ol>
</div>
以下のコードは、返り値の型が引数の一つの型に依存する例であり、
<tt>sig</tt> テンプレートによって、どのように依存関係を表現できるかを示している。
<pre class="programlisting">
struct A {

  // the return type equals the third argument type:
  template&lt;class T1, T2, T3&gt;
  T3 operator()(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3);

  template &lt;class Args&gt; 
  class sig {
    // get the third argument type (4th element)
    typedef typename 
      boost::tuples::element&lt;3, Args&gt;::type T3;
  public:
    typedef typename 
      boost::remove_cv&lt;T3&gt;::type type;
  }
};
</pre>

The following code shows an example, where the return type depends on the type
of one of the arguments, and how that dependency can be expressed with the
<tt>sig</tt> template:

<pre class="programlisting">
struct A {

  // the return type equals the third argument type:
  template&lt;class T1, T2, T3&gt;
  T3 operator()(const T1&amp; t1, const T2&amp; t2, const T3&amp; t3);

  template &lt;class Args&gt; 
  class sig {
    // get the third argument type (4th element)
    typedef typename 
      boost::tuples::element&lt;3, Args&gt;::type T3;
  public:
    typedef typename 
      boost::remove_cv&lt;T3&gt;::type type;
  }
};
</pre>
<tt>Args</tt> タプルの要素は常に参照でない型である。
さらに、要素の型は、const や volatile または、その両方によって修飾されることがある。
これにより、引数の const/volatile 修飾子によって、返り値の型へ影響を与えることが可能となる。
また、潜在的に const/volatile によって修飾子された関数オブジェクトの型自身が <tt>Args</tt> タプルに含まれていることにより、関数オブジェクトクラスは、const と 非 const (または、volatile や const volatile )の関数呼出し演算子を両方含むことができ、かつ、それぞれの異なる返り値の型とすることが可能となる。

<br><br>

The elements of the <tt>Args</tt> tuple are always 
non-reference types.

Moreover, the element types can have a const or volatile qualifier
(jointly referred to as <span class="emphasis"><i>cv-qualifiers</i></span>), or both.
This is since the cv-qualifiers in the arguments can affect the return type.
The reason for including the potentially cv-qualified function object 
type itself into the <tt>Args</tt> tuple, is that the function
object class can contain both const and non-const (or volatile, even
const volatile) function call operators, and they can each have a different
return type.
</p><p>
<tt>sig</tt> テンプレートは引数の型のタプルから、その型の引数をともなって呼ばれた場合の返り値の型への<span class="emphasis"><i>メタ関数</i></span>と見ることができる。
上で示した例のように、テンプレートは結局何かと複雑になってしまうことがある。
典型的な場合に実行されるのは、const/volatile 修飾子を取り除くなどして、タプルから関係のある型を取り出すことである。
これらのことの助けとなる手段については、Boost の type_traits [<a href="bi01.html#cit:boost::type_traits" title="[type_traits]">type_traits</a>] と Tuple [<a href="bi01.html#cit:boost::type_traits" title="[type_traits]">type_traits</a>] のライブラリを見よ。
<tt>sig</tt> テンプレートは最初に FC++ ライブラリ [<a href="bi01.html#cit:fc++" title="[fc++]">fc++</a>] で導入された同様な仕組を
洗練したものである。

</p><p>
The <tt>sig</tt> template can be seen as a 
<span class="emphasis"><i>meta-function</i></span> that maps the argument type tuple to 
the result type of the call made with arguments of the types in the tuple.

As the example above demonstrates, the template can end up being somewhat 
complex.
Typical tasks to be performed are the extraction of the relevant types 
from the tuple, removing cv-qualifiers etc.
See the Boost type_traits [<a href="bi01.html#cit:boost::type_traits" title="[type_traits]">type_traits</a>] and
Tuple [<a href="bi01.html#cit:boost::type_traits" title="[type_traits]">type_traits</a>] libraries 
for tools that can aid in these tasks.
The <tt>sig</tt> templates are a refined version of a similar
mechanism first introduced in the FC++ library  
[<a href="bi01.html#cit:fc++" title="[fc++]">fc++</a>].
</p>
</div>
<p>
初期のバージョンのライブラリでは、標準ライブラリの仕様をデフォルトでサポートしており、<tt>sig</tt> テンプレートを認識させるためには特別な操作が必要であった。
現在の BLL では、これが逆になっている。
標準ライブラリの仕様に従ったファンクタを bind 式で使用する必要があるときのために、
<tt>std_functor</tt> ラッパ が提供されている。
このラッパにより、<tt>result_type</tt> typedef に基づいて、<tt>sig</tt> テンプレートが用意される。
例えば、次のようになる。
<pre class="programlisting">
int i = 1;
bind(plus&lt;int&gt;(), _1, 1)(i);              // error, no sig template
bind(std_functor(plus&lt;int&gt;()), _1, 1)(i); // ok
</pre>

</p>
<p>
Earlier versions of the library supported the Standard Library convention
as the default, and required special actions to make the library recognize
the <tt>sig</tt> template. 
Now the BLL has that reversed.

If one needs to use a functor that adheres to the Standard Library
convention in a bind expression, we provide the <tt>std_functor</tt>
wrapper, that gives the function object a <tt>sig</tt>
template based on the <tt>result_type</tt> typedef.
For example:

<pre class="programlisting">
int i = 1;
bind(plus&lt;int&gt;(), _1, 1)(i);              // error, no sig template
bind(std_functor(plus&lt;int&gt;()), _1, 1)(i); // ok
</pre>

</p>
</div>
</div>
<div class="section">
<div class="titlepage">
<div>
<h3 class="title"><a name="sect:overriding_deduced_return_type"></a>5.4. Overriding the deduced return type</h3>
</div>
</div>
<p>
返り値の型推論システムは一部のユーザ定義の演算子とクラスオブジェクトを含んだ bind 式の返り値の型を解決できないかもしれない。
返り値の型を明示し、型推論システムをオーバーライドするために、特別なλ式の型が提供されている。
λ式 <tt>e</tt> で定義されるλファンクタの返り値が <tt>T</tt> であると示すには、次のように記述すればよい。
<pre class="programlisting">ret&lt;T&gt;(e);</pre>

The return type deduction system may not be able to deduce the return types of some user defined operators or bind expressions with class objects.

A special lambda expression type is provided for stating the return type explicitly and overriding the deduction system. 
To state that the return type of the lambda functor defined by the lambda expression <tt>e</tt> is <tt>T</tt>, you can write:

<pre class="programlisting">ret&lt;T&gt;(e);</pre>

これにより、λ式 <tt>e</tt> には返り値の型推論が一切行われない。そのかわりに、<tt>T</tt> が返り値として使用される。
明かに、<tt>T</tt> には任意の型が指定できるわけではない。
真のλファンクタの型は暗黙的に <tt>T</tt> に変換可能でなければならない。
例えば、次のようなことである。
<pre class="programlisting">
A a; B b;
C operator+(A, B);
int operator*(A, B); 
  ...
ret&lt;D&gt;(_1 + _2)(a, b);     // error (C cannot be converted to D)
ret&lt;C&gt;(_1 + _2)(a, b);     // ok
ret&lt;float&gt;(_1 * _2)(a, b); // ok (int can be converted to float)
  ...
struct X {
  Y operator(int)();   
};
  ...
X x; int i;
bind(x, _1)(i);            // error, return type cannot be deduced
ret&lt;Y&gt;(bind(x, _1))(i);    // ok
</pre>

The effect is that the return type deduction is not performed for the lambda expression <tt>e</tt> at all, but instead, <tt>T</tt> is used as the return type. 
Obviously <tt>T</tt> cannot be an arbitrary type, the true result of the lambda functor must be implicitly convertible to <tt>T</tt>. 
For example:

<pre class="programlisting">
A a; B b;
C operator+(A, B);
int operator*(A, B); 
  ...
ret&lt;D&gt;(_1 + _2)(a, b);     // error (C cannot be converted to D)
ret&lt;C&gt;(_1 + _2)(a, b);     // ok
ret&lt;float&gt;(_1 * _2)(a, b); // ok (int can be converted to float)
  ...
struct X {
  Y operator(int)();   
};
  ...
X x; int i;
bind(x, _1)(i);            // error, return type cannot be deduced
ret&lt;Y&gt;(bind(x, _1))(i);    // ok
</pre>
bind 式に関しては、<tt>ret</tt> の代わりに使用できる簡便な表記がある。
先の例の最後の行は、次のように記述することが可能である。
<pre class="programlisting">bind&lt;Z&gt;(x, _1)(i);</pre>
この機能は Boost Bind library [<a href="bi01.html#cit:boost::bind" title="[bind]">bind</a>] に倣ったものである。
<br><br>

For bind expressions, there is a short-hand notation that can be used instead of <tt>ret</tt>. 
The last line could alternatively be written as:

<pre class="programlisting">bind&lt;Z&gt;(x, _1)(i);</pre>

This feature is modeled after the Boost Bind library [<a href="bi01.html#cit:boost::bind" title="[bind]">bind</a>].

</p><p>
ネストしたλ式中においては、
<tt>ret</tt> はそれなしでは返り値の型推論に失敗するそれぞれの部分式について使用しなければならない。
例えば次のようなことである。
<pre class="programlisting">
A a; B b;
C operator+(A, B); D operator-(C);
  ...
ret&lt;D&gt;( - (_1 + _2))(a, b); // error 
ret&lt;D&gt;( - ret&lt;C&gt;(_1 + _2))(a, b); // ok
</pre>
</p><p>
Note that within nested lambda expressions, 
the <tt>ret</tt> must be used at each subexpression where 
the deduction would otherwise fail. 
For example:
<pre class="programlisting">
A a; B b;
C operator+(A, B); D operator-(C);
  ...
ret&lt;D&gt;( - (_1 + _2))(a, b); // error 
ret&lt;D&gt;( - ret&lt;C&gt;(_1 + _2))(a, b); // ok
</pre>
</p><p>
もし、<tt>ret</tt> を同一の型に何度も使用しているのであれば、
返り値の型推論を拡張する価値がある。
(詳しくは <a href="ar01s06.html#sect:extending_return_type_system" title="6. Extending return type deduction system">Section 6</a> を見よ)
</p><p>
If you find yourself using  <tt>ret</tt> repeatedly with the same types, it is worth while extending the return type deduction (see <a href="ar01s06.html#sect:extending_return_type_system" title="6. Extending return type deduction system">Section 6</a>).
</p>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="sect:nullary_functors_and_ret"></a>5.4.1. Nullary lambda functors and ret</h4>
</div>
</div>
<p>
ここまでで示したように、<tt>ret</tt> により返り値の型推論を実行することを防ぐことができる。
しかし、例外もある。
<font color="red">
C++ のテンプレートのインスタンス化の働きのために、コンパイラは 0 引数のλファンクタに関しては、常に返り値の型が解決されたテンプレートのインスタンス化を強制する。
</font>
これにより、<tt>ret</tt> にちょっとした問題が発生する。
次の例がそれをよく表わしている。
<pre class="programlisting">
struct F { int operator()(int i) const; }; 
F f;
  ...
bind(f, _1);           // fails, cannot deduce the return type
ret&lt;int&gt;(bind(f, _1)); // ok
  ...
bind(f, 1);            // fails, cannot deduce the return type
ret&lt;int&gt;(bind(f, 1));  // fails as well!
</pre>

As stated above, the effect of <tt>ret</tt> is to prevent the return type deduction to be performed. 
However, there is an exception. 
Due to the way the C++ template instantiation works, the compiler is always forced to instantiate the return type deduction templates for zero-argument lambda functors.
This introduces a slight problem with <tt>ret</tt>, best described with an example:

<pre class="programlisting">
struct F { int operator()(int i) const; }; 
F f;
  ...
bind(f, _1);           // fails, cannot deduce the return type
ret&lt;int&gt;(bind(f, _1)); // ok
  ...
bind(f, 1);            // fails, cannot deduce the return type
ret&lt;int&gt;(bind(f, 1));  // fails as well!
</pre>
BLL は <tt>F</tt> は <tt>result_type</tt> typedef を定義していないため、
上のような bind の呼出しの返り値の型を推論することはできない。
<tt>ret</tt> がこれを解決してくれるだろうと期待するかもしれないが、
(上の例の最後の行のような) bind 式の結果である引数なしのλファンクタに関しては、うまく機能しないのである。
<font color="red">
たとえ不必要であったとしても、返り値の型が解決されたテンプレートがインスタンス化される。その結果としてコンパイル時エラーとなる。
</font>
<br><br>

The BLL cannot deduce the return types of the above bind calls, as <tt>F</tt> does not define the typedef <tt>result_type</tt>. 
One would expect <tt>ret</tt> to fix this, but for the nullary lambda functor that results from a bind expression (last line above) this does not work.
The return type deduction templates are instantiated, even though it would not be necessary and the result is a compilation error.

</p><p>
この問題の解決法は関数 <tt>ret</tt> を使用することではなく、次のように <tt>bind</tt> の呼出しにおいて、テンプレート引数で明示的に返り値の型を指定することである。
<pre class="programlisting">
bind&lt;int&gt;(f, 1);       // ok
</pre>
<tt>ret&lt;<i><tt>T</tt></i>&gt;(bind(<i><tt>arg-list</tt></i>))</tt> から生成されたλファンクタと、<tt>bind&lt;<i><tt>T</tt></i>&gt;(<i><tt>arg-list</tt></i>)</tt> から生成されたλファンクタは全く同一の機能を持つ。
&#8212;
異なるのは前者は一部の無引数のλファンクタにおいてうまく動作しないのに対し、後者はその場合にも動作するということである。
</p><p>
The solution to this is not to use the <tt>ret</tt> function, but rather define the return type as an explicitly specified template parameter in the <tt>bind</tt> call:
<pre class="programlisting">
bind&lt;int&gt;(f, 1);       // ok
</pre>

The lambda functors created with 
<tt>ret&lt;<i><tt>T</tt></i>&gt;(bind(<i><tt>arg-list</tt></i>))</tt> and 
<tt>bind&lt;<i><tt>T</tt></i>&gt;(<i><tt>arg-list</tt></i>)</tt> have the exact same functionality &#8212;
apart from the fact that for some nullary lambda functors the former does not work while the latter does. 
</p>
</div>
</div>
<div class="section">
<div class="titlepage">
<div>
<h3 class="title"><a name="sect:delaying_constants_and_variables"></a>5.5. Delaying constants and variables</h3>
</div>
</div>
<p>
単項関数 <tt>constant</tt> と <tt>constant_ref</tt> と <tt>var</tt> は引数を<font color="red">同一のマッピングを実装する</font> λファンクタへと変化させる。
前の二つは定数に用い、最後のものは変数に用いる。
これらの<span class="emphasis"><i>評価を遅延させた</i></span>定数や変数は、明示的なλ式の文法がないために必要となる。
例を挙げると、
<pre class="programlisting">
for_each(a.begin(), a.end(), cout &lt;&lt; _1 &lt;&lt; ' ');
for_each(a.begin(), a.end(), cout &lt;&lt; ' ' &lt;&lt; _1);
</pre>

The unary functions <tt>constant</tt>,
<tt>constant_ref</tt> and <tt>var</tt> turn their argument into a lambda functor, that implements an identity mapping.
The former two are for constants, the latter for variables. 
The use of these <span class="emphasis"><i>delayed</i></span> constants and variables is sometimes necessary due to the lack of explicit syntax for lambda expressions. 
For example:
<pre class="programlisting">
for_each(a.begin(), a.end(), cout &lt;&lt; _1 &lt;&lt; ' ');
for_each(a.begin(), a.end(), cout &lt;&lt; ' ' &lt;&lt; _1);
</pre>
最初の行では、<tt>a</tt>の要素を空白で区切って出力するが、
二行目では、一つ空白を出力しそのあとに区切なしで、<tt>a</tt>の要素を出力する。
これは、<tt>cout &lt;&lt; ' '</tt> のオペランドのいずれもλ式でないためである。
よって、<tt>cout &lt;&lt; ' '</tt> が即座に評価されてしまうのである。
<tt>cout &lt;&lt; ' '</tt> の評価を遅延させるためには、オペランドの一つをλ式であると明示的に示さなくてはならない。
これは、関数 <tt>constant</tt> によって行なえる。
<pre class="programlisting">
for_each(a.begin(), a.end(), cout &lt;&lt; constant(' ') &lt;&lt; _1);
</pre>

The first line outputs the elements of <tt>a</tt> separated by spaces, while the second line outputs a space followed by the elements of <tt>a</tt> without any separators.
The reason for this is that neither of the operands of 
<tt>cout &lt;&lt; ' '</tt> is a lambda expression, hence <tt>cout &lt;&lt; ' '</tt> is evaluated immediately.

To delay the evaluation of <tt>cout &lt;&lt; ' '</tt>, one of the operands must be explicitly marked as a lambda expression. 
This is accomplished with the <tt>constant</tt> function:
<pre class="programlisting">
for_each(a.begin(), a.end(), cout &lt;&lt; constant(' ') &lt;&lt; _1);
</pre>

<tt>constant(' ')</tt>の呼出しにより、無引数のλファンクタが生成される。
このファンクタは、定数文字<tt>' '</tt>を格納し、呼出されたときにこの文字への参照を返す。
関数 <tt>constant_ref</tt> も、引数の定数への参照を格納するという点を除いて、同様である。
<tt>constant</tt> と <tt>constant_ref</tt> は上記の例のように、演算子の呼出しに副作用があるときにのみ必要となる。

<br><br>

The call <tt>constant(' ')</tt> creates a nullary lambda functor which stores the character constant <tt>' '</tt> 
and returns a reference to it when invoked. 
The function <tt>constant_ref</tt> is similar, except that it
stores a constant reference to its argument.

The <tt>constant</tt> and <tt>consant_ref</tt> are only
needed when the operator call has side effects, like in the above example.

</p><p>
時々変数の評価を遅延させる必要がある。
コンテンナの要素を番号付けしたリストとして出力したいとする。
<pre class="programlisting">
int index = 0; 
for_each(a.begin(), a.end(), cout &lt;&lt; ++index &lt;&lt; ':' &lt;&lt; _1 &lt;&lt; '\n');
for_each(a.begin(), a.end(), cout &lt;&lt; ++var(index) &lt;&lt; ':' &lt;&lt; _1 &lt;&lt; '\n');
</pre>
最初の行の <tt>for_each</tt> の呼出しは期待通りには動作しない。
<tt>index</tt> は一度だけインクリメントされ、その値が一度だけ出力ストリームに書き出される。
<tt>var</tt> を使用して、<tt>index</tt> をλ式とすることにより、望む効果が得られる。
</p><p>
Sometimes we need to delay the evaluation of a variable. 
Suppose we wanted to output the elements of a container in a numbered list:

<pre class="programlisting">
int index = 0; 
for_each(a.begin(), a.end(), cout &lt;&lt; ++index &lt;&lt; ':' &lt;&lt; _1 &lt;&lt; '\n');
for_each(a.begin(), a.end(), cout &lt;&lt; ++var(index) &lt;&lt; ':' &lt;&lt; _1 &lt;&lt; '\n');
</pre>

The first <tt>for_each</tt> invocation does not do what we want; <tt>index</tt> is incremented only once, and its value is written into the output stream only once.
By using <tt>var</tt> to make <tt>index</tt> a lambda expression, we get the desired effect.

</p><p>
まとめると、<tt>var(x)</tt> は変数 <tt>x</tt>への参照を格納した無引数のλファンクタを生成する。
このλファンクタが呼出されると、<tt>x</tt> への参照が返される。
</p><p>
In sum, <tt>var(x)</tt> creates a nullary lambda functor, 
which stores a reference to the variable <tt>x</tt>. 
When the lambda functor is invoked, a reference to <tt>x</tt> is returned.
</p>
<div class="simplesect">
<div class="titlepage">
<div>
<h4 class="title"><a name="id2804084"></a>Naming delayed constants and variables</h4>
</div>
</div>
<p>
λ式の外側で遅延評価する変数や定数を前もって定義し、名前付けすることも可能である。
テンプレート <tt>var_type</tt> や <tt>constant_type</tt> 
や <tt>constant_ref_type</tt> はこの目的のために提供されている。
これらは次のように使用する。
<pre class="programlisting">
var_type&lt;T&gt;::type delayed_i(var(i));
constant_type&lt;T&gt;::type delayed_c(constant(c));
</pre>

It is possible to predefine and name a delayed variable or constant outside a lambda expression. 
The templates <tt>var_type</tt>, <tt>constant_type</tt> 
and <tt>constant_ref_type</tt> serve for this purpose. 
They are used as:
<pre class="programlisting">
var_type&lt;T&gt;::type delayed_i(var(i));
constant_type&lt;T&gt;::type delayed_c(constant(c));
</pre>
最初の行では、型 <tt>T</tt> の変数 <tt>i</tt> の遅延評価用の変数 <tt>delayed_i</tt> を定義している。
同様に、二行目では、定数 <tt>c</tt> の遅延評価用の定数として <tt>delayed_c</tt>を定義している。
例えば、
<pre class="programlisting">
int i = 0; int j;
for_each(a.begin(), a.end(), (var(j) = _1, _1 = var(i), var(i) = var(j))); 
</pre>
は次のものと等価である。
<pre class="programlisting">
int i = 0; int j;
var_type&lt;int&gt;::type vi(var(i)), vj(var(j));
for_each(a.begin(), a.end(), (vj = _1, _1 = vi, vi = vj));
</pre>

The first line defines the variable <tt>delayed_i</tt> which is a delayed version of the variable <tt>i</tt> of type <tt>T</tt>.
Analogously, the second line defines the constant <tt>delayed_c</tt> as a delayed version of the constant <tt>c</tt>.
For example:
<pre class="programlisting">
int i = 0; int j;
for_each(a.begin(), a.end(), (var(j) = _1, _1 = var(i), var(i) = var(j))); 
</pre>
is equivalent to:
<pre class="programlisting">
int i = 0; int j;
var_type&lt;int&gt;::type vi(var(i)), vj(var(j));
for_each(a.begin(), a.end(), (vj = _1, _1 = vi, vi = vj));
</pre>

</p><p>
遅延評価する定数の名前付けの例を挙げると、
<pre class="programlisting">
constant_type&lt;char&gt;::type space(constant(' '));
for_each(a.begin(),a.end(), cout &lt;&lt; space &lt;&lt; _1);
</pre>
</p><p>
Here is an example of naming a delayed constant:
<pre class="programlisting">
constant_type&lt;char&gt;::type space(constant(' '));
for_each(a.begin(),a.end(), cout &lt;&lt; space &lt;&lt; _1);
</pre>
</p>
</div>
<div class="simplesect">
<div class="titlepage">
<div>
<h4 class="title"><a name="id2804207"></a>About assignment and subscript operators</h4>
</div>
</div>
<p>
<a href="ar01s05.html#sect:assignment_and_subscript" title="5.2.2. Assignment and subscript operators">Section 5.2.2</a>
で示したように、代入と添字の演算子は常にメンバ関数として定義される。
このため、
<tt>x = y</tt> や <tt>x[y]</tt>
の形の式がλ式と解釈されるためには、左側のオペランドはλ式でなければならない。
結果として、<tt>var</tt>をこの目的のために使用しなければならない場合がある。
次に、<a href="ar01s05.html#sect:assignment_and_subscript" title="5.2.2. Assignment and subscript operators">Section 5.2.2</a>の例を再び示す。
<pre class="programlisting">
int i; 
i = _1;       // error
var(i) = _1;  // ok
</pre>
</p><p>
As described in <a href="ar01s05.html#sect:assignment_and_subscript" title="5.2.2. Assignment and subscript operators">Section 5.2.2</a>, assignment and subscripting operators are always defined as member functions.
This means, that for expressions of the form
<tt>x = y</tt> or <tt>x[y]</tt> to be interpreted as lambda expressions, the left-hand operand <tt>x</tt> must be a lambda expression. 
Consequently, it is sometimes necessary to use <tt>var</tt> for this purpose.
We repeat the example from <a href="ar01s05.html#sect:assignment_and_subscript" title="5.2.2. Assignment and subscript operators">Section 5.2.2</a>:

<pre class="programlisting">
int i; 
i = _1;       // error
var(i) = _1;  // ok
</pre>
</p><p>
<tt>+=</tt> や <tt>-=</tt> といった複合代入演算子は非メンバ関数として定義することが可能である。そのため、たとえ右側のオペランドのみがλ式であったとしても、これらの式はλ式として解釈される。
しかしながら、左側のオペランドを明示的に遅延評価させても全く問題ない。
例えば、<tt>i += _1</tt> と <tt>var(i) += _1</tt> は等価である。
</p><p>
Note that the compound assignment operators <tt>+=</tt>, <tt>-=</tt> etc. can be defined as non-member functions, and thus they are interpreted as lambda expressions even if only the right-hand operand is a lambda expression.
Nevertheless, it is perfectly ok to delay the left operand explicitly. 
For example, <tt>i += _1</tt> is equivalent to <tt>var(i) += _1</tt>.
</p>
</div>
</div>
<div class="section">
<div class="titlepage">
<div>
<h3 class="title"><a name="sect:lambda_expressions_for_control_structures"></a>5.6. Lambda expressions for control structures</h3>
</div>
</div>
<p>
BLL は制御構造を表現するλファンクタを生成するいくつかの関数を定義している。
それらは、引数としてλファンクを取り、返り値は <tt>void</tt> である。
まず、例を提示する。以下のコードはあるコンテナ <tt>a</tt>の偶数の要素をすべて出力する。
<pre class="programlisting">
for_each(a.begin(), a.end(), 
         if_then(_1 % 2 == 0, cout &lt;&lt; _1));  
</pre>
</p><p>
BLL defines several functions to create lambda functors that represent control structures. 
They all take lambda functors as parameters and return <tt>void</tt>.
To start with an example, the following code outputs all even elements of some container <tt>a</tt>:

<pre class="programlisting">
for_each(a.begin(), a.end(), 
         if_then(_1 % 2 == 0, cout &lt;&lt; _1));  
</pre>
</p><p>
BLL は制御構造のために以下の関数テンプレートをサポートする。
<pre class="programlisting">
if_then(condition, then_part)
if_then_else(condition, then_part, else_part)
if_then_else_return(condition, then_part, else_part)
while_loop(condition, body)
while_loop(condition) // no body case
do_while_loop(condition, body)
do_while_loop(condition) // no body case 
for_loop(init, condition, increment, body)
for_loop(init, condition, increment) // no body case
switch_statement(...)
</pre>

The BLL supports the following function templates for control structures: 
<pre class="programlisting">
if_then(condition, then_part)
if_then_else(condition, then_part, else_part)
if_then_else_return(condition, then_part, else_part)
while_loop(condition, body)
while_loop(condition) // no body case
do_while_loop(condition, body)
do_while_loop(condition) // no body case 
for_loop(init, condition, increment, body)
for_loop(init, condition, increment) // no body case
switch_statement(...)
</pre>

すべての制御構造のλファンクタの返り値は <tt>void</tt>である。
例外は、次の条件演算子の呼出しをラップする <tt>if_then_else_return</tt>
だけである。
<pre class="programlisting">
condition ? then_part : else_part
</pre>

The return types of all control construct lambda functor is 
<tt>void</tt>, except for <tt>if_then_else_return</tt>,
which wraps a call to the conditional operator 
<pre class="programlisting">
condition ? then_part : else_part
</pre>

この演算子の返り値の型の規則は少々複雑である。
基本的には、両方の分岐の結果の型が同一であれば、その型が返り値の型である。
分岐の型の結果が異なるのであれば、
片方の分岐の結果、例えば <tt>A</tt> はもう一つの分岐の結果、例えば <tt>B</tt>
に変換可能でなければならない。
このような状況では、返り値の型は <tt>B</tt>である。
さらに、共通の型が左辺値であれば、返り値も左辺値になるであろう。

<br><br>

The return type rules for this operator are somewhat complex. 
Basically, if the branches have the same type, this type is the return type.
If the type of the branches differ, one branch, say of type 
<tt>A</tt>, must be convertible to the other branch, 
say of type <tt>B</tt>.
In this situation, the result type is <tt>B</tt>.
Further, if the common type is an lvalue, the return type will be an lvalue
too.
</p><p>

遅延評価される変数は、制御構造のλ式によく現れる。
例えば、ここでは、<tt>for_loop</tt> の引数をλ式に変換するために <tt>var</tt>を使用している。
次のコードは二次元配列の各要素に 1 を加えるものである。
<pre class="programlisting">
int a[5][10]; int i;
for_each(a, a+5, 
  for_loop(var(i)=0, var(i)&lt;10, ++var(i), 
           _1[var(i)] += 1));  
</pre>

</p><p>

Delayed variables tend to be commonplace in control structure lambda expressions. 
For instance, here we use the <tt>var</tt> function to turn the arguments of <tt>for_loop</tt> into lambda expressions. 
The effect of the code is to add 1 to each element of a two-dimensional array:

<pre class="programlisting">
int a[5][10]; int i;
for_each(a, a+5, 
  for_loop(var(i)=0, var(i)&lt;10, ++var(i), 
           _1[var(i)] += 1));  
</pre>

</p><p>
BLL は Joel de Guzmann が提案した、別な制御式の文法もサポートしている。
<tt>operator[]</tt> をオーバーロードすることにより、
組み込みの制御構造と非常によく似たものを実現できる。
<pre class="programlisting">
if_(condition)[then_part]
if_(condition)[then_part].else_[else_part]
while_(condition)[body]
do_[body].while_(condition)
for_(init, condition, increment)[body]
</pre>
例えば、この文法を使用すると 上記の <tt>if_then</tt> の例は次のように記述することができる。
<pre class="programlisting">
for_each(a.begin(), a.end(), 
         if(_1 % 2 == 0)[ cout &lt;&lt; _1 ])  
</pre>
<font color="red">
経験を積むと、これらのいくつかを結局は非難するかもしれない。
</font>
</p><p>

The BLL supports an alternative syntax for control expressions, suggested
by Joel de Guzmann. 
By overloading the <tt>operator[]</tt> we can
get a closer resemblance with the built-in control structures:

<pre class="programlisting">
if_(condition)[then_part]
if_(condition)[then_part].else_[else_part]
while_(condition)[body]
do_[body].while_(condition)
for_(init, condition, increment)[body]
</pre>

For example, using this syntax the <tt>if_then</tt> example above
can be written as:
<pre class="programlisting">
for_each(a.begin(), a.end(), 
         if(_1 % 2 == 0)[ cout &lt;&lt; _1 ])  
</pre>

As more experience is gained, we may end up deprecating one or the other 
of these syntaces. 

</p>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="sect:switch_statement"></a>5.6.1. Switch statement</h4>
</div>
</div>
</div>
<p>
数多くの場合があるため、<tt>switch</tt> 文の制御構造のλ式はもう少し複雑である。
一般的な switch 文のλ式の形は次のようになる。
<pre class="programlisting">
switch_statement(<i><tt>condition</tt></i>, 
  case_statement&lt;<i><tt>label</tt></i>&gt;(<i><tt>lambda expression</tt></i>),
  case_statement&lt;<i><tt>label</tt></i>&gt;(<i><tt>lambda expression</tt></i>),
  ...
  default_statement(<i><tt>lambda expression</tt></i>)
)
</pre>

<tt><i><tt>condition</tt></i></tt> 引数は全体の返り値の型をともなったλファンクタを生成するλ式でなければならない。
関数 <tt>case_statement</tt> によって各 case 文が生成され、
関数 <tt>default_statement</tt> によってオプションである default 文が生成される。
case 文のラベルは関数 <tt>case_statement</tt> へのテンプレート引数によって明示的に指定され、<tt>break</tt> 文は暗黙的に各 case 文に含まれている。
例えば、<tt>a</tt> があるλファンクタであるとして、<tt>case_statement&lt;1&gt;(a)</tt> は次のようなコードを生成する。
<pre class="programlisting">
case 1: 
  <i><tt>evaluate lambda functor</tt></i> a; 
  break;
</pre>
<font color="red">
関数 <tt>switch_statement</tt> は 9 つまでの case 文に特化されている。
</font>
</p><p>

The lambda expressions for <tt>switch</tt> control structures are more complex since the number of cases may vary. 
The general form of a switch lambda expression is:

<pre class="programlisting">
switch_statement(<i><tt>condition</tt></i>, 
  case_statement&lt;<i><tt>label</tt></i>&gt;(<i><tt>lambda expression</tt></i>),
  case_statement&lt;<i><tt>label</tt></i>&gt;(<i><tt>lambda expression</tt></i>),
  ...
  default_statement(<i><tt>lambda expression</tt></i>)
)
</pre>

The <tt><i><tt>condition</tt></i></tt> argument must be a lambda expression that creates a lambda functor with an integral return type.
The different cases are created with the <tt>case_statement</tt> functions, and the optional default case with the <tt>default_statement</tt> function.
The case labels are given as explicitly specified template arguments to <tt>case_statement</tt> functions and 
<tt>break</tt> statements are implicitly part of each case. 
For example, <tt>case_statement&lt;1&gt;(a)</tt>, where <tt>a</tt> is some lambda functor,  generates the code:

<pre class="programlisting">
case 1: 
  <i><tt>evaluate lambda functor</tt></i> a; 
  break;
</pre>
The <tt>switch_statement</tt> function is specialized for up to 9 case statements.

</p><p>
switch 文の完全な例を示す。
次のコードでは、あるコンテナ <tt>v</tt> に関して反復しながら、0 の要素ごとに &#8220;zero&#8221; を、 1 の要素ごとに &#8220;one&#8221; を、その他の数 <i><tt>n</tt></i> に対しては、&#8220;other: <i><tt>n</tt></i>&#8221; という文字列を出力する。
各要素の後に改行を出力するために、<tt>switch_statement</tt> の後に別なλ式が続いている。

<pre class="programlisting">
std::for_each(v.begin(), v.end(),
  ( 
    switch_statement(
      _1,
      case_statement&lt;0&gt;(std::cout &lt;&lt; constant(&quot;zero&quot;)),
      case_statement&lt;1&gt;(std::cout &lt;&lt; constant(&quot;one&quot;)),
      default_statement(cout &lt;&lt; constant(&quot;other: &quot;) &lt;&lt; _1)
    ), 
    cout &lt;&lt; constant(&quot;\n&quot;) 
  )
);
</pre>
</p><p>
As a concrete example, the following code iterates over some container <tt>v</tt> and ouptuts &#8220;zero&#8221; for each <tt>0</tt>, &#8220;one&#8221; for each <tt>1</tt>, and &#8220;other: <i><tt>n</tt></i>&#8221; for any other value <i><tt>n</tt></i>.
Note that another lambda expression is sequenced after the <tt>switch_statement</tt> to output a line break after each element:

<pre class="programlisting">
std::for_each(v.begin(), v.end(),
  ( 
    switch_statement(
      _1,
      case_statement&lt;0&gt;(std::cout &lt;&lt; constant(&quot;zero&quot;)),
      case_statement&lt;1&gt;(std::cout &lt;&lt; constant(&quot;one&quot;)),
      default_statement(cout &lt;&lt; constant(&quot;other: &quot;) &lt;&lt; _1)
    ), 
    cout &lt;&lt; constant(&quot;\n&quot;) 
  )
);
</pre>
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<h3 class="title"><a name="sect:exceptions"></a>5.7. Exceptions</h3>
</div>
</div>
<p>
BLL は 例外を送出したり、補足するλファンクタを提供している。
例外を送出するλファンクタは単項関数 <tt>throw_exception</tt> によって生成される。
この関数の引数は送出する例外か、送出する例外を生成するλファンクタである。
例外を再送出するλファンクタは、無項関数 <tt>rethrow</tt> によって生成される。
</p><p>
The BLL provides lambda functors that throw and catch exceptions.
Lambda functors for throwing exceptions are created with the unary function <tt>throw_exception</tt>.
The argument to this function is the exception to be thrown, or a lambda functor which creates the exception to be thrown.
A lambda functor for rethrowing exceptions is created with the nullary <tt>rethrow</tt> function.
</p><p>
例外を扱うλ式はもう少し複雑である。
try-catch ブロックの一般的なλ式の形は次のようになる。
<pre class="programlisting">
try_catch(
  <i><tt>lambda expression</tt></i>,
  catch_exception&lt;<i><tt>type</tt></i>&gt;(<i><tt>lambda expression</tt></i>),
  catch_exception&lt;<i><tt>type</tt></i>&gt;(<i><tt>lambda expression</tt></i>),
  ...
  catch_all(<i><tt>lambda expression</tt></i>)
)
</pre>
Lambda expressions for handling exceptions are somewhat more complex.
The general form of a lambda expression for try catch blocks is as follows:

<pre class="programlisting">
try_catch(
  <i><tt>lambda expression</tt></i>,
  catch_exception&lt;<i><tt>type</tt></i>&gt;(<i><tt>lambda expression</tt></i>),
  catch_exception&lt;<i><tt>type</tt></i>&gt;(<i><tt>lambda expression</tt></i>),
  ...
  catch_all(<i><tt>lambda expression</tt></i>)
)
</pre>
最初のλ式が try ブロックである。
各 <tt>catch_exception</tt> は補足する例外の型をテンプレート引数として明示的に指定して catch ブロックを定義する。
<tt>catch_exception</tt> 内のλ式では、例外を補足した際の動作を定義する。
参照として補足する例外ハンドラ、すなわち、<tt>catch_exception&lt;T&gt;(...)</tt> というλ式は次のような catch ブロックとなる。
<pre class="programlisting">
catch(T&amp; e) { ... }
</pre>

The first lambda expression is the try block. 
Each <tt>catch_exception</tt> defines a catch block where the 
explicitly specified template argument defines the type of the exception 
to catch.

The lambda expression within the <tt>catch_exception</tt> defines 
the actions to take if the exception is caught.

Note that the resulting exception handlers catch the exceptions as 
references, i.e., <tt>catch_exception&lt;T&gt;(...)</tt> 
results in the catch block:

<pre class="programlisting">
catch(T&amp; e) { ... }
</pre>
最後の catch ブロックは、<tt>catch_exception&lt;<i><tt>type</tt></i>&gt;</tt> 
または、<tt>catch(...)</tt> と等価のλ式 <tt>catch_all</tt> の呼出しとなる。

<br><br>

The last catch block can alternatively be a call to 
<tt>catch_exception&lt;<i><tt>type</tt></i>&gt;</tt> 
or to 
<tt>catch_all</tt>, which is the lambda expression equivalent to 
<tt>catch(...)</tt>.

</p><p>

<a href="ar01s05.html#ex:exceptions" title="Example 1. Throwing and handling exceptions in lambda expressions.">Example 1</a> では BLL の例外操作の機能の使い方の実例を示している。
最初の例外ハンドラは <tt>foo_exception</tt> 型の例外を補足する。
プレースホルダ <tt>_1</tt> をハンドラの内部で使用している。
</p><p>

The <a href="ar01s05.html#ex:exceptions" title="Example 1. Throwing and handling exceptions in lambda expressions.">Example 1</a> demonstrates the use of the BLL 
exception handling tools. 
The first handler catches exceptions of type <tt>foo_exception</tt>. 
Note the use of <tt>_1</tt> placeholder in the body of the handler.

</p><p>
二つ目の例外ハンドラでは、例外の送出の方法と、
<span class="emphasis"><i>例外プレースホルダ </i></span> <tt>_e</tt> の実例を示している。
この特別なプレースホルダは、補足した例外オブジェクトをハンドラの内部から参照している。
ここでは、例外の原因を説明する文字列が付随している <tt>std::exception</tt> 型の例外を扱っている。
この説明は無引数のメンバ関数 <tt>what</tt> により取り出すことができる。
<tt>bind(&amp;std::exception::what, _e)</tt> という式はこの関数を呼出すλファンクタを生成する。
<tt>_e</tt> は例外ハンドラを示すλ式の外側では使用できない。
二番目の例外ハンドラの最後の行では、新たな例外オブジェクトを構築し、
<font color="red"> 関数 <tt>throw_exception</tt> を使用して、</font>その例外オブジェクトを送出する。
λ式中における、オブジェクトの構築と破棄に関しては、
<a href="ar01s05.html#sect:construction_and_destruction" title="5.8. Construction and destruction">Section 5.8</a> において説明する。
</p><p>
The second handler shows how to throw exceptions, and demonstrates the 
use of the <span class="emphasis"><i>exception placeholder</i></span> <tt>_e</tt>.

It is a special placeholder, which refers to the caught exception object 
within the handler body.

Here we are handling an exception of type <tt>std::exception</tt>, 
which carries a string explaining the cause of the exception. 

This explanation can be queried with the zero-argument member 
function <tt>what</tt>.

The expression
<tt>bind(&amp;std::exception::what, _e)</tt> creates the lambda 
function for making that call.

Note that <tt>_e</tt> cannot be used outside of an exception handler lambda expression.


The last line of the second handler constructs a new exception object and 
throws that with <tt>throw exception</tt>. 

Constructing and destructing objects within lambda expressions is 
explained in <a href="ar01s05.html#sect:construction_and_destruction" title="5.8. Construction and destruction">Section 5.8</a>

</p><p>
そして、三番目の例外ハンドラ(<tt>catch_all</tt>)では、例外の再送出の実例を示す。
</p><p>
Finally, the third handler (<tt>catch_all</tt>) demonstrates 
rethrowing exceptions.
</p>
<div class="example">
<p>
<a name="ex:exceptions"></a><b>Example 1. Throwing and handling exceptions in lambda expressions.</b>
</p>
<pre class="programlisting">
for_each(
  a.begin(), a.end(),
  try_catch(
    bind(foo, _1),                 // foo may throw
    catch_exception&lt;foo_exception&gt;(
      cout &lt;&lt; constant(&quot;Caught foo_exception: &quot;) 
           &lt;&lt; &quot;foo was called with argument = &quot; &lt;&lt; _1
    ),
    catch_exception&lt;std::exception&gt;(
      cout &lt;&lt; constant(&quot;Caught std::exception: &quot;) 
           &lt;&lt; bind(&amp;std::exception::what, _e),
      throw_exception(bind(constructor&lt;bar_exception&gt;(), _1)))
    ),      
    catch_all(
      (cout &lt;&lt; constant(&quot;Unknown&quot;), rethrow())
    )
  )
);
</pre>
</div>
</div>
<div class="section">
<div class="titlepage">
<div>
<h3 class="title"><a name="sect:construction_and_destruction"></a>5.8. Construction and destruction</h3>
</div>
</div>
<p>
演算子 <tt>new</tt> と <tt>delete</tt> はオーバーロード可能であるが、
それらの返り値は共通である。
<font color="red">
特に、返り値はλファンクタとなることはない。
そのため、λ式のためにオーバーロードされることが防げる。
</font>

コンストラクタのアドレスを取得することはできない。
よって、コンストラクタは bind 式の対象として使用することはできない。
このことは、デストラクタに関しても同じである。
このような制限を回避するために、BLL は コンストラクタやデストラクタと同様に
<tt>new</tt> と <tt>delete</tt> の呼出しを行なうためのラッパのクラスを
定義している。
これらのクラスのインスタンスは関数オブジェクトであり、
bind 式の対象として使用することが可能である。
次に例を挙げる。
<pre class="programlisting">
int* a[10];
for_each(a, a+10, _1 = bind(new_ptr&lt;int&gt;())); 
for_each(a, a+10, bind(delete_ptr(), _1));
</pre>
Operators <tt>new</tt> and <tt>delete</tt> can be 
overloaded, but their return types are fixed. 

Particularly, the return types cannot be lambda functors, 
which prevents them to be overloaded for lambda expressions.

It is not possible to take the address of a constructor, 
hence constructors cannot be used as target functions in bind expressions.

The same is true for destructors.

As a way around these constraints, BLL defines wrapper classes for 
<tt>new</tt> and <tt>delete</tt> calls, 
as well as for constructors and destructors.

Instances of these classes are function objects, that can be used as 
target functions of bind expressions. 

For example:

<pre class="programlisting">
int* a[10];
for_each(a, a+10, _1 = bind(new_ptr&lt;int&gt;())); 
for_each(a, a+10, bind(delete_ptr(), _1));
</pre>
<font color="red">
<tt>new_ptr&lt;int&gt;()</tt> という式は、
呼出されたときに、<tt>new int()</tt>を呼出す関数オブジェクトを生成する。
そして、<tt>bind</tt> 中においてその呼出しをラップすることにより、
λファンクタとしている。
</font>
同様に、<tt>delete_ptr()</tt> という式は引数に対して、<tt>delete</tt>を
呼出す関数オブジェクトを生成する。
<tt>new_ptr&lt;<i><tt>T</tt></i>&gt;()</tt> も同様に引数を取ることができる。
その引数は直接コンストラクタの呼出しに渡される。
そして、そのことにより引数をとるコンストラクタの呼出しが可能になる。

<br><br>

The <tt>new_ptr&lt;int&gt;()</tt> expression creates 
a function object that calls <tt>new int()</tt> when invoked, 
and wrapping that inside <tt>bind</tt> makes it a lambda functor.

In the same way, the expression <tt>delete_ptr()</tt> creates 
a function object that invokes <tt>delete</tt> on its argument. 

Note that <tt>new_ptr&lt;<i><tt>T</tt></i>&gt;()</tt> 
can take arguments as well.

They are passed directly to the constructor invocation and thus allow 
calls to constructors which take arguments. 

</p><p>
λ式によるコンストラクタの例を示す。
以下のコードでは、二つのコンテナ <tt>x</tt> と <tt>y</tt> から整数を取り出し、
それらの pair を構築し、三つ目のコンテナへ挿入する。

<pre class="programlisting">
vector&lt;pair&lt;int, int&gt; &gt; v;
transform(x.begin(), x.end(), y.begin(), back_inserter(v),
          bind(constructor&lt;pair&lt;int, int&gt; &gt;(), _1, _2));
</pre>

<a href="ar01s05.html#table:constructor_destructor_fos" title="Table 1. Construction and destruction related function objects.">Table 1</a> にオブジェクトの構築と破棄に関するすべての関数オブジェクトをまとめた。
この表は、関数オブジェクトの生成と呼出しの式とこの式の評価の効果を示している。
</p><p>

As an example of constructor calls in lambda expressions, 
the following code reads integers from two containers <tt>x</tt> 
and <tt>y</tt>, 
constructs pairs out of them and inserts them into a third container:

<pre class="programlisting">
vector&lt;pair&lt;int, int&gt; &gt; v;
transform(x.begin(), x.end(), y.begin(), back_inserter(v),
          bind(constructor&lt;pair&lt;int, int&gt; &gt;(), _1, _2));
</pre>

<a href="ar01s05.html#table:constructor_destructor_fos" title="Table 1. Construction and destruction related function objects.">Table 1</a> lists all the function 
objects related to creating and destroying objects,
 showing the expression to create and call the function object, 
and the effect of evaluating that expression.

</p>
<div class="table">
<p><a name="table:constructor_destructor_fos"></a><b>Table 1. Construction and destruction related function objects.</b>
</p>
<table summary="Construction and destruction related function objects." border="1">
<colgroup>
<col><col>
</colgroup>
<thead>
<tr>
<th>Function object call</th>
<th>Wrapped expression</th>
</tr>
</thead>
<tbody>
<tr>
<td><tt>constructor&lt;T&gt;()(<i><tt>arg_list</tt></i>)</tt></td>
<td>T(<i><tt>arg_list</tt></i>)</td>
</tr>
<tr>
<td><tt>destructor()(a)</tt></td>
<td><tt>a.~A()</tt>, where <tt>a</tt> is of type <tt>A</tt></td>
</tr>
<tr>
<td><tt>destructor()(pa)</tt></td>
<td><tt>pa.-&gt;A()</tt>, where <tt>pa</tt> is of type <tt>A*</tt></td>
</tr>
<tr>
<td><tt>new_ptr&lt;T&gt;()(<i><tt>arg_list</tt></i>)</tt></td>
<td><tt>new T(<i><tt>arg_list</tt></i>)</tt></td>
</tr>
<tr>
<td><tt>new_array&lt;T&gt;()(sz)</tt></td>
<td><tt>new T[sz]</tt></td>
</tr>
<tr>
<td><tt>delete_ptr()(p)</tt></td>
<td><tt>delete p</tt></td>
</tr>
<tr>
<td><tt>delete_array()(p)</tt></td>
<td><tt>delete p[]</tt></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<div class="titlepage">
<div>
<h3 class="title"><a name="id2805476"></a>5.9. Special lambda expressions</h3>
</div>
</div>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="id2805483"></a>5.9.1. Preventing argument substitution</h4>
</div>
</div>
<p>
λファンクタが呼出されたとき、デフォルトの動作では、すべての部分式において実引数をプレースホルダと置き換える。
このサブセクションでは、置き換えと部分式の表を防ぐ方法を示し、
この機能が必要な場合に関して説明する。
</p><p>
When a lambda functor is called, the default behavior is to substitute 
the actual arguments for the placeholders within all subexpressions.

This section describes the tools to prevent the substitution and 
evaluation of a subexpression, and explains when these tools should be used.
</p><p>
bind 式の引数には任意のλ式がなることがありえる。
例えば、次のように別な bind 式が引数となることも可能である。
<pre class="programlisting">
int foo(int); int bar(int);
...
int i;
bind(foo, bind(bar, _1)(i);
</pre>
The arguments to a bind expression can be arbitrary lambda expressions, 
e.g., other bind expressions.

For example:
<pre class="programlisting">
int foo(int); int bar(int);
...
int i;
bind(foo, bind(bar, _1)(i);
</pre>
最後の行では、<tt>foo(bar(i));</tt> が呼出される。
bind 式の最初の引数は、つまり対象の関数は、<font color="red">例外がなく、</font> bind 式もこの引数となりうる。
一番内側のλファンクタは、別なλファンクタ、関数ポインタ、メンバ関数へのポインタといった、対象の関数として使用されるものを単に返せばよい。
例えば次のコードでは、一番内側のλファンクタは二つの関数の選択をし、
そのうちの一つへのポインタを返す。
<pre class="programlisting">
int add(int a, int b) { return a+b; }
int mul(int a, int b) { return a*b; }

int(*)(int, int)  add_or_mul(bool x) { 
  return x ? add : mul; 
}

bool condition; int i; int j;
...
bind(bind(&amp;add_or_mul, _1), _2, _3)(condition, i, j);
</pre>

The last line makes the call <tt>foo(bar(i));</tt>

Note that the first argument in a bind expression, the target function, 
is no exception, and can thus be a bind expression too.

The innermost lambda functor just has to return something that can be used 
as a target function: another lambda functor, function pointer, 
pointer to member function etc. 

For example, in the following code the innermost lambda functor makes 
a selection between two functions, and returns a pointer to one of them:

<pre class="programlisting">
int add(int a, int b) { return a+b; }
int mul(int a, int b) { return a*b; }

int(*)(int, int)  add_or_mul(bool x) { 
  return x ? add : mul; 
}

bool condition; int i; int j;
...
bind(bind(&amp;add_or_mul, _1), _2, _3)(condition, i, j);
</pre>

</p>
<div class="section">
<div class="titlepage">
<div>
<h5 class="title"><a name="sect:unlambda"></a>5.9.1.1. Unlambda</h5>
</div>
</div>
<p>
対象の関数がテンプレート引数に依存する型が可変である場合には、
いつのまにか bind 式がネストしてしまうことがある。
一般的に対象の関数は関数テンプレートの形式的引数となりうる。
このような場合には、プログラマは対象の関数がλファンクタかどうか知らないかもしれない。
</p><p>
A nested bind expression may occur inadvertently, 
if the target function is a variable with a type that depends on a 
template parameter. 

Typically the target function could be a formal parameter of a 
function template. 

In such a case, the programmer may not know whether the target function is a lambda functor or not.
</p><p>
次の関数テンプレートを考えてみる。
<pre class="programlisting">
template&lt;class F&gt;
int nested(const F&amp; f) {
  int x;
  ...
  bind(f, _1)(x);
  ...
}
</pre>
Consider the following function template:

<pre class="programlisting">
template&lt;class F&gt;
int nested(const F&amp; f) {
  int x;
  ...
  bind(f, _1)(x);
  ...
}
</pre>
この関数内では、形式的引数 <tt>f</tt> は bind 式の対象の関数として利用されている。
この <tt>bind</tt> の呼出しが有効であるためには、
<tt>f</tt> は単項関数でなければならない。
以下の二つの <tt>nested</tt> の呼出しを考えてみる。
<pre class="programlisting">
int foo(int);
int bar(int, int);
nested(&amp;foo);
nested(bind(bar, 1, _1));
</pre>

Somewhere inside the function the formal parameter
<tt>f</tt> is used as a target function in a bind expression. 
In order for this <tt>bind</tt> call to be valid, 
<tt>f</tt> must be a unary function.
Suppose the following two calls to <tt>nested</tt> are made:
<pre class="programlisting">
int foo(int);
int bar(int, int);
nested(&amp;foo);
nested(bind(bar, 1, _1));
</pre>

両方とも単項の関数または関数オブジェクトであり、適切な引数と返り値をもつ。
しかし、後者はコンパイルできない。
後者の呼出しにおいては、<tt>nested</tt> の内部の bind 式は次のようになってしまう。
<pre class="programlisting">
bind(bind(bar, 1, _1), _1) 
</pre>

Both are unary functions, or function objects, with appropriate argument 
and return types, but the latter will not compile.

In the latter call, the bind expression inside <tt>nested</tt> 
will become:

<pre class="programlisting">
bind(bind(bar, 1, _1), _1) 
</pre>
これが、引数 <tt>x</tt> をとって呼出されたとき、
置換され、結局は次のように呼出すこととなる。
<pre class="programlisting">
bar(1, x)(x)
</pre>
When this is invoked with <tt>x</tt>, 
after substituitions we end up trying to call

<pre class="programlisting">
bar(1, x)(x)
</pre>
これは、エラーとなる。
<tt>bar</tt> の呼出しの返り値は int であり、
単項の関数や関数オブジェクトではない。
<br><br>
which is an error. 

The call to <tt>bar</tt> returns int, 
not a unary function or function object.
</p><p>
上記の例では、<tt>nested</tt> 中の bind 式の意図は <tt>f</tt> を
λファンクタではなく、通常の関数オブジェクトとして扱うことである。
BLL は関数テンプレート <tt>unlambda</tt> を提供している。
この関数テンプレートにより、
<tt>unlambda</tt> の内部にラップされたλファンクタはもはやλファンクタではなく、引数の代入のプロセスには関係しない。
ということを表現する。
λファンクタ以外の型の引数に対しては、<tt>unlambda</tt> は
<font color="red">
const なオブジェクトを非 const に変更することを除いて、 
恒等演算
</font>である。
</p><p>
In the example above, the intent of the bind expression in the 
<tt>nested</tt> function is to treat <tt>f</tt> 
as an ordinary function object, instead of a lambda functor. 

The BLL provides the function template <tt>unlambda</tt> to 
express this: a lambda functor wrapped inside <tt>unlambda</tt> 
is not a lambda functor anymore, and does not take part into the 
argument substitution process.

Note that for all other argument types <tt>unlambda</tt> is 
an identity operation, except for making non-const objects const.
</p><p>
<tt>unlambda</tt> を利用して、
関数 <tt>nested</tt> は次のように書くことができる。
<pre class="programlisting">
template&lt;class F&gt;
int nested(const F&amp; f) {
  int x;
  ...
  bind(unlambda(f), _1)(x);
  ...
}
</pre>
Using <tt>unlambda</tt>, the <tt>nested</tt> 
function is written as:

<pre class="programlisting">
template&lt;class F&gt;
int nested(const F&amp; f) {
  int x;
  ...
  bind(unlambda(f), _1)(x);
  ...
}
</pre>

</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<h5 class="title"><a name="id2805742"></a>5.9.1.2. Protect</h5>
</div>
</div>
<p>
関数 <tt>protect</tt> は unlambda と関係がある。
この関数も引数の代入を防ぐために利用される。
しかし、<tt>unlambda</tt> はλファンクタを永続的に通常の関数オブジェクトに変換するのに対して、<tt>protected</tt> はこの操作を一回の評価だけに一時的に行う。
次に例を示す。
<pre class="programlisting">
int x = 1, y = 10;
(_1 + protect(_1 + 2))(x)(y);
</pre>
最初の呼出しでは、<tt>x</tt> を最左の <tt>_1</tt> に代入され、
その結果は別なλファンクタ <tt>x + (_1 + 2)</tt> となる。
そのλファンクタが <tt>y</tt> とともに呼出されると、
<tt>x + (y + 2)</tt> となり、最終的には 13 となる。
</p><p>
The <tt>protect</tt> function is related to unlambda. 

It is also used to prevent the argument substitution taking place, 
but whereas <tt>unlambda</tt> turns a lambda functor into 
an ordinary function object for good, <tt>protect</tt> does 
this temporarily, for just one evaluation round.

For example:

<pre class="programlisting">
int x = 1, y = 10;
(_1 + protect(_1 + 2))(x)(y);
</pre>
    
The first call substitutes <tt>x</tt> for the leftmost 
<tt>_1</tt>, and results in another lambda functor 
<tt>x + (_1 + 2)</tt>, which after the call with 
<tt>y</tt> becomes <tt>x + (y + 2)</tt>, 
and thus finally 13.
</p><p>
<tt>protected</tt> をライブラリに含めた主要な動機はネストした STL アルゴリズムの呼出しを可能にすることであった。
(<a href="ar01s05.html#sect:nested_stl_algorithms" title="5.11. Nesting STL algorithm invocations">Section 5.11</a>)
</p><p>
Primary motivation for including <tt>protect</tt> into the library, 
was to allow nested STL algorithm invocations 
(<a href="ar01s05.html#sect:nested_stl_algorithms" title="5.11. Nesting STL algorithm invocations">Section 5.11</a>).
</p>
</div>
</div>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="sect:rvalues_as_actual_arguments"></a>5.9.2. Rvalues as actual arguments to lambda functors</h4>
</div>
</div>
<p>
非 const な右辺値がλファンクタの実引数となることはできない。
これは意図して決定された設計のためである。
この制限がなければ、実引数に対する副作用を与えることができなくなる。
この制限を回避する方法がある。
サブセクション 
<a href="ar01s04.html#sect:actual_arguments_to_lambda_functors" title="4.3. About actual arguments to lambda functors">Section 4.3</a>
の例を再び使用して、いくつかの解決策を並べる。
<pre class="programlisting">
int i = 1; int j = 2; 
(_1 + _2)(i, j); // ok
(_1 + _2)(1, 2); // error (!)
</pre>
Actual arguments to the lambda functors cannot be non-const rvalues.
This is due to a deliberate design decision: either we have this restriction, 
or there can be no side-effects to the actual arguments.

There are ways around this limitation.

We repeat the example from section 
<a href="ar01s04.html#sect:actual_arguments_to_lambda_functors" title="4.3. About actual arguments to lambda functors">Section 4.3</a> and list the 
different solutions:

<pre class="programlisting">
int i = 1; int j = 2; 
(_1 + _2)(i, j); // ok
(_1 + _2)(1, 2); // error (!)
</pre>

<div class="orderedlist">
<ol type="1">
<li>
<p>
もし、右辺値がクラス型であれば、右辺値を作成する関数の返り値の型は const として定義されるべきである。
不幸にも言語仕様の制限により、この方法は組み込みの型に対してはうまくいかない。
組み込みの型の右辺値は、const 修飾することができないためである。
</p>
<p>
If the rvalue is of a class type, the return type of the function that 
creates the rvalue should be defined as const. 
Due to an unfortunate language restriction this does not work for 
built-in types, as built-in rvalues cannot be const qualified. 
</p>
</li>
<li>
<p>
λ関数の呼出しの部分を変更できるのであれば、
関数 <tt>make_const</tt> を利用して右辺値を <span class="emphasis"><i>const 修飾</i></span>することができる。
次に例を示す。
<pre class="programlisting">
(_1 + _2)(make_const(1), make_const(2)); // ok
</pre>
一般的にλ関数の呼出しは標準アルゴリズムのテンプレート関数の内部で行われるため、この解決策を仕様することは難しい。
</p>
<p>
If the lambda function call is accessible, the <tt>make_const</tt> 
function can be used to <span class="emphasis"><i>constify</i></span> the rvalue. E.g.:
<pre class="programlisting">
(_1 + _2)(make_const(1), make_const(2)); // ok
</pre>
Commonly the lambda function call site is inside a standard algorithm 
function template, preventing this solution to be used.
</p>
</li>
<li>
<p>
上記のいずれもが不可能であれば、λ式を 関数<tt>const_parameters</tt> で
ラップすることができる。
この関数は引数を const 参照としてとる別の型のλファンクタを生成する。
以下に例を示す。
<pre class="programlisting">
const_parameters(_1 + _2)(1, 2); // ok
</pre>
<tt>const_parameters</tt> は全ての引数を const な型にする。
そのため、引数に非 const な右辺値があったり、非 const 参照として渡したい引数があった場合にはこの方法は使用できない。
</p>
<p>
If neither of the above is possible, the lambda expression can be wrapped 
in a <tt>const_parameters</tt> function. 
It creates another type of lambda functor, which takes its arguments as 
const references. For example:

<pre class="programlisting">
const_parameters(_1 + _2)(1, 2); // ok
</pre>

Note that <tt>const_parameters</tt> makes all arguments const.
Hence, in the case were one of the arguments is a non-const rvalue, 
and another argument needs to be passed as a non-const reference, 
this approach cannot be used.
</p>
</li>
<li>
<p>
以上のいづれも不可能である場合にも、残念ながら <font color="red"> const 性</font>を破ることも可能となってしまうが、一つの解決策が存在する。
この解決法はさらに別なλファンクタのラッパを使用することである。
このラッパには <tt>break_const</tt> と名付けて、ユーザにこの関数の潜在的な危険に注意を促している。
関数 <tt>break_const</tt> は const として引数を受け取り、ラップされたλファンクタを呼出す前に const を捨て去るλファンクタを生成する。
次に例を示す。
For example:
<pre class="programlisting">
int i; 
...
(_1 += _2)(i, 2);                 // error, 2 is a non-const rvalue
const_parameters(_1 += _2)(i, 2); // error, i becomes const
break_const(_1 += _2)(i, 2);      // ok, but dangerous
</pre>
If none of the above is possible, there is still one solution, 
which unfortunately can break const correctness.

The solution is yet another lambda functor wrapper, which we have named 
<tt>break_const</tt> to alert the user of the potential dangers 
of this function. 

The <tt>break_const</tt> function creates a lambda functor that 
takes its arguments as const, and casts away constness prior to the call 
to the original wrapped lambda functor.

For example:
<pre class="programlisting">
int i; 
...
(_1 += _2)(i, 2);                 // error, 2 is a non-const rvalue
const_parameters(_1 += _2)(i, 2); // error, i becomes const
break_const(_1 += _2)(i, 2);      // ok, but dangerous
</pre>
<tt>break_const</tt> や <tt>const_parameters</tt> の結果はλファンクタではない。そのため、例えば次のように、λ式の部分式として使用することはできない。
<pre class="programlisting">
break_const(_1 + _2) + _3; // fails.
const_parameters(_1 + _2) + _3; // fails.
</pre>

Note, that the results of <tt> break_const</tt> or 
<tt>const_parameters</tt> are not lambda functors, 
so they cannot be used as subexpressions of lambda expressions. For instance:

<pre class="programlisting">
break_const(_1 + _2) + _3; // fails.
const_parameters(_1 + _2) + _3; // fails.
</pre>
しかし、部分的なλファンクタは BLL の内部で呼出され、非 const な右辺値の問題の影響を受けないため、この種のコードは決して必要とされない。
<br><br>
However, this kind of code should never be necessary, 
since calls to sub lambda functors are made inside the BLL, 
and are not affected by the non-const rvalue problem.
</p>
</li>
</ol>
</div>

</p>
</div>
</div>
<div class="section">
<div class="titlepage">
<div>
<h3 class="title"><a name="id2806049"></a>5.10. Casts, sizeof and typeid</h3>
</div>
</div>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="sect:cast_expressions"></a>5.10.1. 
Cast expressions
</h4>
</div>
</div>
<p>
BLL は <tt>static_cast</tt>、<tt>dynamic_casy</tt>、
<tt>const_cast</tt>、<tt>reinterpret_cast</tt> の
四つのキャストと同等なものを定義している。
BLL のキャストには、<tt>ll_</tt> という接頭辞が付いている。
キャスト先の型はテンプレート引数として明示的に指定し、
唯一の引数はキャストを行なう式である。
引数がλファンクタであれば、λファンクタがまず評価される。
例えば、以下のコードでは、<tt>ll_dynamic_cast</tt> を使用して、
コンテナ <tt>a</tt> 内の <tt>derived</tt> 型のインスタンスの数を数える。
<pre class="programlisting">
class base {};
class derived : public base {};

vector&lt;base*&gt; a;
...
int count = 0;
for_each(a.begin(), a.end(), 
         if_then(ll_dynamic_cast&lt;derived*&gt;(_1), ++var(count)));
</pre>
</p>
<p>
The BLL defines its counterparts for the four cast expressions 
<tt>static_cast</tt>, <tt>dynamic_cast</tt>, 
<tt>const_cast</tt> and <tt>reinterpret_cast</tt>.

The BLL versions of the cast expressions have the prefix 
<tt>ll_</tt>.

The type to cast to is given as an explicitly specified template argument, 
and the sole argument is the expression from which to perform the cast.

If the argument is a lambda functor, the lambda functor is evaluated first.

For example, the following code uses <tt>ll_dynamic_cast</tt> 
to count the number of <tt>derived</tt> instances in the container 
<tt>a</tt>:

<pre class="programlisting">
class base {};
class derived : public base {};

vector&lt;base*&gt; a;
...
int count = 0;
for_each(a.begin(), a.end(), 
         if_then(ll_dynamic_cast&lt;derived*&gt;(_1), ++var(count)));
</pre>
</p>
</div>
<div class="section">
<div class="titlepage">
<div>
<h4 class="title"><a name="id2806150"></a>5.10.2. Sizeof and typeid</h4>
</div>
</div>
<p>
BLL の sizeof と typeid と同等なものは、
<tt>ll_sizeof</tt> と <tt>ll_typeid</tt> と名付けらている。
双方とも一つの引数をとる。その引数はλ式でもよい。
これらにより作られたλファンクタは、<tt>sizeof</tt> や <tt>typeid</tt> 
の呼出しをラップする。そして、λファンクタが呼出されたときに、
ラップされた操作が実行される。
以下に例を示す。
<pre class="programlisting">
vector&lt;base*&gt; a; 
...
for_each(a.begin(), a.end(), 
         cout &lt;&lt; bind(&amp;type_info::name, ll_typeid(*_1)));
</pre>
<tt>ll_typeid</tt> は各要素に対して、<tt>typeid</tt> を呼出すλファンクタを生成する。
<tt>typeid</tt> の呼出しの結果は <tt>type_info</tt> 型のインスタンスであり、
bind 式はそのメンバ関数 <tt>name</tt> を呼ぶλファンクタを生成する。
</p>
<p>
The BLL counterparts for these expressions are named 
<tt>ll_sizeof</tt> and <tt>ll_typeid</tt>.

Both take one argument, which can be a lambda expression.
The lambda functor created wraps the <tt>sizeof</tt> or 
<tt>typeid</tt> call, and when the lambda functor is called 
the wrapped operation is performed.

For example:

<pre class="programlisting">
vector&lt;base*&gt; a; 
...
for_each(a.begin(), a.end(), 
         cout &lt;&lt; bind(&amp;type_info::name, ll_typeid(*_1)));
</pre>

Here <tt>ll_typeid</tt> creates a lambda functor for 
calling <tt>typeid</tt> for each element.

The result of a <tt>typeid</tt> call is an instance of 
the <tt>type_info</tt> class, and the bind expression creates 
a lambda functor for calling the <tt>name</tt> member 
function of that class.

</p>
</div>
</div>
<div class="section">
<div class="titlepage">
<div>
<h3 class="title"><a name="sect:nested_stl_algorithms"></a>5.11. Nesting STL algorithm invocations</h3>
</div>
</div>
<p>
BLL は共通の STL アルゴリズムを関数オブジェクトクラスとして定義しており、
そのインスタンスは bind 式の対象の関数として使用できる。
例えば、以下のコードでは、二次元配列の要素を反復して、その和を計算する。
<pre class="programlisting">
int a[100][200];
int sum = 0;

std::for_each(a, a + 100, 
	      bind(ll::for_each(), _1, _1 + 200, protect(sum += _1)));
</pre>
BLL の STL アルゴリズムはクラスである。
そのクラスでは、関数呼出し演算子(時にはオーバーロードして) を定義し、
<tt>std</tt> 名前空間の対応すう関数テンプレートを呼出すようにしている。
これらすべての構造体は部分名前空間 <tt>boost::lambda::ll</tt>
に存在する。
</p><p>
The BLL defines common STL algorithms as function object classes, 
instances of which can be used as target functions in bind expressions.
For example, the following code iterates over the elements of a 
two-dimensional array, and computes their sum.

<pre class="programlisting">
int a[100][200];
int sum = 0;

std::for_each(a, a + 100, 
	      bind(ll::for_each(), _1, _1 + 200, protect(sum += _1)));
</pre>

The BLL versions of the STL algorithms are classes, which define the function call operator (or several overloaded ones) to call the corresponding function templates in the <tt>std</tt> namespace.
All these structs are placed in the subnamespace <tt>boost::lambda:ll</tt>. 

</p><p>
λ式におけるオーバーロードされたメンバ関数の呼出しを表現する簡単な方法はない。
このことにより、ネストした STL アルゴリズムの有効性を制限されてしまう。
例えば、テンプレートコンテナにおいて、関数 <tt>begin</tt> は
オーバーロードされた定義が一つ以上ある。
一般的には、以下の擬似コードと類似したものを書くことはできない。
<pre class="programlisting">
std::for_each(a.begin(), a.end(), 
	      bind(ll::for_each(), _1.begin(), _1.end(), protect(sum += _1)));
</pre>

Note that there is no easy way to express an overloaded member function 
call in a lambda expression. 

This limits the usefulness of nested STL algorithms, as for instance 
the <tt>begin</tt> function has more than one overloaded 
definitions in container templates.

In general, something analogous to the pseudo-code below cannot be written:

<pre class="programlisting">
std::for_each(a.begin(), a.end(), 
	      bind(ll::for_each(), _1.begin(), _1.end(), protect(sum += _1)));
</pre>
しかし、共通の特殊な場合には対応策が提供されている。
BLL は <tt>call_begin</tt> と <tt>call_end</tt> という二つのヘルパ関数オブジェクトクラスを定義している。
それらのクラスはそれぞれコンテナの関数 <tt>begin</tt> と関数 <tt>end</tt>
の呼出しをラップし、コンテナの <tt>const_iterator</tt> 型を返す。
これらのヘルパテンプレートを用いると、上記のコードは次のようになる。
<pre class="programlisting">
std::for_each(a.begin(), a.end(), 
	      bind(ll::for_each(), 
                   bind(call_begin(), _1), bind(call_end(), _1),
                        protect(sum += _1)));
</pre>
Some aid for common special cases can be provided though.

The BLL defines two helper function object classes, 
<tt>call_begin</tt> and <tt>call_end</tt>, 
which wrap a call to the <tt>begin</tt> and, respectively, 
<tt>end</tt> functions of a container, and return the 
<tt>const_iterator</tt> type of the container.

With these helper templates, the above code becomes:
<pre class="programlisting">
std::for_each(a.begin(), a.end(), 
	      bind(ll::for_each(), 
                   bind(call_begin(), _1), bind(call_end(), _1),
                        protect(sum += _1)));
</pre>

</p>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s04.html">Prev</a></td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"><a accesskey="n" href="ar01s06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4. Using the library</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">6. Extending return type deduction system</td></tr></table></div></body></html>
