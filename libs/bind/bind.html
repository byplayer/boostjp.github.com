<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
	<head>
		<title>Boost: bind.hpp documentation</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	</head>
	<body bgcolor="white" style="MARGIN-LEFT: 5%; MARGIN-RIGHT: 5%">
		<p>
			原文：<a href="http://www.boost.org/libs/bind/bind.html">http://www.boost.org/libs/bind/bind.html</a>
		</p>
		<table border="0" width="100%">
			<tr>
				<td width="277">
					<img src="../../c++boost.gif" alt="c++boost.gif (8819 bytes)" width="277" height="86">
				</td>
				<td align="center">
					<h1>bind.hpp</h1>
				</td>
			</tr>
			<tr>
				<td colspan="2" height="64">&nbsp;</td>
			</tr>
		</table>
		<h2>Contents</h2>
		<h3 style="MARGIN-LEFT: 20pt"><a href="#Purpose">Purpose</a></h3>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#with_functions">Using bind with functions and 
				function pointers</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#with_function_objects">Using bind with function 
				objects</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#with_member_pointers">Using bind with pointers 
				to members</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#nested_binds">Using nested binds for function 
				composition</a></h4>
		<h3 style="MARGIN-LEFT: 20pt"><a href="#Examples">Examples</a></h3>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#with_algorithms">Using bind with standard 
				algorithms</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#with_boost_function">Using bind with 
				Boost.Function</a></h4>
		<h3 style="MARGIN-LEFT: 20pt"><a href="#Limitations">Limitations</a></h3>
		<h3 style="MARGIN-LEFT: 20pt"><a href="#FAQ">Frequently Asked Questions</a></h3>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Q_doesnt_compile">Why doesn't this compile?</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Q_does_compile">Why does this compile? It 
				should not.</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Q_forms">What is the difference between bind(f, 
				...) and bind&lt;R&gt;(f, ...)?</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Q_win32_api">Does <b>bind</b> work with Windows 
				API functions?</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Q_com">Does <b>bind</b> work with COM methods?</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Q_mac">Does <b>bind</b> work with Mac toolbox 
				functions?</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Q_extern_C">Does <b>bind</b> work with extern 
				"C" functions?</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Q_auto_stdcall">Why doesn't <b>bind</b> automatically 
				recognize nonstandard functions?</a></h4>
		<h3 style="MARGIN-LEFT: 20pt"><a href="#Troubleshooting">Troubleshooting</a></h3>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#err_num_args">Incorrect number of arguments</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#err_signature">The function object cannot be 
				called with the specified arguments</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#err_arg_access">Accessing an argument that does 
				not exist</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#err_short_form">Inappropriate use of bind(f, 
				...)</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#err_long_form">Inappropriate use of 
				bind&lt;R&gt;(f, ...)</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#err_nonstd">Binding a nonstandard function</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#err_const_arg"><b>const</b> in signatures</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#err_msvc_using">MSVC specific: using 
				boost::bind;</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#err_msvc_class_template">MSVC specific: class 
				templates shadow function templates</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#err_msvc_ellipsis">MSVC specific: ... in 
				signatures treated as type</a></h4>
		<h3 style="MARGIN-LEFT: 20pt"><a href="#Interface">Interface</a></h3>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Synopsis">Synopsis</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#CommonRequirements">Common requirements</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#CommonDefinitions">Common definitions</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#bind">bind</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#AdditionalOverloads">Additional overloads</a></h4>
		<h3 style="MARGIN-LEFT: 20pt"><a href="#Implementation">Implementation</a></h3>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Files">Files</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#Dependencies">Dependencies</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#NumberOfArguments">Number of Arguments</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#stdcall">"__stdcall", "__fastcall",&nbsp;and 
				"pascal" Support</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#BOOST_BIND">Using the BOOST_BIND macro</a></h4>
		<h4 style="MARGIN-LEFT: 40pt"><a href="#visit_each"><b>visit_each</b> support</a></h4>
		<h3 style="MARGIN-LEFT: 20pt"><a href="#Acknowledgements">Acknowledgements</a></h3>
		<h2><a name="Purpose">Purpose</a></h2>
		<p>
			<b>boost::bind</b> は標準ライブラリの関数 <b>std::bind1st</b> および <b>std::bind2nd</b> を汎用化したものである。
			関数オブジェクトだけでなく、関数や関数へのポインタ、メンバ関数へのポインタをサポートし、任意の引数を特定の値に束縛したり、入力引数を、もとの順番に関係なく自由な位置に移し替えることができる。
			<b>bind</b> が扱うことのできる関数オブジェクトには、特別な条件はない。
			特に、標準関数が要求する typedef <b>result_type</b> や <b>first_argument_type</b> および <b>second_argument_type</b> は必須ではない。
		</p>
		<!-- TRANSLATOR'S NOTE START -->
		<p>
			【訳注：このような関数を一般に「バインダ」または「束縛子」と呼ぶ。】
		</p>
		<p>
			【訳注：「入力引数」とは、<b>bind</b> によって生成された関数オブジェクトを呼び出す時に渡される引数。例えば、<tt>bind(f, _1, 5)(x)</tt> における <tt>x</tt> のこと。】
		</p>
		<!-- TRANSLATOR'S NOTE END -->
		<h3><a name="with_functions">Using bind with functions and function pointers</a></h3>
		<p>
			以下の関数が定義されているとき、
		</p>
		<pre>
int f(int a, int b)
{
    return a + b;
}

int g(int a, int b, int c)
{
    return a + b + c;
}
</pre>
		<p>
			<tt>bind(f, 1, 2)</tt> は "nullary" (無項)、つまり引数をとらない関数オブジェクトを生成する。これを評価すると <tt>f(1, 2)</tt> を返す。
			同様に、<tt>bind(g, 1, 2, 3)()</tt> は <tt>g(1, 2, 3)</tt> と等価である。
		</p>
		<!-- TRANSLATOR'S NOTE START -->
		<p>
			【訳注："nullary" は boost の造語のようで、「いくつかの邪悪な提案のうち、いちばんマシ」として選ばれたとの記述が <a href="../compose/index.htm">compose ライブラリのコメント</a> にある。】
		</p>
		<!-- TRANSLATOR'S NOTE END -->
		<p>
			引数のうちいくつかだけを、選択的に束縛することもできる。
			例えば、<tt>bind(f, _1, 5)(x)</tt> は <tt>f(x, 5)</tt> と等価である。
			ここで、<b>_1</b> は「最初の入力引数によって置き換えられる」ことを意味するプレースホルダである。
		</p>
		<!-- TRANSLATOR'S NOTE START -->
		<p>
			【訳注：残念ながら、<tt>bind(f, _1, 5)(10)</tt> のように、入力引数にリテラルを渡すことはできない。詳しくは、<a href="#Limitations">Limitations</a> を参照。】
		</p>
		<p>
			【訳注：ここに <b>lambda</b> の <tt>_1</tt> との関連を書く、かも。】
		</p>
		<!-- TRANSLATOR'S NOTE END -->
		<p>
			比較のため、同じ操作を標準ライブラリのプリミティブを使って書くとこうなる。
		</p>
		<pre>
std::bind2nd(std::ptr_fun(f), 5)(x);
</pre>
		<p>
			<b>bind</b> は <b>std::bind1st</b> の機能もカバーしている。
		</p>
		<pre>
std::bind1st(std::ptr_fun(f), 5)(x);   // f(5, x)
bind(f, 5, _1)(x);                     // f(5, x)
</pre>
		<p>
			<b>bind</b> は二つ以上の引数を持つ関数を扱うことができる。
			また、引数の置き換え機能はより一般化されている。
		</p>
		<pre>
bind(f, _2, _1)(x, y);                 // f(y, x)

bind(g, _1, 9, _1)(x);                 // g(x, 9, x)

bind(g, _3, _3, _3)(x, y, z);          // g(z, z, z)

bind(g, _1, _1, _1)(x, y, z);          // g(x, x, x)
</pre>
		<p>
			最後の例で、<tt>bind(g, _1, _1, _1)</tt> が生成する関数オブジェクトは入力引数を一つしか受け取らないにも関わらず、複数の引数を付けて呼び出せることに注意。
			このように、余分な引数は黙って無視され、エラーにはならない。
			同様に、三番目の例では最初の引数 <tt>x</tt> と二番目の引数 <tt>y</tt> は無視される。
		</p>
		<p>
			<b>bind</b> に渡される引数はコピーされ、生成された関数オブジェクトの内部に保持される。
			例えば、以下のコードでは、
		</p>
		<pre>
int i = 5;

bind(f, i, _1);
</pre>
		<p>
			<b>i</b> の値のコピーが関数オブジェクトに格納される。
			コピーではなく参照を関数オブジェクトに格納したい場合には、<a href="ref.html">boost::ref</a> および <a href="ref.html">boost::cref</a> を使う必要がある。
		</p>
		<pre>
int i = 5;

bind(f, ref(i), _1);
</pre>
		<!-- TRANSLATOR'S NOTE START -->
		<p>
			【訳注：詳しくは、<b>ref</b> の<a href="ref.html">ドキュメント</a>を参照。】
		</p>
		<!-- TRANSLATOR'S NOTE END -->
		<h3><a name="with_function_objects">Using bind with function objects</a></h3>
		<p>
			<b>bind</b> は通常の関数だけでなく、任意の関数オブジェクトを受け付ける。
			一般的には（標準 C++ には <b>typeof</b> 演算子がなく、戻り型を推論できないため）、生成される関数オブジェクトの <b>operator()</b> の戻り型を以下のように明示的に指定する必要がある。
		</p>
		<pre>
struct F
{
    int operator()(int a, int b) { return a - b; }
    bool operator()(long a, long b) { return a == b; }
};

F f;

int x = 104;

bind&lt;int&gt;(f, _1, _1)(x);		// f(x, x) つまり、ゼロ
</pre>
		<p>
			関数オブジェクトが <b>result_type</b> という名前の入れ子の型を開示している場合、戻り型を明示的に書く必要はない。
		</p>
		<pre>
int x = 8;

bind(std::less&lt;int&gt;(), _1, 9)(x);	// x &lt; 9
</pre>
		<p>
			【注意：戻り型を省略する機能は、コンパイラによっては利用できない場合がある。】
		</p>
		<h3><a name="with_member_pointers">Using bind with pointers to members</a></h3>
		<p>
			メンバ関数へのポインタやデータメンバへのポインタは <tt>operator()</tt> を持たないので、関数オブジェクトではない。
			しかし、それでは不便なので、<b>bind</b> は最初の引数としてメンバへのポインタも受け付ける。
			この場合、<a href="mem_fn.html">boost::mem_fn</a> によってメンバへのポインタが関数オブジェクトに変換されて渡されたかのように振る舞う。
			すなわち、式
		</p>
		<pre>
bind(&amp;X::f, <i>args</i>)
</pre>
		<p>
			は以下のものと等価である。
		</p>
		<pre>
bind&lt;R&gt;(<a href="mem_fn.html">mem_fn</a>(&amp;X::f), <i>args</i>)
</pre>
		<p>
			ここで、<b>R</b> は <b>X::f</b> の戻り型（メンバ関数の場合）、またはメンバの型への const な参照（データメンバの場合）である。
		</p>
		<p>
			【注意：<b>mem_fn</b> が生成する関数オブジェクトを呼び出す際には、最初の引数としてオブジェクトのポインタ、参照またはスマートポインタを渡す。
			詳しくは、<b>mem_fn</b> の<a href="mem_fn.html">ドキュメント</a>を参照。】
		</p>
		<p>
			例：
		</p>
		<pre>
struct X
{
    bool f(int a);
};

X x;

shared_ptr&lt;X&gt; p(new X);

int i = 5;

bind(&amp;X::f, ref(x), _1)(i);		// x.f(i)
bind(&amp;X::f, &amp;x, _1)(i);			//(&amp;x)-&gt;f(i)
bind(&amp;X::f, x, _1)(i);			// (<i>x の内部的なコピー</i>).f(i)
bind(&amp;X::f, p, _1)(i);			// (<i>p の内部的なコピー</i>)-&gt;f(i)
</pre>
		<p>
			最後の二つの例は「自己充足な」関数オブジェクトを生成する興味深い例である。
			<tt>bind(&amp;X::f, x, _1)</tt> は <b>x</b> のコピーを保持する。
			<tt>bind(&amp;X::f, p, _1)</tt> は <b>p</b> のコピーを保持し、<b>p</b> が <a href="../smart_ptr/shared_ptr.htm">boost::shared_ptr</a> であるため、関数オブジェクトは <b>X</b> のインスタンスへの参照を持ち、それは <b>p</b> のスコープを抜けたり <b>reset()</b> されたりしても有効である。
		</p>
		<!-- TRANSLATOR'S NOTE START -->
		<p>
			【訳注：つまり、<b>bind</b> の最初の引数がメンバ関数へのポインタである場合、次の引数はそのメンバ関数を持つクラスまたは派生クラスのオブジェクトまたはポインタ、ref()、スマートポインタでなければならない。】
		</p>
		<!-- TRANSLATOR'S NOTE END -->
		<h3><a name="nested_binds">Using nested binds for function composition</a></h3>
		<p>
			<b>bind</b> に渡される引数のうちいくつかは、それ自体が <b>bind</b> の入れ子になった式でもよい。
		</p>
		<pre>
bind(f, bind(g, _1))(x);               // f(g(x))
</pre>
		<p>
			<STRONG>bind</STRONG> によって生成された関数オブジェクトを呼び出す時には、外側の <STRONG>bind</STRONG> 式が呼ばれる前に内側の <STRONG>bind</STRONG> 式が、複数ある場合は順不同で評価される。
			次に、その結果は外側の <STRONG>bind</STRONG> が評価される際の引数として渡される。
			上の例で、関数オブジェクトが引数リスト <tt>(x)</tt> とともに呼び出される場合、<tt>bind(g, _1)(x)</tt> がまず評価されて <tt>g(x)</tt> となり、次に <tt>bind(f, g(x))(x)</tt> が評価され、最終的な結果は <tt>f(g(x))</tt> となる。
		</p>
		<P>
			<b>bind</b> のこの機能は、関数を合成するために使用することができる。
			詳しくは、<a href="bind_as_compose.cpp">bind_as_compose.cpp</a> に <b>bind</b> を使って <a href="../compose/index.htm">Boost.Compose</a> と同様の効果を得るサンプルがあるので、それを参照のこと。
		</P>
		<p>
			ただし、（<b>bind</b> 関数の）最初の引数、つまり束縛される関数オブジェクトは、評価されないので注意すること。
			特に、関数オブジェクトが <STRONG>bind</STRONG> で生成されたものや、プレースホルダ引数の場合でも評価されないので、次の例は期待通りには動かない。
		</p>
		<pre>
typedef void (*pf)(int);

std::vector&lt;pf&gt; v;

std::for_each(v.begin(), v.end(), bind(_1, 5));
</pre>
		<!-- TRANSLATOR'S NOTE START -->
		<p>
			【訳注：動かないというか、コンパイルできない。】
		</p>
		<!-- TRANSLATOR'S NOTE END -->
		<p>
			期待通りの結果を得るには、ヘルパ関数オブジェクト <STRONG>apply</STRONG> を使用する必要がある。
			<STRONG>apply</STRONG> はその最初の引数である関数オブジェクトを、残りの引数リストに対して適用する。
			<STRONG>apply</STRONG> 関数は <STRONG>boost/bind/apply.hpp</STRONG> ヘッダファイルに定義されている。
			上の例は、この <STRONG>apply</STRONG> を使って次のように書き直せばよい。
		</p>
		<pre>
typedef void (*pf)(int);

std::vector&lt;pf&gt; v;

std::for_each(v.begin(), v.end(), bind(apply&lt;void&gt;(), _1, 5));
</pre>
		<P>
			時には、最初の引数だけでなく、入れ子になった <STRONG>bind</STRONG> 部分式であるような他の引数を評価したく<STRONG>ない</STRONG>場合もある。
			この場合は、別のヘルパ関数 <STRONG>protect</STRONG> を使用するとよい。
			これにより、引数の型がマスクされ、<STRONG>bind</STRONG> が認識されず、評価されない。
			呼び出し時には、<STRONG>protect</STRONG> は単純に引数リストを他の関数オブジェクトのそのまま渡す。
		</P>
		<P>
			<STRONG>protect</STRONG> 関数は <STRONG>boost/bind/protect.hpp</STRONG> ヘッダに含まれている。
			<STRONG>bind</STRONG> 関数オブジェクトを評価されないように保護するには、<tt>protect(bind(f, ...))</tt> と書けばよい。
		</P>
		<!-- TRANSLATOR'S NOTE START -->
		<p>
			【訳注：ここにも簡単な例が欲しい。】
		</p>
		<!-- TRANSLATOR'S NOTE END -->
		<h2><a name="Examples">Examples</a></h2>
		<h3><a name="with_algorithms">Using bind with standard algorithms</a></h3>
		<pre>
class image;

class animation
{
public:

    void advance(int ms);
    bool inactive() const;
    void render(image &amp; target) const;
};

std::vector&lt;animation&gt; anims;

template&lt;class C, class P&gt; void erase_if(C &amp; c, P pred)
{
    c.erase(std::remove_if(c.begin(), c.end(), pred), c.end());
}

void update(int ms)
{
    std::for_each(anims.begin(), anims.end(), boost::bind(&amp;animation::advance, _1, ms));
    erase_if(anims, boost::mem_fn(&amp;animation::inactive));
}

void render(image &amp; target)
{
    std::for_each(anims.begin(), anims.end(), boost::bind(&amp;animation::render, _1, boost::ref(target)));
}
</pre>
		<h3><a name="with_boost_function">Using bind with Boost.Function</a></h3>
		<pre>
class button
{
public:

    <a href="../function/index.html">boost::function</a>&lt;void&gt; onClick;
};

class player
{
public:

    void play();
    void stop();
};

button playButton, stopButton;
player thePlayer;

void connect()
{
    playButton.onClick = boost::bind(&amp;player::play, &amp;thePlayer);
    stopButton.onClick = boost::bind(&amp;player::stop, &amp;thePlayer);
}
</pre>
		<h3><a name="Limitations">Limitations</a></h3>
		<p>
			<b>bind</b> が生成する関数オブジェクトは、引数を参照渡しで受け取る。このため、const でない一時オブジェクトやリテラル定数を受け取ることはできない。
			これは、C++ 言語自体の制約であり、「転送する関数の問題<font color="green">（？）</font>」として知られている。
		</p>
		<p>
			任意の型の引数を受け取り、それらをそのまま渡すために、<b>bind</b> ライブラリでは、
		</p>
		<pre>
template&lt;class T&gt; void f(T &amp; t);
</pre>
		<p>
			という形式のシグネチャを（訳注：仮引数に）使っている。
			上記のように、この方法は const でない右辺値には使えない。
		</p>
		<p>
			この問題に対して、次のようにオーバーロードを追加する「解決策」がよく提案される。
		</p>
		<pre>
template&lt;class T&gt; void f(T &amp; t);
template&lt;class T&gt; void f(T const &amp; t);
</pre>
		<p>
			残念ながら、この方法は (a) 引数が 9 つある場合、512 ものオーバーロードを提供する必要があり、(b) 引数が const である場合、シグネチャが全く同じであるために半順序<font color="green">（？）</font>を定義できず、左辺値にも右辺値にもうまく働かない。
		</p>
		<p>
			【注意：これは C++ 言語の暗い隅<font color="green">（？）</font>であり、<a href="http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/cwg_active.html#214">該当する問題</a>はまだ解決されていない。】
		</p>
		<h2><a name="FAQ">Frequently Asked Questions</a></h2>
		<h3><a name="Q_doesnt_compile">Why doesn't this compile?<br>(どうしてコンパイルできない？)</a></h3>
		<p>
			<a href="#Troubleshooting">Troubleshooting の項</a>を参照。
		</p>
		<h3><a name="Q_does_compile">Why does this compile? It should not.<br>(どうしてコンパイルできちゃう？ エラーになる筈なのに。)</a></h3>
		<p>
			おそらく、bind&lt;R&gt;(f, ...) という汎用の構文を使っているためであろう。この書き方は、<b>bind</b> に対して <b>f</b> の引数の数や戻り型に関するエラーチェックをしないように指示するものである。
		</p>
		<h3><a name="Q_forms">What is the difference between bind(f, ...) and bind&lt;R&gt;(f, ...)?<br>(bind(f, ...) と bind&lt;R&gt;(f, ...) はどう違う？)</a></h3>
		<p>
			最初の形式は <b>bind</b> に <b>f</b> の型を調べて、引数の数や戻り型を解決するように指示する。
			引数の数の間違いは「バインド時」に検出される。
			この構文はもちろん、<b>f</b> に対していくつかのことを要求する。
			つまり、<b>f</b> は関数、関数ポインタ、メンバ関数へのポインタのいずれかであるか、関数オブジェクトの場合には <b>result_type</b> という入れ子の型を定義する必要がある。簡単に言えば、<b>bind</b> が認識できるものでなければならない。
		</p>
		<p>
			二番目の形式は <b>bind</b> に <b>f</b> の型を識別<b>しない</b>ように指示する。
			これは一般的には、<b>result_type</b> を開示しない、あるいはできない関数オブジェクトとともに用いられるが、その他に非標準の関数に対しても用いることができる。
			たとえば、現在の実装は <b>printf</b> のような可変引数の関数を自動的に認識しないため、<tt>bind&lt;int&gt;(printf, ...)</tt> と書く必要がある。
		</p>
		<!-- TRANSLATOR'S NOTE START -->
		<p>
			【訳注：「非標準」は原文では nonstandard だが、<b>printf</b> が「非標準」というのは変だなぁ。】
		</p>
		<!-- TRANSLATOR'S NOTE END -->
		<p>
			他に考慮すべき重要な点として、コンパイラがテンプレートの部分特殊化版や関数テンプレートの半順序<font color="green">（？）</font>に対応していない場合、<b>f</b> が関数オブジェクトであれば最初の形式は扱えず、また、<b>f</b> が関数（ポインタ）やメンバ関数へのポインタであれば二番目の形式は扱えないことが多い。
		</p>
		<h3><a name="Q_win32_api">Does <b>bind</b> work with Windows API functions?<br>(<b>bind</b> は Windows の API 関数に対して使える？)</a></h3>
		<p>
			はい、<a href="#stdcall">#define BOOST_BIND_ENABLE_STDCALL</a> すれば。
			または、目的の関数を <a href="#with_function_objects">generic function object</a> として扱って、bind&lt;R&gt;(f, ...) の構文を使っても良い。
		</p>
		<h3><a name="Q_com">Does <b>bind</b> work with COM methods?<br>(<b>bind</b> は COM のメソッドに使える？)</a></h3>
		<p>
			はい、<a href="#stdcall">#define BOOST_MEM_FN_ENABLE_STDCALL</a> すれば。
		</p>
		<h3><a name="Q_mac">Does <b>bind</b> work with Mac toolbox functions?<br>(<b>bind</b> は Mac の Toolbox 関数に使える？)</a></h3>
		<p>
			はい、<a href="#stdcall">#define BOOST_BIND_ENABLE_PASCAL</a> すれば。
			または、目的の関数を <a href="#with_function_objects">generic function object</a> として扱って、bind&lt;R&gt;(f, ...) の構文を使っても良い。
		</p>
		<h3><a name="Q_extern_C">Does <b>bind</b> work with extern "C" functions?<br>(<b>bind</b> は extern "C" な関数に使える？)</a></h3>
		<p>
			場合による。
			いくつかのプラットフォームでは、extern "C" な関数へのポインタは「通常の」関数ポインタと等価であり、問題なく動く。
			他のプラットフォームでは、それらは別物として扱われる。
			プラットフォーム固有の <b>bind</b> の実装があれば、問題を透過的に解決できることが期待されるが、この実装はそうなっていない。
			いつものように、回避策は目的の関数を <a href="#with_function_objects">generic function object</a> として扱って、bind&lt;R&gt;(f, ...) の構文を使うことである。
		</p>
		<!-- TRANSLATOR'S NOTE START -->
		<p>
			【訳注：「この実装」とあるが、このドキュメントは bind の仕様を定義するもので、附属の実装は「サンプル実装」という位置付けで書かれているものと思われる。<font color="green">（？）</font>】
		</p>
		<!-- TRANSLATOR'S NOTE END -->
		<h3><a name="Q_auto_stdcall">Why doesn't <b>bind</b> automatically recognize nonstandard functions?<br>(どうして <b>bind</b> は非標準の関数を自動的に認識しない？)</a></h3>
		<p>
			特定のベンダに縛られることを防ぐために、非標準の拡張は一般的にデフォルトで off にすべきである。
			もしも<a href="#stdcall">固有のマクロ</a>が自動的に定義されたら、そのつもりがないのにそれらの機能を使ってしまい、知らない間に互換性を損なってしまう危険性がある。
			また、いくつかのコンパイラは <b>__stdcall</b> (<STRONG>__fastcall</STRONG>) をデフォルトの呼び出し規約とするオプションを用意しており、特別なサポートは必要ない。
		</p>
		<h2><a name="Troubleshooting">Troubleshooting</a></h2>
		<h3><a name="err_num_args">Incorrect number of arguments<br>(引数の数が不正)</a></h3>
		<p>
			式 bind(f, a1, a2, ..., aN) において、関数オブジェクト <b>f</b> はちょうど <b>N</b> 個の引数を取らなければならない。
			このエラーは、通常「バインド時」に検出される。すなわち、bind() を呼び出している行に対してコンパイルエラーが報告される。
		</p>
		<pre>
int f(int, int);

int main()
{
    boost::bind(f, 1);    // エラー、f は二つの引数を取る
    boost::bind(f, 1, 2); // OK
}
</pre>
		<p>
			このエラーの変種として、メンバ関数に対する暗黙の「this」引数を忘れることも多い。
		</p>
		<pre>
struct X
{
    int f(int);
}

int main()
{
    boost::bind(&amp;X::f, 1);     // エラー、X::f は二つの引数を取る
    boost::bind(&amp;X::f, <b>_1</b>, 1); // OK
}
</pre>
		<!-- TRANSLATOR'S NOTE START -->
		<p>
			【訳注：bind では、メンバ関数へのポインタは、通常の引数の前に暗黙の「this」引数をとるものとみなす。】
		</p>
		<!-- TRANSLATOR'S NOTE END -->
		<h3><a name="err_signature">The function object cannot be called with the specified arguments<br>(関数オブジェクトは指定された引数とともに呼び出すことはできない)</a></h3>
		<p>
			通常の関数呼び出しと同様、束縛される関数オブジェクトは引数リストと互換性を持つ必要がある。
			非互換性は、通常コンパイラによって「呼び出し時」に検出され、<b>bind.hpp</b> の次のような行に対するエラーとなる。
		</p>
		<pre>
    return f(a[a1_], a[a2_]);
</pre>
		<p>
			An example of this kind of error:
		</p>
		<pre>
int f(int);

int main()
{
    boost::bind(f, "incompatible");      // OK、呼び出さないので
    boost::bind(f, "incompatible")();    // エラー、"incompatible" は int ではない
    boost::bind(f, _1);                  // OK
    boost::bind(f, _1)("incompatible");  // エラー、"incompatible" は int ではない
}
</pre>
		<h3><a name="err_arg_access">Accessing an argument that does not exist<br>(存在しない引数へのアクセス)</a></h3>
		<p>
			プレースホルダ <b>_N</b> は引数リストの <b>N</b> 番目の引数を、「呼び出し時」に選択する。
			当然、引数リストの範囲外のものにアクセスしようとすればエラーになる。
		</p>
		<pre>
int f(int);

int main()
{
    boost::bind(f, _1);                  // OK
    boost::bind(f, _1)();                // エラー、一番目の引数は存在しない
}
</pre>
		<p>
			このエラーは、通常 <b>bind.hpp</b> の次のような行に対して報告される。
		</p>
		<pre>
    return f(a[a1_]);
</pre>
		<p>
			<b>std::bind1st(f, a)</b> の代わりに使う場合、<b>bind(f, a, _1)</b> ではなく間違って <b>bind(f, a, _2)</b> としてしまうことも多い。
		</p>
		<h3><a name="err_short_form">Inappropriate use of bind(f, ...)<br>(bind(f, ...) の不適切な使用)</a></h3>
		<p>
			bind(f, a1, a2, ..., aN) の<a href="#Q_forms">形式</a>は <b>f</b> を自動的に認識させる。
			これは、任意の関数オブジェクトに対して働くわけではない。<b>f</b> は関数またはメンバ関数へのポインタでなければならない。
		</p>
		<p>
			この形式を <b>result_type</b> を定義する関数オブジェクトに使えるのは、部分特殊化版や半順序<font color="green">（？）</font>を<b>サポートしているコンパイラ</b>に限られる。
			特に、MSVC のバージョン 7.0 までは、関数オブジェクトに対するこの構文はサポートしない。
		</p>
		<!-- TRANSLATOR'S NOTE START -->
		<p>
			【訳注：原文では MSVC up to version 7.0 となっているが、これは 7.0 を含むのだろうか？】
		</p>
		<!-- TRANSLATOR'S NOTE END -->
		<h3><a name="err_long_form">Inappropriate use of bind&lt;R&gt;(f, ...)<br>(bind&lt;R&gt;(f, ...) の不適切な使用)</a></h3>
		<p>
			The bind&lt;R&gt;(f, a1, a2, ..., aN) <a href="#Q_forms">form</a> supports 
			arbitrary function objects.
		</p>
		<p>
			It is possible (but not recommended) to use this form with functions or member 
			function pointers, but <b>only on compilers</b> that support partial ordering. 
			In particular, MSVC up to version 7.0 does not fully support this syntax for 
			functions and member function pointers.
		</p>
		<h3><a name="err_nonstd">Binding a nonstandard function<br>(非標準の関数の束縛)</a></h3>
		<p>
			By default, the bind(f, a1, a2, ..., aN) <A href="#Q_forms">form</A> recognizes 
			"ordinary" C++ functions and function pointers. <A href="#stdcall">Functions that 
				use a different calling convention</A>, or variable-argument functions such 
			as <STRONG>std::printf</STRONG>, do not work. The general bind&lt;R&gt;(f, a1, 
			a2, ..., aN) <A href="#Q_forms">form</A> works with nonstandard functions.
		</p>
		<p>
			On some platforms, extern "C" functions, like <b>std::strcmp</b>, are not 
			recognized by the short form of bind.
		</p>
		<P>
			See also <A href="#stdcall" name="stdcall">"__stdcall" and "pascal" Support</A>.</P>
		<h3><a name="err_const_arg"><b>const</b> in signatures<br>(シグネチャが <b>const</b> を含む)</a></h3>
		<p>
			Some compilers, including MSVC 6.0 and Borland C++ 5.5.1, have problems with 
			the top-level <b>const</b> in function signatures:
		</p>
		<pre>
int f(int const);

int main()
{
    boost::bind(f, 1);     // error
}
</pre>
		<p>
			Workaround: remove the <b>const</b> qualifier from the argument.
		</p>
		<h3><a name="err_msvc_using">MSVC specific: using boost::bind;</a></h3>
		<p>
			On MSVC (up to version 7.0), when <b>boost::bind</b> is brought into scope with 
			an using declaration:
		</p>
		<pre>
using boost::bind;
</pre>
		<p>
			the syntax <b>bind&lt;R&gt;(...)</b> does not work. Workaround: either use the 
			qualified name, <b>boost::bind</b>, or use an using directive instead:
		</p>
		<pre>
using namespace boost;
</pre>
		<h3><a name="err_msvc_class_template">MSVC specific: class templates shadow function 
				templates</a></h3>
		<p>
			On MSVC (up to version 7.0), a nested class template named <b>bind</b> will 
			shadow the function template <b>boost::bind</b>, breaking the <b>bind&lt;R&gt;(...)</b>
			syntax. Unfortunately, some libraries contain nested class templates named <b>bind</b>
			(ironically, such code is often an MSVC specific workaround.) You may try to 
			patch the library in question or contact its author/maintainer. The other 
			option is use the <a href="#BOOST_BIND">BOOST_BIND</a> macro to rename <b>bind</b>.
		</p>
		<h3><a name="err_msvc_ellipsis">MSVC specific: ... in signatures treated as type</a></h3>
		<p>
			MSVC (up to version 7.0) treats the ellipsis in a variable argument function 
			(such as <b>std::printf</b>) as a type. Therefore, it will accept the 
			(incorrect in the current implementation) form:
		</p>
		<pre>
    bind(printf, "%s\n", _1);
</pre>
		<p>
			and will reject the correct version:
		</p>
		<pre>
    bind&lt;int&gt;(printf, "%s\n", _1);
</pre>
		<h2><a name="Interface">Interface</a></h2>
		<h3><a name="Synopsis">Synopsis</a></h3>
		<pre>
namespace boost
{

// no arguments

template&lt;class R, class F&gt; <i>unspecified-1</i> <a href="#bind_1">bind</a>(F f);

template&lt;class F&gt; <i>unspecified-1-1</i> <a href="#bind_1_1">bind</a>(F f);

template&lt;class R&gt; <i>unspecified-2</i> <a href="#bind_2">bind</a>(R (*f) ());

// one argument

template&lt;class R, class F, class A1&gt; <i>unspecified-3</i> <a href="#bind_3">bind</a>(F f, A1 a1);

template&lt;class F, class A1&gt; <i>unspecified-3-1</i> <a href="#bind_3_1">bind</a>(F f, A1 a1);

template&lt;class R, class B1, class A1&gt; <i>unspecified-4</i> <a href="#bind_4">bind</a>(R (*f) (B1), A1 a1);

template&lt;class R, class T, class A1&gt; <i>unspecified-5</i> <a href="#bind_5">bind</a>(R (T::*f) (), A1 a1);

template&lt;class R, class T, class A1&gt; <i>unspecified-6</i> <a href="#bind_6">bind</a>(R (T::*f) () const, A1 a1);

template&lt;class R, class T, class A1&gt; <i>unspecified-6-1</i> <a href="#bind_6_1">bind</a>(R T::*f, A1 a1);

// two arguments

template&lt;class R, class F, class A1, class A2&gt; <i>unspecified-7</i> <a href="#bind_7">bind</a>(F f, A1 a1, A2 a2);

template&lt;class F, class A1, class A2&gt; <i>unspecified-7-1</i> <a href="#bind_7_1">bind</a>(F f, A1 a1, A2 a2);

template&lt;class R, class B1, class B2, class A1, class A2&gt; <i>unspecified-8</i> <a href="#bind_8">bind</a>(R (*f) (B1, B2), A1 a1, A2 a2);

template&lt;class R, class T, class B1, class A1, class A2&gt; <i>unspecified-9</i> <a href="#bind_9">bind</a>(R (T::*f) (B1), A1 a1, A2 a2);

template&lt;class R, class T, class B1, class A1, class A2&gt; <i>unspecified-10</i> <a href="#bind_10">bind</a>(R (T::*f) (B1) const, A1 a1, A2 a2);

// implementation defined number of additional overloads for more arguments

}

namespace
{

<i>unspecified-placeholder-type-1</i> _1;

<i>unspecified-placeholder-type-2</i> _2;

<i>unspecified-placeholder-type-3</i> _3;

// implementation defined number of additional placeholder definitions

}
</pre>
		<h3><a name="CommonRequirements">Common requirements</a></h3>
		<p>
			All <tt><i>unspecified-N</i></tt> types returned by <b>bind</b> are <b>CopyConstructible</b>.
			<tt><i>unspecified-N</i>::result_type</tt> is defined as the return type of <tt><i>unspecified-N</i>::operator()</tt>.
		</p>
		<p>
			All <tt><i>unspecified-placeholder-N</i></tt> types are <b>CopyConstructible</b>. 
			Their copy constructors do not throw exceptions.
		</p>
		<h3><a name="CommonDefinitions">Common definitions</a></h3>
		<p>
			The function &micro;(x, v<sub>1</sub>, v<sub>2</sub>, ..., v<sub>m</sub>), where m is 
			a nonnegative integer, is defined as:
		</p>
		<ul>
			<li>
				<tt>x.get()</tt>, when <tt>x</tt> is of type <tt><a href="ref.html">boost::reference_wrapper</a>&lt;T&gt;</tt>
				for some type <tt>T</tt>;
			<li>
				v<sub>k</sub>, when <tt>x</tt>
			is (a copy of) the placeholder _k for some positive integer k;
			<li>
				<tt>x(v<sub>1</sub>, v<sub>2</sub>, ..., v<sub>m</sub>)</tt> when <tt>x</tt> is 
				(a copy of) a function object returned by <b>bind</b>;
			<li>
				<tt>x</tt> otherwise.</li>
		</ul>
		<h3><a name="bind">bind</a></h3>
		<h4><a name="bind_1">template&lt;class R, class F&gt; <i>unspecified-1</i> bind(F f)</a></h4>
		<blockquote>
			<p>
				<b>Returns:</b> A function object <i>&#955;</i> such that the expression <tt>&#955;(v<sub>1</sub>, 
					v<sub>2</sub>, ..., v<sub>m</sub>)</tt> is equivalent to <tt><b>f</b>()</tt>, 
				implicitly converted to <b>R</b>.
			</p>
			<p>
				<b>Throws:</b> Nothing unless the copy constructor of <b>F</b> throws an 
				exception.
			</p>
		</blockquote>
		<h4><a name="bind_1_1">template&lt;class F&gt; <i>unspecified-1-1</i> bind(F f)</a></h4>
		<blockquote>
			<p>
				<b>Effects:</b> Equivalent to <tt>bind&lt;typename F::result_type, F&gt;(f);</tt>
			</p>
			<p>
				<b>Notes:</b> Implementations are allowed to infer the return type of <b>f</b> via 
				other means as an extension, without relying on the <tt>result_type</tt> member.
			</p>
		</blockquote>
		<h4><a name="bind_2">template&lt;class R&gt; <i>unspecified-2</i> bind(R (*f) ())</a></h4>
		<blockquote>
			<p>
				<b>Returns:</b> A function object <i>&#955;</i> such that the expression <tt>&#955;(v<sub>1</sub>, 
					v<sub>2</sub>, ..., v<sub>m</sub>)</tt> is equivalent to <tt><b>f</b>()</tt>.
			</p>
			<p>
				<b>Throws:</b> Nothing.
			</p>
		</blockquote>
		<h4><a name="bind_3">template&lt;class R, class F, class A1&gt; <i>unspecified-3</i> bind(F 
				f, A1 a1)</a></h4>
		<blockquote>
			<p>
				<b>Returns:</b> A function object <i>&#955;</i> such that the expression <tt>&#955;(v<sub>1</sub>, 
					v<sub>2</sub>, ..., v<sub>m</sub>)</tt> is equivalent to <tt><b>f</b>(&micro;(<b>a1</b>, 
					v<sub>1</sub>, v<sub>2</sub>, ..., v<sub>m</sub>))</tt>, implicitly 
				converted to <b>R</b>.
			</p>
			<p>
				<b>Throws:</b> Nothing unless the copy constructors of <b>F</b> or <b>A1</b> throw 
				an exception.
			</p>
		</blockquote>
		<h4><a name="bind_3_1">template&lt;class F, class A1&gt; <i>unspecified-3-1</i> bind(F 
				f, A1 a1)</a></h4>
		<blockquote>
			<p>
				<b>Effects:</b> Equivalent to <tt>bind&lt;typename F::result_type, F, A1&gt;(f, 
					a1);</tt>
			</p>
			<p>
				<b>Notes:</b> Implementations are allowed to infer the return type of <b>f</b> via 
				other means as an extension, without relying on the <tt>result_type</tt> member.
			</p>
		</blockquote>
		<h4><a name="bind_4">template&lt;class R, class B1, class A1&gt; <i>unspecified-4</i> bind(R 
				(*f) (B1), A1 a1)</a></h4>
		<blockquote>
			<p>
				<b>Returns:</b> A function object <i>&#955;</i> such that the expression <tt>&#955;(v<sub>1</sub>, 
					v<sub>2</sub>, ..., v<sub>m</sub>)</tt> is equivalent to <tt><b>f</b>(&micro;(<b>a1</b>, 
					v<sub>1</sub>, v<sub>2</sub>, ..., v<sub>m</sub>))</tt>.
			</p>
			<p>
				<b>Throws:</b> Nothing unless the copy constructor of <b>A1</b> throws an 
				exception.
			</p>
		</blockquote>
		<h4><a name="bind_5">template&lt;class R, class T, class A1&gt; <i>unspecified-5</i> bind(R 
				(T::*f) (), A1 a1)</a></h4>
		<blockquote>
			<p>
				<b>Effects:</b> Equivalent to <tt>bind&lt;R&gt;(<a href="mem_fn.html">boost::mem_fn</a>(f), 
					a1);</tt>
			</p>
		</blockquote>
		<h4><a name="bind_6">template&lt;class R, class T, class A1&gt; <i>unspecified-6</i> bind(R 
				(T::*f) () const, A1 a1)</a></h4>
		<blockquote>
			<p>
				<b>Effects:</b> Equivalent to <tt>bind&lt;R&gt;(<a href="mem_fn.html">boost::mem_fn</a>(f), 
					a1);</tt>
			</p>
		</blockquote>
		<h4><a name="bind_6_1">template&lt;class R, class T, class A1&gt; <i>unspecified-6-1</i>
				bind(R T::*f, A1 a1)</a></h4>
		<blockquote>
			<p>
				<b>Effects:</b> Equivalent to <tt>bind&lt;R const &amp;&gt;(<a href="mem_fn.html">boost::mem_fn</a>(f), 
					a1);</tt>
			</p>
		</blockquote>
		<h4><a name="bind_7">template&lt;class R, class F, class A1, class A2&gt; <i>unspecified-7</i>
				bind(F f, A1 a1, A2 a2)</a></h4>
		<blockquote>
			<p>
				<b>Returns:</b> A function object <i>&#955;</i> such that the expression <tt>&#955;(v<sub>1</sub>, 
					v<sub>2</sub>, ..., v<sub>m</sub>)</tt> is equivalent to <tt><b>f</b>(&micro;(<b>a1</b>, 
					v<sub>1</sub>, v<sub>2</sub>, ..., v<sub>m</sub>), &micro;(<b>a2</b>, v<sub>1</sub>, 
					v<sub>2</sub>, ..., v<sub>m</sub>))</tt>, implicitly converted to <b>R</b>.
			</p>
			<p>
				<b>Throws:</b> Nothing unless the copy constructors of <b>F</b>, <b>A1</b> or <b>A2</b>
				throw an exception.
			</p>
		</blockquote>
		<h4><a name="bind_7_1">template&lt;class F, class A1, class A2&gt; <i>unspecified-7-1</i>
				bind(F f, A1 a1, A2 a2)</a></h4>
		<blockquote>
			<p>
				<b>Effects:</b> Equivalent to <tt>bind&lt;typename F::result_type, F, A1, A2&gt;(f, 
					a1, a2);</tt>
			</p>
			<p>
				<b>Notes:</b> Implementations are allowed to infer the return type of <b>f</b> via 
				other means as an extension, without relying on the <tt>result_type</tt> member.
			</p>
		</blockquote>
		<h4><a name="bind_8">template&lt;class R, class B1, class B2, class A1, class A2&gt; <i>unspecified-8</i>
				bind(R (*f) (B1, B2), A1 a1, A2 a2)</a></h4>
		<blockquote>
			<p>
				<b>Returns:</b> A function object <i>&#955;</i> such that the expression <tt>&#955;(v<sub>1</sub>, 
					v<sub>2</sub>, ..., v<sub>m</sub>)</tt> is equivalent to <tt><b>f</b>(&micro;(<b>a1</b>, 
					v<sub>1</sub>, v<sub>2</sub>, ..., v<sub>m</sub>), &micro;(<b>a2</b>, v<sub>1</sub>, 
					v<sub>2</sub>, ..., v<sub>m</sub>))</tt>.
			</p>
			<p>
				<b>Throws:</b> Nothing unless the copy constructors of <b>A1</b> or <b>A2</b> throw 
				an exception.
			</p>
		</blockquote>
		<h4><a name="bind_9">template&lt;class R, class T, class B1, class A1, class A2&gt; <i>unspecified-9</i>
				bind(R (T::*f) (B1), A1 a1, A2 a2)</a></h4>
		<blockquote>
			<p>
				<b>Effects:</b> Equivalent to <tt>bind&lt;R&gt;(<a href="mem_fn.html">boost::mem_fn</a>(f), 
					a1, a2);</tt>
			</p>
		</blockquote>
		<h4><a name="bind_10">template&lt;class R, class T, class B1, class A1, class A2&gt; <i>unspecified-10</i>
				bind(R (T::*f) (B1) const, A1 a1, A2 a2)</a></h4>
		<blockquote>
			<p>
				<b>Effects:</b> Equivalent to <tt>bind&lt;R&gt;(<a href="mem_fn.html">boost::mem_fn</a>(f), 
					a1, a2);</tt>
			</p>
		</blockquote>
		<h3><a name="AdditionalOverloads">Additional overloads</a></h3>
		<p>
			Implementations are allowed to provide additional <b>bind</b> overloads in 
			order to support more arguments or different function pointer variations.
		</p>
		<h2><a name="Implementation">Implementation</a></h2>
		<h3><a name="Files">Files</a></h3>
		<ul>
			<li>
				<a href="../../boost/bind.hpp">boost/bind.hpp</a>
			(main header)
			<li>
				<a href="../../boost/bind/bind_cc.hpp">boost/bind/bind_cc.hpp</a>
			(used by bind.hpp, do not include directly)
			<li>
				<a href="../../boost/bind/bind_mf_cc.hpp">boost/bind/bind_mf_cc.hpp</a>
			(used by bind.hpp, do not include directly)
			<li>
				<a href="../../boost/bind/bind_template.hpp">boost/bind/bind_template.hpp</a>
			(used by bind.hpp, do not include directly)
			<LI>
				<A href="../../boost/bind/arg.hpp">boost/bind/arg.hpp</A>
			(defines the type of the placeholder arguments)
			<LI>
				<A href="../../boost/bind/placeholders.hpp">boost/bind/placeholders.hpp</A>
			(defines the _1, _2, ... _9 placeholders)
			<LI>
				<A href="../../boost/bind/apply.hpp">boost/bind/apply.hpp</A> (<STRONG>apply</STRONG>
			helper function object)
			<LI>
				<A href="../../boost/bind/protect.hpp">boost/bind/protect.hpp</A> (<STRONG>protect</STRONG>
			helper function)
			<LI>
				<A href="../../boost/bind/make_adaptable.hpp">boost/bind/make_adaptable.hpp</A> 
				(<STRONG>make_adaptable</STRONG>
			helper function)
			<li>
				<a href="bind_test.cpp">libs/bind/bind_test.cpp</a>
			(test)
			<li>
				<a href="bind_as_compose.cpp">libs/bind/bind_as_compose.cpp</a>
			(function composition example)
			<li>
				<a href="bind_visitor.cpp">libs/bind/bind_visitor.cpp</a>
			(visitor example)
			<li>
				<a href="bind_stdcall_test.cpp">libs/bind/bind_stdcall_test.cpp</a>
			(test with __stdcall functions)
			<li>
				<a href="bind_stdcall_mf_test.cpp">libs/bind/bind_stdcall_mf_test.cpp</a> (test 
				with __stdcall member functions)</li>
			<li>
				<a href="bind_fastcall_test.cpp">libs/bind/bind_fastcall_test.cpp</a>
			(test with __fastcall functions)
			<li>
				<a href="bind_fastcall_mf_test.cpp">libs/bind/bind_fastcall_mf_test.cpp</a> (test 
				with __fastcall member functions)</li>
		</ul>
		<h3><a name="Dependencies">Dependencies</a></h3>
		<ul>
			<li>
				<a href="../config/config.htm">Boost.Config</a>
			<li>
				<a href="ref.html">boost/ref.hpp</a>
			<li>
				<a href="mem_fn.html">boost/mem_fn.hpp</a></li>
		</ul>
		<h3><a name="NumberOfArguments">Number of Arguments</a></h3>
		<p>
			This implementation supports function objects with up to nine arguments. This 
			is an implementation detail, not an inherent limitation of the design.
		</p>
		<h3><a name="stdcall">"__stdcall", "__fastcall", and "pascal" Support</a></h3>
		<p>
			Some platforms allow several types of (member) functions that differ by their <b>calling 
				convention</b> (the rules by which the function is invoked: how are 
			arguments passed, how is the return value handled, and who cleans up the stack 
			- if any.)
		</p>
		<p>
			For example, Windows API functions and COM interface member functions use a 
			calling convention known as <b>__stdcall</b>.Borland VCL components use <STRONG>__fastcall</STRONG>. 
			Mac toolbox functions use a <b>pascal</b> calling convention.
		</p>
		<p>
			To use <b>bind</b> with <b>__stdcall</b> functions, <b>#define</b> the macro <b>BOOST_BIND_ENABLE_STDCALL</b>
			before including <b>&lt;boost/bind.hpp&gt;</b>.
		</p>
		<p>
			To use <b>bind</b> with <b>__stdcall</b> <b>member</b> functions, <b>#define</b>
			the macro <b>BOOST_MEM_FN_ENABLE_STDCALL</b> before including <b>&lt;boost/bind.hpp&gt;</b>.
		</p>
		<P>To use <B>bind</B> with <B>__fastcall</B> functions, <B>#define</B> the macro <B>BOOST_BIND_ENABLE_FASTCALL</B>
			before including <B>&lt;boost/bind.hpp&gt;</B>.
		</P>
		<P>To use <B>bind</B> with <B>__fastcall</B> <B>member</B> functions, <B>#define</B>
			the macro <B>BOOST_MEM_FN_ENABLE_FASTCALL</B> before including <B>&lt;boost/bind.hpp&gt;</B>.
		</P>
		<P>
			To use <b>bind</b> with <b>pascal</b> functions, <b>#define</b> the macro <b>BOOST_BIND_ENABLE_PASCAL</b>
			before including <b>&lt;boost/bind.hpp&gt;</b>.
		</P>
		<p>
			[Note: this is a non-portable extension. It is not part of the interface.]
		</p>
		<p>
			[Note: Some compilers provide only minimal support for the <b>__stdcall</b> keyword.]
		</p>
		<h3><a name="BOOST_BIND">Using the BOOST_BIND macro</a></h3>
		<p>
			A <a href="#err_msvc_class_template">bug in MSVC (up to version 7.0)</a> causes <b>boost::bind</b>
			to be incompatible with libraries that contain nested class templates named <b>bind</b>. 
			To work around this problem, <b>#define</b> the macro <b>BOOST_BIND</b> to 
			something other than <b>bind</b> (before the inclusion of <b>&lt;boost/bind.hpp&gt;</b>) 
			and use this identifier throughout your code wherever you'd normally use <b>bind</b>.
		</p>
		<p style="COLOR: red">
			[Note: BOOST_BIND is not a general renaming mechanism. It is not part of the 
			interface, and is not guaranteed to work on other compilers, or persist between 
			library versions. In short, don't use it unless you absolutely have to.]
		</p>
		<h3><a name="visit_each"><b>visit_each</b> support</a></h3>
		<p>
			Function objects returned by <b>bind</b> support the experimental and 
			undocumented, as of yet, <b>visit_each</b> enumeration interface.
		</p>
		<p>
			See <a href="bind_visitor.cpp">bind_visitor.cpp</a> for an example.
		</p>
		<h2><a name="Acknowledgements">Acknowledgements</a></h2>
		<p>
			Earlier efforts that have influenced the library design:
		</p>
		<ul>
			<li>
				The <a href="http://staff.cs.utu.fi/BL/">Binder Library</a>
			by Jaakko J&auml;rvi;
			<li>
				The <a href="http://lambda.cs.utu.fi/">Lambda Library</a>
			by Jaakko J&auml;rvi and Gary Powell (the successor to the Binder Library);
			<li>
				<a href="http://matfys.lth.se/~petter/src/more/stlext/index.html">Extensions to the 
					STL</a> by Petter Urkedal.</li>
		</ul>
		<p>
			Doug Gregor suggested that a visitor mechanism would allow <b>bind</b> to 
			interoperate with a signal/slot library.
		</p>
		<p>
			John Maddock fixed a MSVC-specific conflict between <b>bind</b> and the <a href="../type_traits/index.htm">
				type traits library</a>.
		</p>
		<p>
			Numerous improvements were suggested during the formal review period by Ross 
			Smith, Richard Crossley, Jens Maurer, Ed Brey, and others. Review manager was 
			Darin Adler.
		</p>
		<p>
			The precise semantics of <b>bind</b> were refined in discussions with Jaakko 
			J&auml;rvi.
		</p>
		<p>
			Dave Abrahams fixed a MSVC-specific conflict between <b>bind</b> and the <a href="../utility/iterator_adaptors.htm">
				iterator adaptors library</a>.
		</p>
		<p>
			Dave Abrahams modified <b>bind</b> and <b>mem_fn</b> to support void returns on 
			deficient compilers.
		</p>
		<p>
			Mac Murrett contributed the "pascal" support enabled by 
			BOOST_BIND_ENABLE_PASCAL.
		</p>
		<p><br>
			<br>
			<br>
			<small>Copyright &copy; 2001, 2002 by Peter Dimov and Multi Media Ltd. Permission to 
				copy, use, modify, sell and distribute this document is granted provided this 
				copyright notice appears in all copies. This document is provided "as is" 
				without express or implied warranty, and with no claim as to its suitability 
				for any purpose.</small></p>
	</body>
</html>
