<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML><HEAD><TITLE>The Boost Format library</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
</HEAD>
<BODY bgColor=#ffffff text=#000000>

<H1><IMG align=center alt="c++boost.gif (8819 bytes)" height=86 
src="../../../c++boost.gif" width=277>The Boost Format library</H1>
<!--
<P>The <CODE>
<A href="../../../boost/format.hpp">&lt;boost/format.hpp&gt;</A></CODE> 
format class provides printf-like formatting, in a type-safe manner which allows output of 
user-defined types. 
<br>
(It does not depend on other boost libraries)
</P>
-->
<P><CODE>
<A href="../../../boost/format.hpp">&lt;boost/format.hpp&gt;</A></CODE> 
format クラスは printf に似た、ユーザ定義型も扱える型安全な書式化処理を提供する。
<br>
(このライブラリは他の boost ライブラリに依存しない)
</P>
<ul>
<li><a href="#synopsis">Synopsis</a> </li>
<li><a href="#how_it_works">How it works</a> </li>
<li><a href="#examples">Examples</a> </li>
<li><a href="#syntax">Syntax</a> 
        <ul>
          <li><a href="#printf_directives">printf format-specification syntax</a> </li>
          <li><a href="#printf_differences"">Incompatibilities with printf</a> </li>
        </ul>
</li>
<li><a href="#manipulators">Manipulators and the internal stream state</a> </li>
<li><a href="#user-defined">User-defined types</a> </li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#alternatives">Alternatives</a> </li>
</ul>
<hr>
<H2>Synopsis</H2>
<a name="synopsis">
<!--
<P>
A format object is constructed from a format-string, and is then given arguments through 
repeated calls to <i>operator%</i>.
<br>
Each of those arguments are then converted to strings, who are in turn  combined into one string,
 according to the format-string.
</P>
-->
<P>
format オブジェクトは書式文字列から構築され、その後 <i>operator%</i> を繰り返し呼び出されることで引数を与えられる。
<br>
それぞれの引数は文字列に変換され、書式文字列に従って順に一つの文字列へと結合される。
</P>
<!--
<BLOCKQUOTE><PRE>
cout << boost::format("writing %1%,  x=%2% : %3%-th try") % "toto" % 40.23 % 50; 
     // prints "writing toto,  x=40.230 : 50-th try"
</PRE></BLOCKQUOTE>
-->
<BLOCKQUOTE><PRE>
cout << boost::format("writing %1%,  x=%2% : %3%-th try") % "toto" % 40.23 % 50; 
     // "writing toto,  x=40.230 : 50-th try"と表示
</PRE></BLOCKQUOTE>

<hr>
<H2>How it works</H2>
<a name="how_it_works">
<!--
<p>
<ol>
<li>When you call <i>format(s)</i>, where s is the format-string, it constructs an object,
which parses the format string and look for all directives in it and prepares internal structures
for the next step.</li>
<li>
Then, either immediately,
as in <BLOCKQUOTE><PRE>cout << format("%2% %1%") % 36 % 77 )</PRE></BLOCKQUOTE>
or later on, as in 
<BLOCKQUOTE><PRE>format fmter("%2% %1%");
fmter % 36; fmter % 77;</PRE></BLOCKQUOTE> 
you <i>feed</i> variables into the formatter. 
<br>those variables are dumped into an internal stream, 
which state is set according to the given formatting options in the format-string 
-if there are any-, 
and the format object stores the string results for the last step.
</li>
<li>Once all arguments have been fed  you can dump the format object to a stream, 
or get its string value by using the 
<i>str()</i> member function, or the free function <i>str(const format& )</i> in namespace <i>boost::io</i>. The result string stays accessible in the format object until another argument is passed,
at which time it is reinitialised.
</P>
-->
<p>
<ol>
<li>書式文字列 s を伴って <i>format(s)</i> を呼び出すと、あるオブジェクトが構築される。このオブジェクトは、書式文字列を構文解析してすべての命令を探し、次のステップのために内部構造を準備する。</li>
<li>
そして、すぐに
<BLOCKQUOTE><PRE>cout << format("%2% %1%") % 36 % 77 )</PRE></BLOCKQUOTE>
のようにするか、あるいは後で、
<BLOCKQUOTE><PRE>format fmter("%2% %1%");
fmter % 36; fmter % 77;</PRE></BLOCKQUOTE> 
とすることで、フォーマッタに変数を<i>食わせる</i>ことができる。
<br>変数は内部のストリームにダンプされる。ストリームの状態は、与えられた書式文字列の書式化オプション(あれば)によってセットされる。
format オブジェクトは最後のステップのための結果文字列を保持する。
</li>
<li>すべての引数を与えてしまえば、その format オブジェクトをストリームにダンプしたり、メンバ関数 <i>str()</i> か名前空間 <i>boost::io</i> にある <i>str(const format&)</i> 関数で文字列を取り出すことができる。結果の文字列は、別の引数が与えられて再初期化されるまで、 format オブジェクトの中にアクセス可能な状態で残る。
</P>

<!--
<BLOCKQUOTE><PRE>

// fmter was previously created and fed arguments, it can print the result :
cout << fmter ;  

// You can take the string result :
string s  = fmter.str();

// possibly several times :
s = fmter.str( );

// You can also do all steps at once :
cout << boost::format("%2% %1%") % 36 % 77; 
string s2 = boost::io::str( format("%2% %1%") % 36 % 77 );

</PRE></BLOCKQUOTE>
-->
<BLOCKQUOTE><PRE>

// 先ほど作って引数を与えた fmter の結果を表示:
cout << fmter ;  

// 結果の文字列を取り出せる:
string s  = fmter.str();

// 何度でも:
s = fmter.str( );

// すべてのステップを一度に行うこともできる:
cout << boost::format("%2% %1%") % 36 % 77; 
string s2 = boost::io::str( format("%2% %1%") % 36 % 77 );

</PRE></BLOCKQUOTE>
</li>
<!--
<li>
Optionnally, after step 3, you can re-use a format object and restart at step2 :
<i>fmter % 18 % 39; </i>
<br> to format new variables with  the same format-string, saving the expensive processing
involved at step 1.
</li>
-->
<li>
ステップ３の後で format オブジェクトを再利用し、ステップ２からやり直すこともできる:
<i>fmter % 18 % 39; </i>
<br>新しい変数を同じ書式文字列で書式化する際は、こうすることでステップ１で生じる高価な処理を節約できる。
</li>
</ol>
<!--
All in all, the format class translates a format-string  (with eventually printf-like directives)
into operations on an internal stream, and finally returns the result of the formatting,
as a string, or directly into an output stream.
-->
結局のところ、 format クラスは、書式文字列(printf に似た命令を用いる)を内部のストリームへの操作に翻訳する。そして最終的に、その書式化の結果を文字列として、あるいは直接に出力ストリームへと返す。

<hr>
<H2>Examples</H2>
<a name="examples">
<p>

<BLOCKQUOTE><PRE>
using namespace std;
using boost::format;
using boost::io::group;
using boost::io::str;
</PRE></BLOCKQUOTE>

<ul>
<!--
<li> Simple output, with reordering :
<BLOCKQUOTE><PRE>

cout << format("%1% %2% %3% %2% %1% \n") % "11" % "22" % "333"; // 'simple' style.

</PRE></BLOCKQUOTE>
        It   prints : "11 22 333 22 11 \n"
</li>
-->
<li>並べ替えありの単純な出力:
<BLOCKQUOTE><PRE>

cout << format("%1% %2% %3% %2% %1% \n") % "11" % "22" % "333"; // '単純な'形式。

</PRE></BLOCKQUOTE>
        表示はこうなる : "11 22 333 22 11 \n"
</li>

<!--
<li> More precise formatting, with Posix-printf positional directives :
<BLOCKQUOTE><PRE>

cout << format("(x,y) = (%1$+5d,%2$+5d) \n") % -23 % 35;     // Posix-Printf style

</PRE></BLOCKQUOTE>
        It prints : "(x,y) = (  -23,  +35) \n"
</li>
-->
<li> POSIX 版 printf の位置指定命令を用いた、より精細な書式化:
<BLOCKQUOTE><PRE>

cout << format("(x,y) = (%1$+5d,%2$+5d) \n") % -23 % 35;     // POSIX版Printf形式

</PRE></BLOCKQUOTE>
        表示はこうなる : "(x,y) = (  -23,  +35) \n"
</li>

<!--
<li> classical printf directive, no reordering :
<BLOCKQUOTE><PRE>

cout << format("writing %s,  x=%s : %d-th step \n") % "toto" % 40.23 % 50; 

</PRE></BLOCKQUOTE>
        It prints : "writing toto,  x=40.23 : 50-th step \n"
</li>
-->
<li>並べ替えのない、古典的な printf の命令:
<BLOCKQUOTE><PRE>

cout << format("writing %s,  x=%s : %d-th step \n") % "toto" % 40.23 % 50; 

</PRE></BLOCKQUOTE>
        表示はこうなる : "writing toto,  x=40.23 : 50-th step \n"
</li>

<!--
<li> Several ways to express the same thing :
<BLOCKQUOTE><PRE>

cout << format("(x,y) = (%+5d,%+5d) \n") % -23 % 35;
cout << format("(x,y) = (%|+5|,%|+5|) \n") % -23 % 35;

cout << format("(x,y) = (%1$+5d,%2$+5d) \n") % -23 % 35;
cout << format("(x,y) = (%|1$+5|,%|2$+5|) \n") % -23 % 35;

</PRE></BLOCKQUOTE>
        all those print :  "(x,y) = (  -23,  +35) \n"

</li>
-->
<li>同じことを表現するにもいろいろな方法がある:
<BLOCKQUOTE><PRE>

cout << format("(x,y) = (%+5d,%+5d) \n") % -23 % 35;
cout << format("(x,y) = (%|+5|,%|+5|) \n") % -23 % 35;

cout << format("(x,y) = (%1$+5d,%2$+5d) \n") % -23 % 35;
cout << format("(x,y) = (%|1$+5|,%|2$+5|) \n") % -23 % 35;

</PRE></BLOCKQUOTE>
        表示はどれも :  "(x,y) = (  -23,  +35) \n"

</li>

<!--
<li> Using manipulators to modify the format-string :
<BLOCKQUOTE><PRE>

format fmter("_%1$+5d_ %1$d \n");

format fmter2("_%1%_ %1% \n");
fmter2.modify_item(1, group(showpos, setw(5)) ); 

cout << fmter % 101 ;
cout << fmter2 % 101 ;

</PRE></BLOCKQUOTE>
        Both print the same : "_ +101_ 101 \n"
</li>
-->
<li>マニピュレータによる書式文字列の修飾:
<BLOCKQUOTE><PRE>

format fmter("_%1$+5d_ %1$d \n");

format fmter2("_%1%_ %1% \n");
fmter2.modify_item(1, group(showpos, setw(5)) ); 

cout << fmter % 101 ;
cout << fmter2 % 101 ;

</PRE></BLOCKQUOTE>
        どちらも同じように表示する : "_ +101_ 101 \n"
</li>

<!--
<li> Using manipulators with arguments :
<BLOCKQUOTE><PRE>

cout << format("_%1%_ %1% \n") % group(showpos, setw(5), 101);

</PRE></BLOCKQUOTE>
        The manipulators are applied at each occurence of %1%, and thus it prints : "_ +101_  +101 \n"
</li>
-->
<li>引数を伴うマニピュレータ:
<BLOCKQUOTE><PRE>

cout << format("_%1%_ %1% \n") % group(showpos, setw(5), 101);

</PRE></BLOCKQUOTE>
        マニピュレータは、 %1% が現れるたびに適用されるので、出力はこうなる : "_ +101_  +101 \n"
</li>

<!--
<li> New formatting feature : 'absolute tabulations', useful in loops, 
to insure a field is printed at the same position from one line to the next, 
even if the widthes of the previous arguments can vary a lot.

<BLOCKQUOTE><PRE>

for(unsigned int i=0; i < names.size(); ++i)
    cout << format("%1%, %2%, %|40t|%3%\n") % names[i] % surname[i] % tel[i];

</PRE></BLOCKQUOTE>

For some vector names, surnames, and tel (see sample_new_features.cpp) it prints :
<BLOCKQUOTE><PRE>
Marc-Fran苡is Michel, Durand,           +33 (0) 123 456 789
Jean, de Lattre de Tassigny,            +33 (0) 987 654 321
</PRE></BLOCKQUOTE>


</li>
-->
<li>新しいフォーマット機能「絶対桁送り(absolute tabulations)」はループの中で使うと便利である。これはあるフィールドを各行の同じ位置に出力する機能で、たとえ直前の引数の幅が大きく変化したとしても、同じ位置に出力することを保証してくれる。

<BLOCKQUOTE><PRE>

for(unsigned int i=0; i < names.size(); ++i)
    cout << format("%1%, %2%, %|40t|%3%\n") % names[i] % surname[i] % tel[i];

</PRE></BLOCKQUOTE>

names 、 surnames 、そして tel などのベクタ(sample_new_features.cpp を参照)は次のように表示される :
<BLOCKQUOTE><PRE>
Marc-Fran&ccedil;is Michel, Durand,           +33 (0) 123 456 789
Jean, de Lattre de Tassigny,           +33 (0) 987 654 321
</PRE></BLOCKQUOTE>


</li>

</ul>

</p>
<hr>
<H2>Sample Files</H2>
<!--
<P>The program <A href="../example/sample_formats.cpp">sample_formats.cpp</A> 
 demonstrates simple uses of <B>format</B>.
<br>
<P><A href="../example/sample_new_features.cpp">sample_new_features.cpp</A> 
 illustrates the few formatting features that were added to printf's syntax such as
 simple positional directives, centered alignment, and 'tabulations'.
<br>
<P><A href="../example/sample_advanced.cpp">sample_advanced.cpp</A> 
 demonstrates uses of advanced features, like reusing, and modifying, format objects, etc.. 
<br>
<P>And <A href="../example/sample_userType.cpp">sample_userType.cpp</A> 
shows the behaviour of the <b>format</b> library on user-defined types.
</P>
-->
<P><A href="../example/sample_formats.cpp">sample_formats.cpp</A> は<B> format</B> の簡単な使い方をデモする。
<br>
<P><A href="../example/sample_new_features.cpp">sample_new_features.cpp</A> は、単純な位置指定命令、中寄せ、そして「桁送り」など、 printf の構文に追加された書式化機能のいくつかを説明する。
<br>
<P><A href="../example/sample_advanced.cpp">sample_advanced.cpp</A> は、 format オブジェクトの
再利用や修飾といった、さらに進んだ機能の使い方をデモする。
<br>
<P>そして <A href="../example/sample_userType.cpp">sample_userType.cpp</A> はユーザ定義型に対する <b>format</b> の振る舞いを示す。
</P>

<hr>
<H2>Syntax</H2>
<a name="syntax">
<P>
<b>boost::format( </b> format-string <b> ) %</b> arg1 <b>%</b> arg2 <b>%</b> ... <b>%</b> argN

</P>

<!--
<P>
The <i>format-string</i> contains text in which special directives will be replaced by 
strings resulting from the formatting of the given arguments.
<br>The legacy syntax in the C and C++ worlds is the one used by printf, and thus format can use 
directly printf format-strings, and produce the same result (in almost all cases. see 
<a href="#printf_differences"">Incompatibilities with printf</a> for details)
<br>
This core syntax was extended, to allow new features, but also to adapt to the C++ streams context.
Thus, format accepts several forms of directives in format-strings :
<UL>
<li> Legacy printf format strings : <B>%</B><i>spec</i><b></b> where <i>spec</i> is a 
	<a href="#printf_directives">printf format specification</a>
	<br><i>spec</i> passes formatting options, like width, alignment, numerical base used for
        formatting numbers,
	as well as other specific flags.
	But the classical <i>type-specification</i> flag of printf has a weaker meaning
	in format. It merely sets the appropriate flags on the internal stream,
	and/or formatting parameters, 
	but does not require the corresponding argument to be of a specific type.
	<br>
	e.g. : the specification <i>2$x</i>, 
	meaning "print argument number 2, which  is an integral number, in hexa" 	for printf,
	merely means "print argument 2 with stream basefield flags set to <i>hex</i>" for format.
</li>        
<li><B>%|</B><i>spec</i><b>|</b> where <i>spec</i> is a printf format specification.
        <br>
        The brackets are introduced, to improve the readability of the format-string,
        but primarily, to make the <i>type-conversion character</i> optional
        in <i>spec</i>. This information is not necessary with C++ variables,
        but with direct printf syntax, it is necessary to always give a type-conversion character,
        merely because this character is crucial to determine the end of a format-specification.
        <br>
        e.g. : "%|-5|" will format the next variable with width set to 5, and left-alignment
        just like the following printf directives : "%-5g", "%-5f", "%-5s" ..
</li>	
<li> <b>%</b><i>N</i><b>%</b>  <br>This simple positional notation
        requests the formatting of the <i>N</i>-th argument - wihout any formatting option.
        <br>
        (It's merely a shortcut to Printf's positional directives (like "%<i>N</i>$s"),
        but a major benefit is that it's much more readable, and 
        does not use a "type-conversion" character)
</li>
</UL>
    On top of the standard printf format specifications, new features were implemented, like centered alignment. See <a href="#new_directives">new format specification</a> for details.
</P>
-->
<P>
<i>format-string</i> は特殊な命令を含むテキストである。これらの命令は、与えられた引数の書式化結果の文字列によって置換される。
<br>C/C++ の世界におけるレガシーな構文は printf で使われているものである。そのため format は printf の書式文字列をそのまま利用でき、同じ結果を生成する。(ほとんどの場合において。詳細は <a href="#printf_differences"">Incompatibilities with printf</a> を見よ)
<br>
この中核となる構文は、新機能を許すだけでなく、 C++ のストリームの文脈に適合するために拡張された。そのため、 format は書式文字列のさまざまな形式の命令を受け付ける :
<UL>
<li>レガシーな printf の書式文字列 : <B>%</B><i>spec</i><b></b>　ここで <i>spec</i> は
	<a href="#printf_directives">printf の書式指定子</a>である
	<br><i>spec</i> は幅、アライメント、数値を書式化する際の基数、その他の特殊なフラグなどの書式化オプションを渡す。
	しかし printf の古典的な<i>型指定</i>フラグは format ではより弱い意味しか持たない。 format は内部ストリームと書式化パラメータのどちらかまたは両方に適当なフラグをセットするだけで、対応する引数が指定した型であるかどうかは問わない。
	<br>
    例 : <i>2$x</i> という指定子は、 printf にとっては「整数である二つ目の引数を１６進数で出力する」という意味であるが、 format においては「二つ目の引数を、ストリームの basefield フラグを <i>hex</i> にセットして出力する」という意味でしかない。
</li>        
<li><B>%|</B><i>spec</i><b>|</b> ここで <i>spec</i> は printf の書式指定子である。
        <br>
        括弧[訳注：米英語では、二つの記号の組み合わせで何かを囲むものはすべてbracket(括弧)と呼び、ここでは縦棒 '|' 二つを括弧と呼んでいる]は書式文字列の可読性を改善するが、本来は <i>spec</i> の<i>型変換文字</i>を省略可能にするために導入された。この情報は C++ の変数には不要だが、 printf の構文をそのまま用いる場合には、書式指定子の終端を決定するために必要だというだけの理由で、常に型変換文字を与える必要がある。
        <br>
        例 : "%|-5|" は 次の変数を幅を 5 、左寄せにフォーマットする。これは printf の以下の命令と同じものである : "%-5g", "%-5f", "%-5s" ..
</li>	
<li> <b>%</b><i>N</i><b>%</b>  <br>この単純な位置指定の表記は、 <i>N</i> 番目の引数を書式化オプションなしでフォーマットするよう要求するものである。
        <br>
        (これは printf の位置指定命令("%<i>N</i>$s" のような)の短縮形に過ぎないが、ずっと読みやすく、また「型変換指定」文字を用いないですむというご利益がある)
</li>
</UL>
    
    printf の標準の書式指定子に加えて、中寄せのような新しい機能が実装されている。詳細は <a href="#new_directives">new format specification</a> を参照。
</P>

<h3>printf format specifications</h3>
<a name="printf_directives">
<!--
<p> 
The printf format specifications supported by Boost.format follows the Unix98
<a href="http://www.opengroup.org/onlinepubs/7908799/xsh/fprintf.html">Open-group printf</a>
precise syntax, rather than the standard C printf, which does not support positional arguments.
(Common flags have the same meaning in both, so it should not be a headache for anybody)
<br>
<i> Note that it is an error to use positional format specifications</i>
(e.g. <i>%3$+d</i>) 
<i> mixed with non-positional ones</i> (e.g. <i>%+d</i>) <i>in the same format string.</i>
<br>
In the Open-group specification, referring to the same argument several times (e.g. <i>"%1$d %1$d"</i>) has undefined behaviour.  Boost.format's behaviour in such cases is to allow each argument to be reffered to any number of times. The only constraint is
that it expects exactly <i>P</i> arguments, <i>P</i> being the maximum argument number used in the
 format string. (e.g., for "%1$d %10$d", <i>P</i> == 10 ).
<br>Supplying more, or less, than <i>P</i> arguments raises an exception. 
(unless it was set otherwise, see <a href="#exceptions">exceptions</a>)
</p>
-->
<p> 
Boost.format でサポートされる printf の書式指定子は、引数の位置指定をサポートしない標準 C の printf よりも、むしろ Unix98<a href="http://www.opengroup.org/onlinepubs/7908799/xsh/fprintf.html">Open-group printf</a> の構文に従っている。
(両者の間では共通のフラグは同じ意味を持つので、誰も頭痛に悩まされることはない)
<br>
なお、<i>一つの書式文字列に位置指定付きの書式指定子</i>(例． <i>%3$+d</i>)<i>と位置指定なしのもの</i>(例． <i>%+d</i>)<i>を混ぜて使用するのはエラーである。</i>
<br>
Open-group の仕様では同じ引数を複数回参照すること(例． <i>"%1$d %1$d"</i>)は未定義動作であるが、 Boost.format では各引数を何度でも参照できる。ただ一つの制約は、書式文字列に現れる最大の引数の数が <i>P</i> であるとき、必ず <i>P</i> 個の引数を期待することである。(例． "%1$d %10$d" ならば <i>P</i> == 10)
<br>引数の数が多すぎても少なすぎても例外が起こる。
(そうでないようにセットされていなければ。 <a href="#exceptions">exceptions</a> を参照)
</p>
<!--
<p>
<br>
<br>
A  specification <i>spec</i> has the form :
[ <i>N</i><b>$</b> ] [ <i>flags</i> ] [ <i>width</i> ] 
[ <b>.</b> <i>precision</i> ] <i>type-char</i>
<br>
<br>
Fields insided square brackets are optional.
Each of those fields are explained one by one in the following list :
</p>
-->
<p>
<br>
<br>
書式指定子 <i>spec</i> は次の形式を持つ :
[ <i>N</i><b>$</b> ] [ <i>flags</i> ] [ <i>width</i> ] 
[ <b>.</b> <i>precision</i> ] <i>type-char</i>
<br>
<br>
大括弧で囲われたフィールドは省略可能である。
各フィールドは以下のリストのように説明される :
</p>

<!--
<ul>
<li>
<i>N</i> <b>$</b> (optional field)  specifies that the format specification applies to the <i>N</i>-th argument. (it is called a <i>positional format specification</i>)
<br>If this is not present, arguments are taken one by one. (and it is then an error to later supply an argument number)
<li>
<i>flags</i> is a sequences of any of those :
-->
<ul>
<li>
<i>N</i> <b>$</b> (省略可能なフィールド)は、その書式指定子が <i>N</i> 番目の引数に適用されると指定する。(これは<i>位置指定書式指定子</i>と呼ばれる)
<br>これが与えられない場合、引数は前から順番に解釈される。(ただし、その後に引数番号付きの書式指定子を与えるのはエラーである)
<li>
<i>flags</i> は以下の任意のシーケンスである :
<blockquote>
<table border="1" cellpadding="5">
<!--
<tr> <td><b>Flag</b></td> <td><b>Meaning</b></td> <td><b>effect on internal stream</b></td> 
</tr>
-->
<tr> <td><b>フラグ</b></td> <td><b>意味</b></td> <td><b>内部ストリームへの作用</b></td> 
</tr>

<!--
<tr> <td><b>'-'</b></td> <td>left alignment</td> 
		<td>N/A (applied later on the string)</td> 
</tr>
<tr> 
	    <td><b>'='</b></td> <td>centered alignment</td> 
	    <td>N/A (applied later on the string)<br>
	      Inexistent in printf <i>(added feature)</i></td> 
</tr>
<tr> <td><b>'+'</b></td> <td>show sign even for positive numbers</td> 
	    <td>sets <i>showpos</i></td> 
</tr>
<tr> 
	    <td><b>'#'</b></td> 
	    <td>show numerical base, and decimal point</td> 
	    <td>sets <i>showbase</i> and <i>showpoint</i></td> 
</tr>
<tr> 
	    <td><b>'0'</b></td> 
	    <td>pad with 0's (inserted after sign or base indicator)</td> 
	    <td>if not left-aligned, calls <i>setfill('0')</i> and sets <i>internal</i>
	     <br> Extra actions are taken after stream conversion to handle 
		  <a href="#user-defined">user-defined output</a>.  </td> 
</tr>
<tr> 
	    <td><b>' '</b></td> 
	    <td>if the string does not begin with <i>+</i> or <i>-</i>, 
	      insert a <i>space</i> before the converted string</td> 
	    <td>N/A (applied later on the string)
	      <br>Different to printf's behaviour : it is not affected by internal alignment</td> 
</tr>
-->
<tr> <td><b>'-'</b></td> <td>左寄せ</td> 
		<td>N/A (後で文字列に適用される)</td> 
</tr>
<tr> 
	    <td><b>'='</b></td> <td>中寄せ</td> 
	    <td>N/A (後で文字列に適用される)<br>
	      printf には存在しない<i>(追加機能)</i></td> 
</tr>
<tr> <td><b>'+'</b></td> <td>正の数であっても符号を表示する</td> 
	    <td><i>showpos</i> をセットする</td> 
</tr>
<tr> 
	    <td><b>'#'</b></td> 
	    <td>基数および小数点を表示する</td> 
	    <td><i>showbase</i> と <i>showpoint</i> をセットする</td> 
</tr>
<tr> 
	    <td><b>'0'</b></td> 
	    <td>0 で穴埋めする(符号および基数表示の後に挿入)</td> 
	    <td>左寄せでない場合、 <i>setfill('0')</i> を呼び出し <i>internal</i> をセットする
	     <br><a href="#user-defined">ユーザ定義型</a>を扱うためにストリーム変換の後に追加の動作を行う</td>
</tr>
<tr> 
	    <td><b>' '</b></td> 
	    <td>文字列が <i>+</i> または <i>-</i> から始まらない場合、変換された文字の前に <i>space</i> を挿入</td>
	    <td>N/A (後で文字列に適用される)
	      <br>printf のものとは挙動が異なる : 内部のアライメントには影響されない</td>
</tr>

</table>


<!--
<li>
<i>width</i> specifies a minimal width for the string resulting form the conversion.
If necessary, the string will be padded with alignment and fill characters either set on the stream via manipulators, or specified by the  format-string  (e.g. flags '0', '-', ..)
<br>
Note that width is not just set on the conversion stream. 
To support output of <a href="#user-defined">user-defined types</a>
(that might call <i>operator<<</i> many times on several members),
the width is handled after stream conversion of the whole argument object, 
in the format class code.
-->
<li>
<i>width</i> は変換の結果文字列に対する最小の幅を指定する。
必要ならば、文字列はアライメントにあわせてパディングされ、文字で埋める。この文字はマニピュレータ経由でストリームにセットされたものか、あるいは書式文字列で指定された文字(例． '0', '-', ... などのフラグ)である。
<br>
この幅は変換ストリームにセットされるのではないことに注意してほしい。
<a href="#user-defined">ユーザ定義型</a>の出力をサポートする(これはいくつかのメンバに <i>operator<< </i>を何度も呼び出すことになりうる)ため、幅の取り扱いはすべての引数オブジェクトのストリーム変換の後に、 format クラスのコードの中で行われる。
<!--
<li>
<i>precision</i> (preceded by a point), sets the stream's <i>precision</i>
<ul>
<li>When outputting a floatting type number, it sets the maximum number of digits 
	<ul><li>after decimal point when in fixed or scientific mode</li>
	  <li>in total when in default mode ('<i>general mode</i>', like <i>%g</i>) </li>
	</ul>
<li>When used with type-char <b>s</b> or <b>S</b> it takes another meaning : 
	the conversion string is truncated to the <i>precision</i> first chars.
 (Note that the eventual padding to <i>width</i> is done after truncation.)
</li></ul>
-->
<li>
<i>precision</i> (小数点の後に続く)はストリームの<i>精度</i>をセットする。
<ul>


<li>浮動少数点型の数値を出力する場合、
	<ul><li>固定小数点表示モードまたは指数表示モードでは、小数点より後ろの数字の最大文字数を設定する。</li>
	  <li>デフォルトモード(<i>%g</i> のような'<i>ジェネラルモード</i>')では、全体の数字の最大文字数を設定する。</li>
	</ul>
<li>type-char が <b>s</b> または <b>S</b> の場合は別の意味を持つ : 
	変換文字列は最初の <i>precision</i> 文字で切り詰められる。
 (<i>width</i> によるパディングは、この切り詰めの後で施される。)
</li></ul>

<!--
<li>
<i>type-char</i>. it does <b>not</b> impose the concerned argument to be of a restricted set 
of types, but merely sets the flags that are associated with this type specification.
-->
<li>
<i>type-char</i> 。これは、対象になっている引数が指定した型のいずれかであることを強要<b>しない</b>。その型指定子に関連付けられたフラグをセットするだけである。

<blockquote>
<!--
<table border="1" cellpadding="5">
<tr> 
		<td><b>Type-Char</b></td> 
		<td><b>Meaning</b></td> 
		<td><b>effect on stream</b></td> 
</tr>
<tr> 
	    <td><b>p or x</b></td> 
	    <td>hexadecimal output</td> 
	    <td>sets <i>hex</i></td> 
</tr>
<tr> 
	    <td><b>o</b></td> 
	    <td>octal output</td> 
	    <td>sets <i>oct</i></td> 
</tr>
<tr> 
	    <td><b>e</b></td> 
	    <td>scientific float format</td> 
	    <td>sets floatfield bits to <i>scientific</i></td> 
</tr>
<tr> 
	    <td><b>f</b></td> 
	    <td>fixed float format</td> 
	    <td>sets floatfield bits to <i>fixed</i></td> 
</tr>
<tr> 
	    <td><b>g</b></td> 
	    <td>general -default- float format</td> 
	    <td><b>unset</b> all floatfield bits</td> 
</tr>
<tr> 
	    <td><b>X, E</b> or <b>G</b></td> 
	    <td>same effect as their lowercase counterparts, 
		  but using uppercase letters for number outputs. (exponents, hex digits, ..)</td> 
	    <td>same effects as <i>'x'</i>, <i>'e'</i>, or <i>'g'</i>, 
		  <b>plus</b> <i>uppercase</i></td> 
</tr>

<tr> 
	    <td><b>d, i</b> or <b>u</b></td> 
	    <td><b>decimal</b> type output</td> 
	    <td>sets basefield bits to <i>dec</i></td> 
</tr>
<tr> 
	    <td><b>s</b> or <b>S</b></td> 
	    <td>string output</td> 
	    <td><i>precision</i> specification is unset, 
		  and its value goes to an internal field for later 'truncation'. 
		  (see <i>precision</i> explanation above) </td> 
</tr>
<tr> 
	    <td><b>c</b> or <b>C</b></td> 
	    <td>1-character output</td> 
	    <td>only the first character of the conversion string is used.</td> 
</tr>
<tr>
            <td><b>%</b></td>
            <td>print the character <i>%</i></td>
            <td>N/A</td>
</tr>
</table>
-->
<table border="1" cellpadding="5">
<tr> 
		<td><b>型変換指定文字</b></td> 
		<td><b>意味</b></td> 
		<td><b>ストリームへの作用</b></td> 
</tr>
<tr> 
	    <td><b>p または x</b></td> 
	    <td>１６進数で出力</td> 
	    <td><i>hex</i> をセットする</td> 
</tr>
<tr> 
	    <td><b>o</b></td> 
	    <td>８進数で出力</td> 
	    <td><i>oct</i> をセットする</td> 
</tr>
<tr> 
	    <td><b>e</b></td> 
	    <td>浮動小数点数の指数表記</td> 
	    <td>floatfield ビットを <i>scientific</i> にセットする</td> 
</tr>
<tr> 
	    <td><b>f</b></td> 
	    <td>浮動小数点数の固定小数点表記</td> 
	    <td>floatfield ビットを <i>fixed</i> にセットする</td> 
</tr>
<tr> 
	    <td><b>g</b></td> 
	    <td>一般的な -デフォルトの- 浮動小数点表記</td> 
	    <td>すべての floatfield ビットを<b>外す</b></td> 
</tr>
<tr> 
	    <td><b>X, E</b> または <b>G</b></td> 
	    <td>それぞれの小文字と同じように作用。ただし数値の出力に際して大文字を用いる。(指数、１６進数、..)</td>
	    <td><i>'x'</i>, <i>'e'</i>, または <i>'g'</i> と同じ作用に<b>加え</b>、 <i>uppercase</i> をセットする。</td>
</tr>

<tr> 
	    <td><b>d, i</b> または <b>u</b></td> 
	    <td><b>１０進数</b>で出力</td> 
	    <td>basefield ビットを <i>dec</i> にセットする</td> 
</tr>
<tr> 
	    <td><b>s</b> または <b>S</b></td> 
	    <td>文字列を出力</td>
	    <td><i>precision</i> 指定子が外され、値は後の'切り詰め'のために内部フィールドへ送られる。
          (上記の <i>precision</i> の説明を参照) </td>
</tr>
<tr> 
	    <td><b>c</b> または <b>C</b></td> 
	    <td>１文字出力</td> 
	    <td>変換文字列の最初の文字のみが用いられる。</td>
</tr>
<tr>
            <td><b>%</b></td>
            <td>文字<i>%</i>を表示</td>
            <td>N/A</td>
</tr>
</table>
<!--
<p>Note that the 'n' type specification is ignored (and so is the corresponding argument),
 because it does not fit in this context.
<br>
Also, printf 'l', 'L',  or 'h' modifiers (to indicate wide, long or short types) are supported
(and simply have no effect on the internal stream).
</p>
-->
<p>'n' 型指定子は、こうした流れに合わないので、無視される(そして対応する引数も)。
<br>
また、 printf の 'l', 'L', あるいは 'h' 修飾子(ワイド、ロングおよびショート型を示す)もサポートされている(が、内部ストリームには何の作用もしない)。
</p>

</li>
</ul>

<h3>new format-specifications</h3>
<a name="new_directives">
<ul>
<!--
<li> as stated in the flags table, a centered alignment flag ' <i>=</i> '  was added.
</li>
<li> <i><b>%{</b>n</i><b>t}</b> , where <i>n</i> is a positive number, 
        inserts an <i>absolute tabulation</i>.
        It means that format will, if needed, fill the string with characters, until
        the length of the string created so far reaches <i>n</i> characters.
        (see <a href="#examples">examples</a> )
</li>
<li> <b>%{</b><i>n</i><B>T</B><i>X</i><b>}</b> inserts a tabulation in the same way, 
	but using <i>X</i> as fill character instead of the current 'fill' char of the stream 
	(which is <i>space</i> for a stream in default state)
</li>
-->
<li>前述の表で述べたように、中寄せフラグ '<i>=</i>' が追加された。
</li>
<li> <i><b>%{</b>n</i><b>t}</b> は<i>絶対桁送り</i>を挿入する。ここで <i>n</i> は正の数である。
        すなわち format は、必要であれば、作成済みの文字列の長さが <i>n</i> 文字に届くまで文字で埋め込む。
        (<a href="#examples">examples</a> を参照)
</li>
<li> <b>%{</b><i>n</i><B>T</B><i>X</i><b>}</b> も同様に桁送りを挿入するが、埋め込む文字としてストリームの現在の'埋め込み'文字の代わりに <i>X</i> を用いる。
	(デフォルト状態のストリームでは <i>space</i> を埋め込む)
</li>
</ul>

<h2>Differences of behaviour vs printf</h2>
<a name="printf_differences">
<!--
<p>
Suppose you have variables <i>x1, x2</i> (built_in types, supported by C's printf),
<br> and a format string <i>s</i> intended for use with a printf function this way :
<BLOCKQUOTE><PRE>
printf(s, x1, x2);
</PRE></BLOCKQUOTE>
<br>
In almost all cases, the result will be the same as with this command :
<BLOCKQUOTE><PRE>
cout << format(s) % x1 % x2;
</PRE></BLOCKQUOTE>

But because some printf format specifications don't translate well into stream formatting options,
there are a few notable imperfections in the way Boost.format emulates printf.<br>
In any case, the <i>format</i> class should quietly ignore the unsupported options, so
that printf format-strings are always accepted by format and produce almost the same 
output as printf.
-->
<p>
<i>x1, x2</i> という二つの変数(組み込み型で、 C の printf でサポートされているもの)と書式文字列<i>s</i>があって、
<br>
printf 関数で以下のように使われるとする :
<BLOCKQUOTE><PRE>
printf(s, x1, x2);
</PRE></BLOCKQUOTE>
<br>
ほとんどすべてのケースで、その結果はこの命令と同じものになる :
<BLOCKQUOTE><PRE>
cout << format(s) % x1 % x2;
</PRE></BLOCKQUOTE>

しかしいくつかの printf 書式指定子はストリームの書式化オプションに上手く翻訳されないため、 Boost.format の printf エミュレーションには注意すべき僅かな不完全性がある。<br>
<i>format</i> クラスは、 printf の書式文字列を常に受け付けてほとんど同じ出力を生成するように、どのような場合でもサポートしないオプションを黙って無視する。
<!--
<br>Here is the full list of such differences :
<ul>
<li> <b>'0'</b> and <b>' '</b> options : 
printf ignores these options for non numeric conversions, but format applies them to all
types of variables.
(so it is possible to use those options on user-defined types, e.g. a Rational class, etc..)
</li>
<li> <b>precision</b> for integral types arguments has a special meaning for printf :
<br> <i> printf( "(%5.3d)" , 7 ) ;</i>  prints ?(  007) ?
<br> While format, like streams, ignores the precision parameter for integral types conversions.
</li>
<li> the <b>'</b> printf option 
(<i>format with thousands grouping characters)</i>)
has no effect in format. 
</li>
<li> Width or precision set to asterisk (<i>*</i>) are used by printf to read this field from 
an argument. e.g. 
<i>printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);</i>
<br>This class does not support this mechanism for now. so such precision or width fields are quietly 
ignored by the parsing. 
</ul>
-->
<br>以下はそうした相違点のすべての一覧である :
<ul>
<li> <b>'0'</b> および <b>' '</b> オプション : 
printf は数値以外の変換でこれらのオプションを無視するが、 format は変数のあらゆる型にそれらを適用する。
(そのためこれらのオプションをユーザ定義型に対して用いることができる。例． Rational クラスなど)
</li>
<li> 汎整数型の引数に対する <b>precision</b> は printf では特別な意味を持つ :
<br> <i> printf( "(%5.3d)" , 7 ) ;</i> は &laquo;(  007) &raquo; と出力する。
<br> 一方で format は、ストリームと同様に、汎整数型への変換に対する精度パラメータを無視する。
</li>
<li> printf の <b>'</b> オプション
(<i>三桁ごとに数値をグループ化する書式)</i>)
は format では無効である。
</li>
<li>printf では、幅または精度がアスタリスク (<i>*</i>) にセットされている場合、その値を与えられた引数から読み取る。例．
 <i>printf("%1$d:%2$.*3$d:%4$.*3$d\n", hour, min, precision, sec);</i> 
<span class="by_translator">[訳注：この例では、 min と sec を表示する際の精度は第三引数 precision の値が用いられる。 precision=3 なら "%.3d" だし、 precision=10 なら "%.10d" になる。]</span>
<br>このクラスは現在のところ、このメカニズムをサポートしない。そのためこのような精度または幅フィールドは構文解析の時点で黙って無視される。
</ul>

<!--
Also, note that the special <b>'n'</b> type-specification 
(used to tell printf to save in a variable the number of characters output by the formatting) 
has no effect in format. 
<br> Thus format strings containing this type-specification should produce the same converted 
string by printf or format. 
It will not cause differences in the formatted strings between printf and format.
<br>To get the number of characters in the formatted string using Boost.Format, 
do as follows :
<BLOCKQUOTE><PRE>
format formatter("%+5d");
cout << formatter % x;
unsigned int n = formatter.str().size();
</PRE></BLOCKQUOTE>
-->
同様に、特殊な <b>'n'</b> 型指定子
(書式化によって出力された文字数を変数に格納するよう printf に命じるのに用いる)
は format では無効である。
<br> そのためこの型指定子を含む書式文字列は printf でも format でも同じ変換文字列を生成する。 printf と format で書式化された文字列に違いは生じない。
<br>Boost.format で書式化された文字数をを得るには以下のようにする :
<BLOCKQUOTE><PRE>
format formatter("%+5d");
cout << formatter % x;
unsigned int n = formatter.str().size();
</PRE></BLOCKQUOTE>

</p>
<hr>
<h2>User-defined types output</h2>
<a name="user-defined">
<!--
<p> 
All flags which are translated into modification to the stream state 
act recursively within user-defined types.
( the flags remain active, and so does the desired format option, for each of
the '<<' operations that might be called by the user-defined class)
<br>e.g., with a reasonable class  Rational, we would have something like :
<BLOCKQUOTE><PRE>
Rational ratio(16,9);
cerr << format("%#x \n")  % ratio;  // -> "0x10/0x9 \n"
</PRE></BLOCKQUOTE>
</p>
-->
<p> 
ストリーム状態の修飾に翻訳されたすべてのフラグは、ユーザ定義型にも再帰的に作用する。
( フラグはアクティブなまま残るので、
ユーザ定義クラスによって呼ばれる各々の '<<' 演算に対しても、期待するオプションが渡される)
<br>例．妥当なクラス Rational なら次のようになる :
<BLOCKQUOTE><PRE>
Rational ratio(16,9);
cerr << format("%#x \n")  % ratio;  // -> "0x10/0x9 \n"
</PRE></BLOCKQUOTE>
</p>

<!--
<p>
It's a different story for other formatting options. For example, setting width applies 
to the final output produced by the object, not to each of its internal outputs, and
that's fortunate :
<BLOCKQUOTE><PRE>
cerr << format("%-8d")  % ratio;  // -> "16/9    "      and not    "16      /9       "
cerr << format("%=8d")  % ratio;  // -> "  16/9  "      and not    "   16   /    9   "
</PRE></BLOCKQUOTE>
</p>
<p>
<br>But so does the 0 and ' ' options (contrarily to '+' which is directly translated to the stream
state by <i>showpos</i>. But no such flags exist for the zero and space printf options)
<br>and that is less natural :
<p>
<BLOCKQUOTE><PRE>
cerr << format("%+08d \n")  % ratio;  // -> "+00016/9"
cerr << format("% 08d \n")  % ratio;  // -> "000 16/9"
</PRE></BLOCKQUOTE>
<p></p>
-->
<p>
その他の書式化オプションでは話は異なる。例えば、幅の設定はオブジェクトによって生成される最終出力に適用され、内部の各々の出力には適用されない。これは都合のいい話である :
<BLOCKQUOTE><PRE>
cerr << format("%-8d")  % ratio;  // -> "16/9    " であって、 "16      /9       " ではない
cerr << format("%=8d")  % ratio;  // -> "  16/9  " であって、 "   16   /    9   " ではない
</PRE></BLOCKQUOTE>
</p>
<p>
<br>しかし、 0 や ' ' オプションにも同様に働くため、不自然なことになってしまう。(意地の悪いことに、 '+' が <i>showpos</i> によってストリームの状態へと直接翻訳できるのに対して、 printf のゼロやスペースに当たるオプションはストリームには存在しない) :
<p>
<BLOCKQUOTE><PRE>
cerr << format("%+08d \n")  % ratio;  // -> "+00016/9"
cerr << format("% 08d \n")  % ratio;  // -> "000 16/9"
</PRE></BLOCKQUOTE>
<p></p>
<hr>
<h3>Manipulators, and internal stream state</h3>
<a name="manipulators">
<!--
<P>
The internal stream state of <B>format</B> is saved before 
and restored after output of an argument; therefore, the modifiers are not sticky and affect only
the argument they are applied to.
<br> The default state for streams, as stated by the standard, is :
precision 6, width 0, right alignment, and decimal flag set.
</P>
<P>
The state of the internal <B>format</B> stream can be changed by manipulators passed along 
with the argument; via the <i>group</i> function, like that :
<BLOCKQUOTE><PRE>
cout << format("%1% %2% %1%\n") % group(hex, showbase, 40) % 50; // prints "0x28 50 0x28\n"
</PRE></BLOCKQUOTE>

<br>When passing N items inside a 'group' Boost.format needs to process manipulators
diferently from regular argument, and thus using group is subject to the following constraints :
<ol>
<li>the object to be printed must be passed as the last item in the group</li>
<li>the first N-1 items are treated as manipulators, and if they do produce output, it is discarded
</li>
</ol>
-->
<P>
<B>format</B> の内部ストリームの状態は、引数を出力する直前に保存され、直後に復帰される。そのため、修飾子の影響は後まで引きづられずに、適用される引数にだけ作用する。
<br>ストリームのデフォルト状態は標準で述べられているように :
精度 6 、幅 0 、右寄せ、そして１０進数基数である。
</P>
<P>
<B>format</B> ストリームの内部ストリームの状態は引数と一緒に渡されるマニピュレータによって変えることができる； <i>group</i> 関数を経由して以下のようにできる :
<BLOCKQUOTE><PRE>
cout << format("%1% %2% %1%\n") % group(hex, showbase, 40) % 50; // "0x28 50 0x28\n" と表示
</PRE></BLOCKQUOTE>

<br>'group' の内側にある N 個の項目を渡すとき、 Boost.format はマニピュレータに通常の引数とは異なる処理をする必要がある。そのため、 group の使用には以下の制限がある :
<ol>
<li>表示されるオブジェクトは group の最後の項目として渡されなければならない</li>
<li>先頭の N-1 個の項目はマニピュレータとして扱われるので、出力を生成しても破棄される
</li>
</ol>


<!--
<br>
Such manipulators are passed to the streams right before the following argument, 
at every occurence.
Note that formatting options specified within the format string are overridden
by stream state modifiers passed this way. For instance in the following code,
the <i>hex</i> manipulator has priority over the <i>d</i> type-specification in
 the format-string which would set decimal output :
<BLOCKQUOTE><PRE>
cout << format("%1$d %2% %1%\n") % group(hex, showbase, 40) % 50; 
// prints "0x28 50 0x28\n"
</PRE></BLOCKQUOTE>
</P>
-->
<br>
マニピュレータは、それが現れるごとに、後に続く引数の直前にストリームに渡される。
書式文字列で指定された書式化オプションは、この方法で渡されたストリーム状態修飾子によって上書きされる点に注意して欲しい。
例えば以下のコードで、 <i>hex</i> マニピュレータは、書式文字列の中で１０進数出力を設定している型指定子 <i>d</i> よりも高い優先度を持つ :
<BLOCKQUOTE><PRE>
cout << format("%1$d %2% %1%\n") % group(hex, showbase, 40) % 50; 
// "0x28 50 0x28\n" と表示
</PRE></BLOCKQUOTE>
</P>

</p>

<H2>Alternatives</H2> 
<ul>
<!--
<li>
<B>printf</B> is the classical alternative, that is not type safe and not extendable to user-defined types.
<li>
<a href="http://www.ece.ucdavis.edu/~kenelson/ofrstream.cc">ofrstream.cc</a> 
	by Karl Nelson's design was a big source of inspiration to this format class.
</li>
<li><a href="http://groups.yahoo.com/group/boost/files/format/">format.hpp</a> 
	By Riger Loo. It was a previous proposition for a boost::format class.
	It was an other source for this one, complementary to Karl's,
	in simplicity of design, and minimalistic "%1 %2" syntax - 
	which this class borrowed.
</li>
<li><a href="http://www.gabi-soft.de/code/gabi-lib.tgz">James Kanze's library</a>
	has a format class (in <i>srcode/Extended/format</i> ) which looks 
	very well polished. Its design has in common with this class the use of internal stream
	for the actual conversions, as well as using operators to pass arguments. 
	(but his class, as ofrstream, uses <i>operator<< </i> rather <i>than operator%</i> )
</li>
<li><a href="http://groups.yahoo.com/group/boost/files/format3/">Karl Nelson's library</a>
        was intented as demonstration of alternative solutions 
        in discussions on Boost's list for the design of Boost.format.
</li>
-->
<li>
<B>printf</B> は古典的な代替手段である。型安全でなく、ユーザ定義型に対して拡張可能ではない。
<li>
<a href="http://www.ece.ucdavis.edu/~kenelson/ofrstream.cc">ofrstream.cc</a> 
	Karl Nelson によるデザインはこの format クラスへのインスピレーションの大きな源となった。
</li>
<li><a href="http://groups.yahoo.com/group/boost/files/format/">format.hpp</a> 
	R&uuml;iger Loo による。 boost:format クラスの以前の提案だった。
	デザインの簡易さにおいてこのクラスの起源である。最小主義的な "%1 %2" という構文はこのクラスでも借用している。
</li>
<li><a href="http://www.gabi-soft.de/code/gabi-lib.tgz">James Kanze's library</a> 
	は非常に洗練された format クラス (<i>srcode/Extended/format</i>) を持っている。
	そのデザインは、実際の変換に内部ストリームを用いる点や引数渡しに演算子を用いる点で、このクラスと共通している。
	(しかし彼のクラス ofrstream は <i>operator%</i> ではなく <i>operator<<</i> を用いている)
</li>
<li><a href="http://groups.yahoo.com/group/boost/files/format3/">Karl Nelson's library</a> 
        は、 Boost.format のデザインのための boost メーリングリストの討論において、別の解決法を示すために用意された。
</li>
</ul>


<hr>
<H2>Exceptions</H2>
<a name="exceptions">
<!--
<p>
Boost.format enforces a number of rules on the usage of format objects. The format-string must obeys 
the syntax described above, the user must supply exactly the right number of arguments before outputting to the final destination, and if using modify_item or bind_arg, items and arguments index
must not be out of range.
<br>
When format detects that one of these rules is not satisfied, it raises a corresponding exception, 
so that the mistakes don't go unnoticed and unhandled.
<br>
But the user can change this behaviour to fit his needs, 
and select which types of errors may raise exceptions  using the following functions :
<BLOCKQUOTE><PRE>

unsigned char exceptions(unsigned char newexcept); // query and set
unsigned char exceptions() const;                  // just query

</PRE></BLOCKQUOTE>
</p>
-->
<p>
Boost.format は format オブジェクトの使い方にいくつかのルールを強要する。書式文字列は前述の構文に従わなくてはならず、ユーザは最終的な出力までに正しい個数の引数を供給しなければならない。また modify_item や bind_arg を用いるなら、項目や引数のインデックスが範囲外を指してはならない。
<br>
ミスが見過ごされたり放置されたりしないように、 format はいずれかのルールが満たされていないことを検出すると対応する例外を発生する。
<br>
しかしユーザはこの振る舞いを必要に応じて変えることができる。また、どのエラーの型が発生するかを次の関数を用いて選択できる :
<BLOCKQUOTE><PRE>

unsigned char exceptions(unsigned char newexcept); // クエリおよび設定
unsigned char exceptions() const;                  // クエリのみ

</PRE></BLOCKQUOTE>
</p>

<!--
<p>
The user can compute the argument <i>newexcept</i> by combining the following atoms using binary arithmetic :

<ul>
<li> <b>boost::io::bad_format_string_bit</b> selects errors due to ill-formed format-strings.
</li>

<li> <b>boost::io::too_few_args_bit</b> selects errors due to asking for the srting result before all arguments are passed.
</li>

<li> <b>boost::io::too_many_args_bit</b>  selects errors due to passing too many arguments.
</li>

<li> <b>boost::io::out_of_range_bit</b> select errors due to out of range index supplied by the user when calling 
        <i>modify_item</i> or other functions taking an item index (or an argument index)
</li>

<li> <b>boost::io::all_error_bits</b> selects all errors
</li>

<li> <b>boost::io::no_error_bits</b> selects no error.
</li>
        
</ul>
-->
<p>
ユーザは、以下のアトムを２進演算で結合することで引数 <i>newexcept</i> を算出できる :

<ul>
<li> <b>boost::io::bad_format_string_bit</b> 書式文字列が適切でなければ例外を発生する。
</li>

<li> <b>boost::io::too_few_args_bit</b> すべての引数が渡される前に結果の文字列を尋ねられたとき、例外を発生する。
</li>

<li> <b>boost::io::too_many_args_bit</b> 渡された引数の数が多すぎれば例外を発生する。
</li>

<li> <b>boost::io::out_of_range_bit</b> <i>modify_item</i> や項目インデックスを取る他の関数の呼び出し(および引数のインデックス）の際に、ユーザの与えたインデックスが範囲外であれば例外を発生する。
</li>

<li> <b>boost::io::all_error_bits</b> すべてのエラーで例外を発生する。
</li>

<li> <b>boost::io::no_error_bits</b> いずれのエラーでも例外を発生しない。
</li>
        
</ul>

<!--
For instance, if you don't want Boost.format to detect bad number of arguments, you can define
a specific wrapper function for building format objects with the right exceptions settings :

<BLOCKQUOTE><PRE>

boost::format  my_fmt(const std::string & f_string) {
    using namespace boost::io;
    format fmter(f_string);
    fmter.exceptions( all_error_bits ^ ( too_many_args_bit | too_few_args_bit )  );
    return fmter;
}

</PRE></BLOCKQUOTE>

It is then allowed to give more arguments than needed  (they are simply ignored) :

<BLOCKQUOTE><PRE>

cout << my_fmt(" %1% %2% \n") % 1 % 2 % 3 % 4 % 5;

</PRE></BLOCKQUOTE>

And if we ask for the result before all arguments are supplied, the corresponding part of the
result is simply empty

<BLOCKQUOTE><PRE>

cout << my_fmt(" _%2%_ _%1%_ \n") % 1 ;
// prints      " __ _1_ \n"

</PRE></BLOCKQUOTE>
-->
例えば、 Boost.format が引数の個数をチェックしないようにしたければ、適切な例外設定を施した format オブジェクトを作る特殊なラッパ関数を定義する :

<BLOCKQUOTE><PRE>

boost::format  my_fmt(const std::string & f_string) {
    using namespace boost::io;
    format fmter(f_string);
    fmter.exceptions( all_error_bits ^ ( too_many_args_bit | too_few_args_bit )  );
    return fmter;
}

</PRE></BLOCKQUOTE>

すると、必要とされるよりも多くの引数を与えても許される(単に無視される) :

<BLOCKQUOTE><PRE>

cout << my_fmt(" %1% %2% \n") % 1 % 2 % 3 % 4 % 5;

</PRE></BLOCKQUOTE>

また、すべての引数が与えられる前に結果を問い合わせると、結果の対応する部分は単に空になる

<BLOCKQUOTE><PRE>

cout << my_fmt(" _%2%_ _%1%_ \n") % 1 ;
// prints      " __ _1_ \n"

</PRE></BLOCKQUOTE>
</p>


<hr>
<H2>Extract</H2>
<BLOCKQUOTE><PRE>namespace boost {

template&lt;class charT, class Traits=std::char_traits&lt;charT&gt; &gt; 
class basic_format 
{
public:
  typedef std::basic_string&lt;charT, Traits&gt string_t,
  basic_format(const charT* str);
  basic_format(const charT* str, const std::locale & loc);
  basic_format(const string_t& s);
  basic_format(const string_t& s, const std::locale & loc);

  string_t str() const;

  // pass arguments through those operators :
  template&lt;class T&gt;  basic_format&   operator%(T& x);  
  template&lt;class T&gt;  basic_format&   operator%(const T& x);

  // dump buffers to ostream :
  friend std::basic_ostream&lt;charT, Traits&gt;& 
  operator&lt;&lt; &lt;&gt; ( std::basic_ostream&lt;charT, Traits&gt;& , basic_format& ); 

// ............  これはただの抜粋である .......
}; // basic_format

typedef basic_format&lt;char &gt;          format;
typedef basic_format&lt;wchar_t &gt;      wformat;


namespace io {
// free function for ease of use :
template&lt;class charT, class Traits&gt; 
std::basic_string&lt;charT,Traits&gt;  str(const basic_format&lt;charT,Traits&gt;& f) {
      return f.str();
}
} //namespace io


} // namespace boost
</PRE></BLOCKQUOTE>
<P>
</P>
<hr>
<H2>Rationale</H2>
<!--
<p>This class's goal is to bring a better, C++, type-safe and type-extendable <i>printf</i> 
      equivalent to be used with streams.
</p>
Precisely, <b>format</b> was designed to provide the following features :
<ul>
<li> support positional arguments (required for internationalisation)
<li> accept an unlimited number of arguments.
<li> make formatting commands visually natural.
<li> support the use of manipulators to modify the display of an argument.
     in addition to the format-string syntax.
<li> accept any types of variables, by relying on streams for the actual conversion
     to string. This specifically concerns user-defined types, for which the formatting
     options effects should be intuitively natural.
<li> provide printf-compatibility, as much as it makes sense in a type-safe and type-extendable
     context.
</li>
</ul>
<p> In the process of the design, many issues were faced, and some choices were made, that
      might not be intuitively right. But in each case they were taken for 
      <a href="choices.html">some reasons</a>.
</p>
-->
<p>このクラスのゴールは、より良い、 C++ 用の、型安全かつ型拡張性のある <i>printf</i> の等価物が、
      ストリームとともに用いられるようにすることである。
</p>
正確には、 <b>format</b> は以下の機能を実現するようデザインされた :
<ul>
<li> 引数の位置指定のサポート(国際化に必要)
<li> 個数無制限の引数を許す。
<li> 書式化命令の見た目を自然にする。
<li> 書式文字列の構文に加えて、引数の出力を修飾するためのマニピュレータをサポー
ト。</font>
<li> あらゆる型の変数を受け付ける。文字列への実際の変換はストリームに任せる。
     これは特にユーザ定義型について、書式化オプションの作用が直観的に自然なものとなるよう考慮したものである。
<li>printf 互換性の提供、型安全で型拡張性のある文脈においてもできるだけ意味をなすようにする。
</li>
</ul>
<p> デザインの過程で多くの問題に直面し、いくつかの選択をすることになったが、
      中には直観的には正しくないものもあった。しかしいずれのケースにも
      <a href="choices.html">何らかの意味がある</a>。
</p>
<hr>
<H2>Credits</H2>
<!--
<P>The author of Boost format is Samuel Krempp. &nbsp; He used ideas from both
    R&uuml;iger Loos' and Karl Nelson's formatting classes.
<HR>

<P>February 19, 2002</P>
<P>?Copyright Samuel Krempp 2002. Permission to copy, use, modify, sell and 
distribute this document is granted provided this copyright notice appears in 
all copies. This document is provided "as is" without express or implied 
warranty, and with no claim as to its suitability for any purpose.</P>
<P></P>
-->
<P>Boost format の著者は Samuel Krempp である。 &nbsp; 彼は
    R&uuml;iger Loos と Karl Nelson の両者の format クラスのアイディアを利用した。
<HR>

<P>February 19, 2002</P>
<P>&copy; Copyright Samuel Krempp 2002. Permission to copy, use, modify, sell and 
distribute this document is granted provided this copyright notice appears in 
all copies. This document is provided "as is" without express or implied 
warranty, and with no claim as to its suitability for any purpose.</P>
<P></P>

<p>Japanese Translation Copyright &copy; 2003 <a href="mailto:kn@mm.neweb.ne.jp">Kent.N</a><br> 
<small><i>オリジナルの、及びこの著作権表示が全ての複製の中に現れる限り、この文書の複製、利用、変更、販売そして配布を認める。このドキュメントは「あるがまま」に提供されており、いかなる明示的、暗黙的保証も行わない。また、いかなる目的に対しても、その利用が適していることを関知しない。</i></small></p>
<P>&nbsp;</P></BODY></HTML>
